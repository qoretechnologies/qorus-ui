{"workflowid": 127,"name": "DEPRECATEDTEST","version": "1.0","description": "H3G UK PO Receipt inbound","author": "Marian Bonda","autostart": 0,"manual_autostart": false,"errorfunction_instanceid": 35,"attach_func_instanceid": 29,"onetimeinit_func_instanceid": 399,"created": "2099-01-20 12:56:47.120340 +01:00","modified": "2019-01-20 12:56:47.120340 +01:00","enabled": true,"deprecated": true,"keylist": ["isepl-filename","filename","uuid","parent","parent_write"],"stepmap": {"206": "mapls_rma_receipt_inem_update_oracle","197": "mapls_rma_receipt_scmhub_get","65": "mapls_scmhub_update","66": "mapls_scmhub_map_split","199": "mapls_rma_receipt_scmhub","68": "mapls_scmhub_write_split","200": "mapls_update_order_id","69": "mapls_update_complete","201": "mapls_rma_trigger_mip32","202": "mapls_rma_trigger_mip37","203": "mapls_rma_create_mip21_data"},"steps": {"206": [],"197": [206],"65": [197],"66": [65],"199": [66],"68": [199],"200": [68],"69": [200],"201": [69],"202": [69],"203": [69]},"segment": [{"steplist": [206,197,65,66,199,68,200,69,201,202,203],"steps": {"206": [],"197": [206],"65": [197],"66": [65],"199": [66],"68": [199],"200": [68],"69": [200],"201": [69],"202": [69],"203": [69]}},{"steplist": [201],"steps": {"201": []},"start": 201,"subworkflow": true,"linksegment": 0,"linkstepid": 201}],"stepseg": {"201": 1},"lib": {"functions": [{"name": "sepl-lib","version": "1.0","id": 32,"function_type": "GENERIC","description": "Common SEPL library functions","author": "David Nichols (Qore Technologies, sro)","body": "%require-types\n#%requires OracleExtensions\n\n#! base dir for APEX files inbound\nconst ApexBaseDirIn = \"/appl/data/mseplftp/$cc/opco/in\";\n\n#! source system: Retail Java\nconst SS_RetailJava = \"RJ\";\n\n#! source system: UTL\nconst SS_UTL = \"UTL\";\n\n#! source system: SG\nconst SS_SG = \"SG\";\n\n#! source system: Sonopress\nconst SS_Sonopress = \"ADS\";\n\n#! source system: VCC\nconst SS_VCC = \"VCC\";\n\n#! source system: APEX\nconst SS_Apex = \"APEX\";\n\n#! source system: GEMALTO\nconst SS_Gemalto = \"GEMALTO\";\n\n#! source system: Orange SAP\nconst SS_OrangeSAP = \"OrangeSAP\";\n\n#! source system: SPL\nconst SS_SPL = \"SPL\";\n\n#! optional HTTP properties that can be set in HTTP objects\n/* the following are valid property names that can be applied to HTTP objects\n*/\nconst SeplHttpProps = (\n    \"timeout\",          # read timeout in milliseconds\n    \"connect_timeout\",  # connect timeout in milliseconds\n    \"proxy\",            # proxy URL (if any should be used)\n    #\"max_redirects\",    # maximum number of redirects\n    );\n\n#! default subdirectory names for file processing\nconst FileDefaults = (\n    \"arch\":    \"arch\",\n    \"archive\": \"archive\",\n    \"import\":  \"import\",\n    \"output\":  \"output\",\n    \"discard\": \"discard\",\n    \"work\":    \"work\",\n    \"error\":   \"error\",\n    \"tmp\":     \"tmp\",\n    \"temp\":    \"tmp\",\n\n    \"base_path\"             : \"/appl/data/mseplftp/$cc/rj\",\n    \"utl_base_path\"         : \"/appl/data/mseplftp/uk/utl\",\n    \"vcc_base_path\"         : \"/appl/data/mseplftp/uk/vcc\",\n    \"gemalto_base_path\"     : \"/appl/data/mseplftp/$cc/gemalto\",\n    \"b4n_base_path\"         : \"/appl/data/mseplftp/$cc/b4n\",\n    \"sono_base_path\"        : \"/appl/data/mseplftp/ie/sono\",\n    \"bhub_base_path_in\"     : \"/var/opt/bhub/mseplftp/$cc/opco/in\",\n    \"bhub_base_path_out\"    : \"/var/opt/bhub/mseplftp/$cc/opco/out\",\n    \"orange_gl_base_path\"   : \"/appl/data/mseplftp/at/orange-gl\",\n    \"orange_rmca_base_path\" : \"/appl/data/mseplftp/at/orange-rmca\",\n    \"spl_base_path\"         : \"/appl/data/mseplftp/at/spl\",\n    \"icrs_ap_base_path\"     : \"/appl/data/mseplftp/at/icrs-ap-in\",\n    \"icrs_ar_base_path\"     : \"/appl/data/mseplftp/at/icrs-ar-in\",\n    \"icrs_gl_base_path\"     : \"/appl/data/mseplftp/at/icrs-gl-in\",\n    \"sepl_at_base_path\"     : \"/appl/data/mseplftp\", # root dir for shared dir in Austria\n    \"sepl_at_sg_base_path\"  : \"/it/SG\",\n\n    # defaults for \"end system\" subdirectories\n    \"erp_to_vcc\"         : \"erp_to_vcc\",       # VCC outbound: MIPs 1, 2:\n    \"vcc_to_erp\"         : \"vcc_to_erp\",       # VCC inbound: MIP 49:\n    \"erp_to_psft\"        : \"erp_to_psft\",      # PSFT outbound: MIP 23:\n    \"erp_to_dupp\"        : \"erp_to_dupp\",      # DUPP outbound: MIP 24:\n    \"erp_to_cfs\"         : \"erp_to_cfs\",\n    \"erp_to_mvno\"        : \"erp_to_numeriq\",   # MVNO/Numeriq outbound: MIP 24:\n    \"gemalto_to_erp\"     : \"gemalto_to_erp\",   # Gemalto inbound: MIP 24:\n    \"erp_to_ota\"         : \"erp_to_ota\",       # OTA outbound: MIP18a\n    \"gl_journal\"         : \"billing_journal\",  # GL_JOURNAL\n    \"content\"            : \"content\",          # CONTENT\n    \"other_ap_invoice\"   : \"other_ap_invoice\", # OTHER_AP_INVOICE\n    \"sap2erp_journal\"    : \"sap_journal\",      # SAP2ERP_JOURNAL\n    \"mip1_email_exports\" : \"master_data_item\", # MIP1 email exports -archive\n);\n\n#! required tags for the submit method\nconst InboundDataTags = (\"source_system\", \"filename\", \"msepl\", \"msepl_instance\");\n\n#*OracleExtensions::OracleApplicationInfo sub getAutoInfo() {\n#\n#    my *OracleExtensions::OracleApplicationInfo $ret = NOTHING;\n#\n#%ifdef QorusWorkflow\n#    my *hash $sinfo = getStepInfo();\n#    my hash $info = getWorkflowMetadata();\n#    $ret = new OracleExtensions::OracleApplicationInfo(getSystemInfo().\"instance-key\",\n#                                     sprintf(\"%s.%s\", $info.name, $info.version),\n#                                     $sinfo.name\n#                                    );\n#%endif\n#%ifdef QorusService\n#    my hash $info = getServiceInfo();\n#    $ret = new OracleExtensions::OracleApplicationInfo(getSystemInfo().\"instance-key\",\n#                                     sprintf(\"%s:%s.%s\", $info.type, $info.name, $info.version),\n#                                     $info.method\n#                                    );\n#%endif\n#    return $ret;\n#}\n\n#! wrapper for the Datasource class when communicating with EBS; acquires a dedicated Datasource from the datasource service\n/** wraps each call with a try/catch block and calls sepl_check_db_error() as needed\n*/\nclass OracleDatasource inherits AbstractDatasource {\n    private {\n        Datasource $.ds;\n        string $.dsn;\n        bool $.fromds = False;\n    }\n\n    # creates the object based on a dedicated datasource acquired from the datasource service from the datasource name passed as an argument\n    /** @param $name the datasource name\n    */\n    constructor(string $name) {\n        $.dsn = $name;\n\t$.assignDS();\n    }\n\n    # creates the object based on a dedicated datasource passed as an argument\n    /** @param $ds the datasource\n    */\n    constructor(Datasource $ds) {\n        $.dsn = $ds.getDBName();\n        $.ds = $ds;\n        $.fromds = True;\n    }\n\n    string name() {\n        return $.dsn;\n    }\n\n    #! get \"raw\" qore Datasource instance used in this wrapper; used in OracleSQLStatement and elsewhere\n    Datasource datasource() {\n        return $.ds;\n    }\n\n    nothing beginTransaction() {\n        $.execIntern(\"beginTransaction\");\n    }\n\n    nothing commit() {\n        $.execIntern(\"commit\");\n    }\n\n    any exec(string $sql) {\n        return $.execIntern(\"vexec\", ($sql, $argv));\n    }\n\n    any execRaw(string $sql) {\n        return $.execIntern(\"execRaw\", $sql);\n    }\n\n    any getClientVersion() {\n        return $.execIntern(\"getClientVersion\");\n    }\n\n    string getDBEncoding() {\n        return $.execIntern(\"getDBEncoding\");\n    }\n\n    *string getDBName() {\n        return $.execIntern(\"getDBName\");\n    }\n\n    string getDriverName() {\n        return $.execIntern(\"getDriverName\");\n    }\n\n    *string getHostName() {\n        return $.execIntern(\"getHostName\");\n    }\n\n    *string getOSEncoding() {\n        return $.execIntern(\"getOSEncoding\");\n    }\n\n    *string getPassword() {\n        return $.execIntern(\"getPassword\");\n    }\n\n    *int getPort() {\n        return $.execIntern(\"getPort\");\n    }\n\n    any getServerVersion() {\n        return $.execIntern(\"getServerVersion\");\n    }\n\n    *string getUserName() {\n        return $.execIntern(\"getUserName\");\n    }\n\n    bool inTransaction() {\n        return $.execIntern(\"inTransaction\");\n    }\n\n    nothing rollback() {\n        $.execIntern(\"rollback\");\n    }\n\n    any select(string $sql) {\n        return $.execIntern(\"vselect\", ($sql, $argv));\n    }\n\n    any selectRow(string $sql) {\n        return $.execIntern(\"vselectRow\", ($sql, $argv));\n    }\n\n    any selectRows(string $sql) {\n        return $.execIntern(\"vselectRows\", ($sql, $argv));\n    }\n\n    any vexec(string $sql, *softlist $vargs) {\n        return $.execIntern(\"vexec\", ($sql, $vargs));\n    }\n\n    any vselect(string $sql, *softlist $vargs) {\n        return $.execIntern(\"vselect\", ($sql, $vargs));\n    }\n\n    any vselectRow(string $sql, *softlist $vargs) {\n        return $.execIntern(\"vselectRow\", ($sql, $vargs));\n    }\n\n    any vselectRows(string $sql, *softlist $vargs) {\n        return $.execIntern(\"vselectRows\", ($sql, $vargs));\n    }\n\n    string getConfigString() {\n        # this will cause a runtime error if called and not supported\n        my object $o = $self;\n        return $o.getConfigString();\n    }\n\n    hash getConfigHash() {\n        # this will cause a runtime error if called and not supported\n        my object $o = $self;\n        return $o.getConfigHash();\n    }\n\n    #! wrapper for method calls to the Datasource class when communicating with Oracle; wraps each call with a try/catch block and calls sepl_check_db_error() as needed\n    /** @return the return value of the Datasource method\n    */\n    private any execIntern(string $m, *softlist $args) {\n        try {\n            return callObjectMethodArgs($.ds, $m, $args);\n        }\n\tcatch ($ex) {\n            # check for common db errors and throw the appropriate exception\n            sepl_check_db_error($ex, $.dsn, \\$.reset());\n            # if the above function did not throw any exceptions, then rethrow the current exception\n            rethrow;\n        }\n    }\n\n    #! wrapper for unimplemented method calls to the Datasource class when communicating with Oracle; wraps each call with a try/catch block and calls sepl_check_db_error() as needed\n    /** @return the return value of the Datasource method\n    */\n    any methodGate(string $m) {\n        return $.execIntern($m, $argv);\n    }\n\n    #! get a value from a sequence using error handling\n    softint getNextSequenceValue(string $s) {\n        try {\n%ifdef QoreDebug\n            if ($.ds.getDriverName() == \"pgsql\")\n       \t        return string($.ds.selectRow(sprintf(\"select nextval('%s');\", $s)).nextval);\n%endif\n            return $.ds.selectRow(sprintf(\"select %s.nextval from dual\", $s)).nextval;\n\t}\n\tcatch ($ex) {\n            # check for common db errors and throw the appropriate exception\n            sepl_check_db_error($ex, $.dsn, \\$.reset());\n            # if the above function did not throw any exceptions, then rethrow the current exception\n            rethrow;\n        }\n    }\n\n    #! handles reset events during an exception\n    private reset() {\n        # release any locks and ignore the exception if in a transaction\n        if ($.ds.inTransaction())\n            try $.ds.rollback(); catch () {}\n        $.assignDS();\n    }\n\n    #! assigns the internal connection object\n    private assignDS() {\n\ttry {\n            if ($.fromds)\n                $.ds = $.ds.copy();\n            else {\n                #$.ds = $omqservice.system.datasource.getDedicated($.dsn);\n%ifdef QoreDebug\n                my Datasource $ds = $omqservice.system.datasource.getDedicated($.dsn);\n                #if ($ds.getDriverName() == \"oracle\")\n                #    $.ds = new OracleExtensions::OracleDatasource($ds, \\getAutoInfo());\n                #else\n                    $.ds = $ds;\n%else\n                #$.ds = new OracleExtensions::OracleDatasource($omqservice.system.datasource.getDedicated($.dsn), \\getAutoInfo());\n                $.ds = $omqservice.system.datasource.getDedicated($.dsn);\n%endif\n            }\n        }\n\tcatch ($ex) {\n\t    # rethrow the exception such that it matches a preconfigured error string\n\t    if ($ex.err =~ /ORACLE/)\n\t\tthrow DATASOURCE_ERROR, sprintf(\"%s:%d: %s: %s\", $ex.file, $ex.line, $ex.err, $ex.desc);\n\t    # otherwise rethrow the exception as is\n\t    rethrow;\n\t}\n    }\n}\n\n#! wrapper for the DatasourcePool class when communicating with EBS; acquires a DatasourcePool from the datasource service\n/** wraps each call with a try/catch block and calls sepl_check_db_error() as needed\n*/\nclass OracleDatasourcePool inherits AbstractDatasource {\n    private {\n        DatasourcePool $.ds;\n        string $.dsn;\n        bool $.fromds = False;\n    }\n\n    # creates the object based on a dedicated datasource pool acquired from the datasource service from the datasource name passed as an argument\n    /** @param $name the datasource name\n    */\n    constructor(string $name) {\n        $.dsn = $name;\n        $.assignDS();\n    }\n\n    # creates the object based on a dedicated datasource pool passed as an argument\n    /** @param $ds the datasource pool\n    */\n    constructor(DatasourcePool $ds) {\n        $.dsn = $ds.getDBName();\n        $.ds = $ds;\n        $.fromds = True;\n    }\n\n    string name() {\n        return $.dsn;\n    }\n\n    DatasourcePool datasource() {\n        return $.ds;\n    }\n\n    nothing beginTransaction() {\n        $.execIntern(\"beginTransaction\");\n    }\n\n    nothing commit() {\n        $.execIntern(\"commit\");\n    }\n\n    any exec(string $sql) {\n        return $.execIntern(\"vexec\", ($sql, $argv));\n    }\n\n    any execRaw(string $sql) {\n        return $.execIntern(\"execRaw\", $sql);\n    }\n\n    any getClientVersion() {\n        return $.execIntern(\"getClientVersion\");\n    }\n\n    string getDBEncoding() {\n        return $.execIntern(\"getDBEncoding\");\n    }\n\n    *string getDBName() {\n        return $.execIntern(\"getDBName\");\n    }\n\n    string getDriverName() {\n        return $.execIntern(\"getDriverName\");\n    }\n\n    *string getHostName() {\n        return $.execIntern(\"getHostName\");\n    }\n\n    *string getOSEncoding() {\n        return $.execIntern(\"getOSEncoding\");\n    }\n\n    *string getPassword() {\n        return $.execIntern(\"getPassword\");\n    }\n\n    *int getPort() {\n        return $.execIntern(\"getPort\");\n    }\n\n    any getServerVersion() {\n        return $.execIntern(\"getServerVersion\");\n    }\n\n    *string getUserName() {\n        return $.execIntern(\"getUserName\");\n    }\n\n    bool inTransaction() {\n        return $.execIntern(\"inTransaction\");\n    }\n\n    nothing rollback() {\n        $.execIntern(\"rollback\");\n    }\n\n    any select(string $sql) {\n        return $.execIntern(\"vselect\", ($sql, $argv));\n    }\n\n    any selectRow(string $sql) {\n        return $.execIntern(\"vselectRow\", ($sql, $argv));\n    }\n\n    any selectRows(string $sql) {\n        return $.execIntern(\"vselectRows\", ($sql, $argv));\n    }\n\n    any vexec(string $sql, *softlist $vargs) {\n        return $.execIntern(\"vexec\", ($sql, $vargs));\n    }\n\n    any vselect(string $sql, *softlist $vargs) {\n        return $.execIntern(\"vselect\", ($sql, $vargs));\n    }\n\n    any vselectRow(string $sql, *softlist $vargs) {\n        return $.execIntern(\"vselectRow\", ($sql, $vargs));\n    }\n\n    any vselectRows(string $sql, *softlist $vargs) {\n        return $.execIntern(\"vselectRows\", ($sql, $vargs));\n    }\n\n    string getConfigString() {\n        # this will cause a runtime error if called and not supported\n        my object $o = $self;\n        return $o.getConfigString();\n    }\n\n    hash getConfigHash() {\n        # this will cause a runtime error if called and not supported\n        my object $o = $self;\n        return $o.getConfigHash();\n    }\n\n    #! wrapper for method calls to the Datasource class when communicating with Oracle; wraps each call with a try/catch block and calls sepl_check_db_error() as needed\n    /** @return the return value of the Datasource method\n    */\n    private any execIntern(string $m, *softlist $args) {\n        try {\n            return callObjectMethodArgs($.ds, $m, $args);\n        }\n\tcatch ($ex) {\n%ifdef QorusHasHttpUserIndex\n            log(LL_INFO, \"%s: %s: %s\", get_ex_pos($ex), $ex.err, $ex.desc);\n%else\n            log(LL_INFO, \"%s:%d: %s: %s\", $ex.file, $ex.line, $ex.err, $ex.desc);\n%endif\n            # check for common db errors and throw the appropriate exception\n            sepl_check_db_error($ex, $.dsn, \\$.reset());\n            # if the above function did not throw any exceptions, then rethrow the current exception\n            rethrow;\n        }\n    }\n\n    #! wrapper for method calls to the Datasource class when communicating with EBS; wraps each call with a try/catch block and calls sepl_check_db_error() as needed\n    /* @return the return value of the Datasource method\n    */\n    any methodGate(string $m) {\n        return $.execIntern($m, $argv);\n    }\n\n    #! get a value from a sequence using error handling\n    softint getNextSequenceValue(string $s) {\n        try {\n%ifdef QoreDebug\n            if ($.ds.getDriverName() == \"pgsql\")\n       \t        return string($.ds.selectRow(sprintf(\"select nextval('%s');\", $s)).nextval);\n%endif\n            return $.ds.selectRow(sprintf(\"select %s.nextval from dual\", $s)).nextval;\n\t}\n\tcatch ($ex) {\n            # check for common db errors and throw the appropriate exception\n            sepl_check_db_error($ex, $.dsn, \\$.reset());\n            # if the above function did not throw any exceptions, then rethrow the current exception\n            rethrow;\n        }\n    }\n\n    #! handles reset events during an exception\n    private reset() {\n        # release any locks and ignore the exception if in a transaction\n        if ($.ds.inTransaction())\n            try $.ds.rollback(); catch () {}\n        $.assignDS();\n    }\n\n    #! assigns the internal connection object\n    private assignDS() {\n\ttry {\n            if ($.fromds)\n%ifdef QorusHasHttpUserIndex\n                $.ds = new DatasourcePool($.ds.getConfigHash());\n%else\n                $.ds = $.ds.copy();\n%endif\n                #$.ds = $.ds.copy();\n            else {\n                #$.ds = $omqservice.system.datasource.getPool($.dsn);\n%ifdef QoreDebug\n                my DatasourcePool $ds = $omqservice.system.datasource.getPool($.dsn);\n                #if ($ds.getDriverName() == \"oracle\")\n                #    $.ds = new OracleExtensions::OracleDatasourcePool($ds, \\getAutoInfo());\n                #else\n                    $.ds = $ds;\n%else\n                #$.ds = new OracleExtensions::OracleDatasourcePool($omqservice.system.datasource.getPool($.dsn), \\getAutoInfo());\n                $.ds = $omqservice.system.datasource.getPool($.dsn);\n%endif\n            }\n        }\n\tcatch ($ex) {\n\t    # rethrow the exception such that it matches a preconfigured error string\n\t    if ($ex.err =~ /ORACLE/)\n\t\tthrow DATASOURCE_ERROR, sprintf(\"%s:%d: %s: %s\", $ex.file, $ex.line, $ex.err, $ex.desc);\n\t    # otherwise rethrow the exception as is\n\t    rethrow;\n\t}\n    }\n}\n\n#! wrapper for the SQLStatement class when communicating with EBS\n/** wraps each call with a try/catch block and calls sepl_check_db_error() as needed\n*/\nclass OracleSQLStatement inherits AbstractIterator {\n    private {\n        object $.ds;\n        SQLStatement $.stmt;\n        # are we using a DatasourcePool? (used in resetting)\n        bool $.pool = False;\n        # save name for resets\n        string $.name;\n    }\n\n    # creates the object based on a datasource pool acquired from the datasource service from the datasource name passed as an argument\n    /** @param $name the datasource name\n    */\n    constructor(string $name) {\n        $.pool = True;\n        $.name = $name;\n        $.assignDS();\n    }\n\n    # creates the object based on the OracleDatasource or OracleDatasourcePool passed as an argument\n    /** @param $ds the OracleDatasource or OracleDatasourcePool to use\n    */\n    constructor(any $ds) {\n        if (getClassName($ds) != \"OracleDatasource\") {\n            if (getClassName($ds) != \"OracleDatasourcePool\")\n                throw \"ORACLESQLSTATEMENT-CONSTRUCTOR-ERROR\", sprintf(\"expecting an OracleDatasourcePool or OracleDatasource object; got %y instead\", getClassName($ds));\n            # make sure and replace with a pool if initialized with a pool\n            $.pool = True;\n        }\n        $.name = $ds.name();\n        $.ds = $ds.datasource();\n        $.stmt = new SQLStatement($.ds);\n    }\n\n    #! wrapper for method calls to the SQLStatement class when communicating with EBS; wraps each call with a try/catch block and calls sepl_check_db_error() as needed\n    /** @return the return value of the Datasource method\n    */\n    any methodGate(string $m) {\n        try {\n            return callObjectMethodArgs($.stmt, $m, $argv);\n        }\n        catch ($ex) {\n            # check for common db errors and throw the appropriate exception\n            sepl_check_db_error($ex, $.name, \\$.reset());\n            # if the above function did not throw any exceptions, then rethrow the current exception\n            rethrow;\n        }\n    }\n\n    #! handles reset events during an exception\n    private reset() {\n        # release any locks and ignore the exception if in a transaction\n        if ($.ds.inTransaction())\n            try $.ds.rollback(); catch () {}\n        $.assignDS();\n    }\n\n    private assignDS() {\n        try {\n            if ($.pool) {\n                #$.ds = $omqservice.system.datasource.getPool($.name);\n%ifdef QoreDebug\n                my DatasourcePool $ds = $omqservice.system.datasource.getPool($.name);\n                #if ($ds.getDriverName() == \"oracle\")\n                #    $.ds = new OracleExtensions::OracleDatasourcePool($ds, \\getAutoInfo());\n                #else\n                    $.ds = $ds;\n%else\n                #$.ds = new OracleExtensions::OracleDatasourcePool($omqservice.system.datasource.getPool($.name), \\getAutoInfo());\n                $.ds = $omqservice.system.datasource.getPool($.name);\n%endif\n            }\n            else {\n                #$.ds = $omqservice.system.datasource.getDedicated($.name);\n%ifdef QoreDebug\n                my Datasource $ds = $omqservice.system.datasource.getDedicated($.name);\n                #if ($ds.getDriverName() == \"oracle\")\n                #    $.ds = new OracleExtensions::OracleDatasource($ds, \\getAutoInfo());\n                #else\n                    $.ds = $ds;\n%else\n                #$.ds = new OracleExtensions::OracleDatasource($omqservice.system.datasource.getDedicated($.name), \\getAutoInfo());\n                $.ds = $omqservice.system.datasource.getDedicated($.name);\n%endif\n            }\n            # try to execute a rollback to avoid possible exceptions when the SQLStatement object is redefined\n            try { $.stmt.rollback(); } catch () {}\n            $.stmt = new SQLStatement($.ds);\n        }\n        catch (hash $ex) {\n            # rethrow the exception such that it matches a preconfigured error string\n            if ($ex.err =~ /ORACLE/)\n                throw DATASOURCE_ERROR, sprintf(\"%s:%d: %s: %s\", $ex.file, $ex.line, $ex.err, $ex.desc);\n            # otherwise rethrow the exception as is\n            rethrow;\n        }\n    }\n\n    hash getValue() {\n        try {\n            return $.stmt.getValue();\n        }\n        catch (hash $ex) {\n            # rethrow the exception such that it matches a preconfigured error string\n            if ($ex.err =~ /ORACLE/)\n                throw DATASOURCE_ERROR, sprintf(\"%s:%d: %s: %s\", $ex.file, $ex.line, $ex.err, $ex.desc);\n            # otherwise rethrow the exception as is\n            rethrow;\n        }\n    }\n\n    bool next() {\n        try {\n            return $.stmt.next();\n        }\n        catch (hash $ex) {\n            # rethrow the exception such that it matches a preconfigured error string\n            if ($ex.err =~ /ORACLE/)\n                throw DATASOURCE_ERROR, sprintf(\"%s:%d: %s: %s\", $ex.file, $ex.line, $ex.err, $ex.desc);\n            # otherwise rethrow the exception as is\n            rethrow;\n        }\n    }\n\n    bool valid() {\n        return $.stmt.valid();\n    }\n} # class OracleSQLStatement\n\n#! returns the value of the given property, checking the domain hierarchy (current object, and, if not found, the \\c \"sepl\" domain)\n/** @param $key the name of the property to return\n    @return the value of the given property, checking the domain hierarchy (current object, and, if not found, the \\c \"sepl\" domain)\n*/\nany sub sepl_single_prop_get(string $key) {\n    return sepl_prop_get(sepl_get_current_name(), $key);\n}\n\n#! returns the value of the given property in the given domain, or, if not found, in the \\c \"sepl\" domain\n/** @param $domain the domain to check first before checking the \\c \"sepl\" domain\n    @param $key the name of the property to return\n    @return the value of the given property in the given domain, or, if not found, in the \\c \"sepl\" domain\n*/\nany sub sepl_prop_get(string $domain, string $key) {\n    # first, check in the given domain\n    my any $v = $omqservice.system.prop.get($domain, $key);\n    if (exists $v)\n\treturn $v;\n\n    # now return the value in the \"sepl\" domain\n    return $omqservice.system.prop.get(\"sepl\", $key);\n}\n\n#! returns the contents of the entire domain; if any values are not set, then the values in the \\c \"sepl\" domain are returned instead; uses the optional $required list to check if required properties are set\n/** @param $domain the domain to check first before checking the \\c \"sepl\" domain\n    @param $required an optional list of properties to check if they are set; if any properties in this list are not set then an exception is thrown\n    @param $defaults an optional hash of default values to use if no other values are set in system properties\n    @return the contents of the entire domain; if any values are not set, then the values in the \\c \"sepl\" domain are returned instead\n    @throw PROPERTY-ERROR missing property\n*/\n*hash sub sepl_prop_get(string $domain, *softlist $required, *hash $defaults) {\n    my *hash $h = $defaults + $omqservice.system.prop.get(\"sepl\") + $omqservice.system.prop.get($domain);\n    foreach my string $key in ($required) {\n\tif (!exists $h.$key)\n \t    throw ERROR::PROPERTY_ERROR, sprintf(\"missing system property in domain \\\"sepl\\\" or in domain %n with key %n; cannot start\", $domain, $key);\n    }\n    return $h;\n}\n\n#! returns the contents of the entire domain for the given object (domain name determined automatically); if any values are not set, then the values in the \\c \"sepl\" domain are returned instead; uses the optional $required list to check if required properties are set\n/** @param $required an optional list of properties to check if they are set; if any properties in this list are not set then an exception is thrown\n    @param $defaults an optional hash of default values to use if no other values are set in system properties\n    @return the contents of the entire domain; if any values are not set, then the values in the \\c \"sepl\" domain are returned instead\n    @throw PROPERTY-ERROR missing property\n*/\n*hash sub sepl_prop_get(*softlist $required, *hash $defaults) {\n    return sepl_prop_get(sepl_get_current_name(), $required, $defaults);\n}\n\n#! returns the value of the given property after a 3-tier search, first in the given domain, second, in the given alternate domain, or, if not found, in the \\c \"sepl\" domain\n/** @param $domain the domain to check first before checking the alternate domain and the \\c \"sepl\" domain\n    @param $altdomain an alternate domain to check for values before checking the \\c \"sepl\" domain\n    @param $key the name of the property to return\n    @return the value of the given property in the given domain, or, if not found, in the \\c \"sepl\" domain\n*/\nany sub sepl_alt_prop_get(string $domain, string $altdomain, string $key) {\n    # first, check in the given domain\n    my any $v = $omqservice.system.prop.get($domain, $key);\n    if (exists $v)\n\treturn $v;\n\n    if (exists ($v = $omqservice.system.prop.get($altdomain, $key)))\n\treturn $v;\n\n    # now return the value in the \"sepl\" domain\n    return $omqservice.system.prop.get(\"sepl\", $key);\n}\n\n#! returns the contents of the entire domain; if any values are not set, then the values in the alternate domain are given, followed by values in the \\c \"sepl\" domain\n/** @param $domain the domain to check first before checking the alternate domain and the \\c \"sepl\" domain\n    @param $altdomain an alternate domain to check for values before checking the \\c \"sepl\" domain\n    @return the contents of the entire domain; if any values are not set, then the values in the \\c \"sepl\" domain are returned instead\n*/\n*hash sub sepl_alt_prop_get(string $domain, string $altdomain) {\n    return $omqservice.system.prop.get(\"sepl\") + $omqservice.system.prop.get($altdomain) + $omqservice.system.prop.get($domain);\n}\n\n# Get system properties value for key. SP domain is the WF/SVC/JOB name.\nany sub sepl_getconf(string $key, any $default) {\n    my string $domain = sepl_get_current_name();\n    my any $ret = sepl_prop_get($domain, $key);\n    if (!exists $ret && !exists $default)\n        throw \"CONFIG-ERROR\", sprintf(\"A value for domain 'sepl' or '%s', key '%s' is not configured\", $domain, $key);\n    else if (!exists $ret && exists $default)\n        return $default;\n    return $ret;\n}\n# a legacy functions - to be removed in Rossini project\nany sub isepl_wf_getconf(string $key, any $default) { return sepl_getconf($key, $default); }\nany sub isepl_sv_getconf(string $key, any $default) { return sepl_getconf($key, $default); }\n\n#! used to get an OracleDatasourcePool\n/** @return an OracleDatasourcePool for the named datasource\n    @throw DATASOURCE-ERROR if any Oracle exceptions are thrown retrieving the datasource, it is rethrown with this error name\n    @note this call is equivalent to: @code new OracleDatasourcePool($name);@endcode\n*/\nOracleDatasourcePool sub sepl_get_dsp(string $dsn) {\n    return new OracleDatasourcePool($dsn);\n}\n\n#! used to get an OracleDatasource\n/** @return an OracleDatasource for the named datasource\n    @throw DATASOURCE-ERROR if any Oracle exceptions are thrown retrieving the datasource, it is rethrown with this error name\n    @note this call is equivalent to: @code new OracleDatasource($name);@endcode\n*/\nOracleDatasource sub sepl_get_ds(string $dsn) {\n    return new OracleDatasource($dsn);\n}\n\n#! check if a workflow order exists with the given order key and value\n/** @param $name the name of the workflow order\n    @param $ver the version of the workflow order\n    @param $key the name of the order key\n    @param $val the value of the order key\n\n    @return \\c True if the order exists, \\c False if it does not\n*/\nbool sub sepl_check_order_key(string $name, string $ver, string $key, softstring $val) {\n   my list $l;\n   try {\n       $l = $omqservice.system.info.getOrderInfoFromKey($name, $ver, $key, $val);\n   }\n   catch ($ex) {\n       if ($ex.err == \"UNKNOWN-KEY-VALUE\")\n\t   $l = ();\n       else\n\t   rethrow;\n   }\n\n   if (!elements $l)\n       return False;\n\n   if (elements $l != 1)\n       throw \"SEPL-CHECK-ERROR\", sprintf(\"unexpected answer received from service call: system.info.getOrderInfoFromKey(%y, %y, %y, %y): %y\", $name, $ver, $key, $val, $l);\n\n   return True;\n}\n\n#! converts a workflow name to the equivalent service name\n/** @param $wf the workflow name\n\n    @return a string giving the name of the corresponding service\n\n    @throw WORKFLOW-NAME-ERROR the workflow name has an invalid format\n*/\nstring sub workflow_to_service(string $wf) {\n    my *string $country = ($wf =~ x/^([A-Z]+)-/)[0];\n    if (!exists $country)\n        throw \"WORKFLOW-NAME-ERROR\", sprintf(\"workflow name %y does not have the format ..-\", $wf);\n\n    # get the associated service's name to get the \"staging\" datasource name\n    # from system properties using the service name as the domain\n    return \"ebs-\" + tolower($wf);\n}\n\n#! converts a service or job name to the equivalent workflow name\n/** @param $name the service or job name\n\n    @return a string giving the name of the corresponding workflow\n\n    @throw NAME-ERROR the service or job name has an invalid format\n*/\nstring sub name_to_workflow(string $name) {\n    my *string $country = ($name =~ x/^ebs-([a-z]+)-/)[0];\n    if (!exists $country)\n        throw \"NAME-ERROR\", sprintf(\"name %y does not have the format ebs-..-\", $name);\n\n    # convert country name to upper case\n    $country = toupper($country);\n\n    # get workflow name from service name\n    return toupper(($name =~ x/^ebs-(.*)/)[0]);\n}\n\n# \"private\" function - returns a single descriptive string for the exception\nstring sub get_err(hash $ex) {\n    return sprintf(\"%s:%d: %s: %s\", $ex.file, $ex.line, $ex.err, $ex.desc);\n}\n\n# \"private\" function - resets a datasource when certain errors occur\nsub reset_ds(string $dsname, *code $reset) {\n    # reset datasource\n    $omqservice.system.datasource.reset($dsname);\n    # reset datasource in current workflow if necessary\n    if (exists $reset)\n\t$reset();\n}\n\n#! run in the catch block for db actions to enforce common db-related error handling in workflows\n/** @param $ex the exception hash\n    @param $dsname the optional name of the datasource; if given, it can be reset depending on the error\n    @param $reset an optional closure for resetting the datasource in the current workflow\n\n    @throw DATASOURCE-ERROR thrown if the datasource cannot be contacted; step will be retried\n    @throw DB-CLUSTER-FAILOVER thrown if a cluster failover error has been detected; datasource is reset, and the step will be retried\n    @throw DB-PACKAGE-STATE-ERROR thrown if a package state error has been detected; datasource is reset, and the step will be retried\n*/\nsub sepl_check_db_error(hash $ex, *string $dsname, *code $reset) {\n    if ($ex.err =~ /^DBI:ORACLE:/ || ($ex.err == \"API-CALL-ERROR\" && $ex.desc =~ /DBI:ORACLE/)) {\n\t# if the connection was lost (either during the transaction - the first error, or while starting the transaction - the second error\n\t# then rethrow an exception that will cause the step to be retried\n\tif ($ex.desc =~ /ORA-12541/)\n\t    throw DATASOURCE_ERROR, get_err($ex);\n\n        # connection lost contact - will get a retry\n        if ($ex.desc =~ /ORA-03135/)\n            throw DATASOURCE_ERROR, get_err($ex);\n\n\t# handle cluster failover errors\n\tif ($ex.desc =~ /ORA-2540[1-9]/) {\n            if ($dsname)\n                reset_ds($dsname, $reset);\n\t    throw ERROR::DB_CLUSTER_FAILOVER, get_err($ex);\n\t}\n\n\t# handle invalid package state errors\n\tif ($ex.desc =~ /ORA-0406[158]/) {\n            if ($dsname)\n                reset_ds($dsname, $reset);\n\t    throw ERROR::DB_PACKAGE_STATE_ERROR, get_err($ex);\n\t}\n\n        # handle invalid package state errors\n\tif ($ex.desc =~ /ORA-06508/) {\n            if ($dsname)\n                reset_ds($dsname, $reset);\n\t    throw ERROR::DB_PACKAGE_STATE_ERROR, get_err($ex);\n\t}\n    }\n}\n\n#! returns the name of the current object (workflow, service, or job)\n/** @return the name of the current object (workflow, service, or job)\n*/\nstring sub sepl_get_current_name() {\n%ifdef QorusWorkflow\n    return getWorkflowMetadata().name;\n%endif\n%ifdef QorusService\n    return getServiceInfo().name;\n%endif\n%ifdef QorusJob\n    return job_info().name;\n%endif\n}\n\n#! returns the org_name associated with the current object (ex: \\c \"UK-OPCO\")\n/** @return the org_name associated with the current object (ex: \\c \"UK-OPCO\")\n\n    @throw NAME-ERROR this exception is thrown if the calling object's name does not fit *SEPL naming conventions and therefore the associated org name cannot be derived\n*/\nstring sub sepl_get_org_name() {\n%ifdef QorusWorkflow\n    my string $name = getWorkflowMetadata().name;\n    # remove MAP- and GSLS- from names\n    $name =~ s/^(MAP-|GSLS-)//;\n    my *string $org = ($name =~ x/^([A-Z][A-Z]-[A-Z]+)-[-A-Z0-9_]+/)[0];\n    if (!$org.val()) {\n        $org = ($name =~ x/^([A-Z][A-Z])-/)[0];\n        if ($org.val())\n            return $org + \"_OPCO\";\n    }\n%endif\n%ifdef QorusService\n    my string $name = getServiceInfo().name;\n    my *string $org = ($name =~ x/ebs-([a-z][a-z]-[^-]+)-[-a-z0-9_]+/)[0];\n    if ($org.val())\n        $org = $org.upr();\n    else {\n        $org = ($name =~ x/^([a-z][a-z])-/)[0];\n        if ($org.val())\n            return $org.upr() + \"_OPCO\";\n    }\n%endif\n%ifdef QorusJob\n    my string $name = job_info().name;\n    my *string $org = ($name =~ x/ebs-([a-z][a-z]-[^-]+)-[-a-z0-9_]+/)[0];\n    if ($org.val())\n        $org = $org.upr();\n    else {\n        $org = ($name =~ x/^([a-z][a-z])-/)[0];\n        if ($org)\n            return $org.upr() + \"_OPCO\";\n    }\n%endif\n\n    if (!exists $org)\n        throw \"NAME-ERROR\", sprintf(\"could not derive org name from object name %y\", $name);\n\n    # convert hyphen to underscore\n    $org =~ s/-/_/;\n    return $org;\n}\n\n#! returns the country name for the calling object (in upper case)\n/** @return the country name for the calling object (in upper case)\n\n    @throw NAME-ERROR this exception is thrown if the calling object's name does not fit *SEPL naming conventions and therefore the associated org name cannot be derived\n*/\nstring sub sepl_get_cc() {\n    return (sepl_get_org_name() =~ x/([A-Z]+)_[A-Z]+/)[0];\n}\n\n#! returns the country name for the calling object (in lower case)\n/** @return the country name for the calling object (in lower case)\n\n    @throw NAME-ERROR this exception is thrown if the calling object's name does not fit *SEPL naming conventions and therefore the associated org name cannot be derived\n*/\nstring sub sepl_get_cc_lwr() {\n    return tolower((sepl_get_org_name() =~ x/([A-Z]+)_[A-Z]+/)[0]);\n}\n\n#! returns the org_id associated with the current object - the org_name is taken from the current object's name\n/** @param $ds the datasource or datasourcepool object to use\n\n    @return the org_id associated with the current object\n\n    @throw INVALID-ORG the h3g_legal_entity_info function did not return any org_id for the given org name\n*/\nsoftint sub sepl_get_org_id(object $ds) {\n    return sepl_get_org_id($ds, sepl_get_org_name());\n}\n\n#! returns the org_id associated with the current object\n/** @param $ds the datasource or datasourcepool object to use\n    @param $org the org name to use for the lookup (in the format \\c \"UK_OPCO\" etc)\n\n    @return the org_id associated with the current object\n\n    @throw INVALID-ORG the h3g_legal_entity_info.f_get_org_id function did not return any org_id for the given org name\n*/\nsoftint sub sepl_get_org_id(object $ds, string $org) {\n    try {\n        return $omqservice.user.\"ass-org-lookup\".get_org_id($org);\n    }\n    catch (hash $ex) {\n        log(LL_INFO, \"%s: %s: %s\", get_ex_pos($ex), $ex.err, $ex.desc);\n    }\n\n%ifdef QoreDebug\n    switch ($org) { case \"UK_OPCO\": return 1001; case \"IE_OPCO\": return 1002; case \"AT_OPCO\": return 1003; case \"IT_OPCO\": return 1004; }\n    throw \"INVALID-ORG\", sprintf(\"cannot determine org_id from %y\", $org);\n%else\n    my hash $h = $ds.select(\"begin :res := h3g_legal_entity_info.f_get_org_id(%v); end;\", Type::String, $org);\n    if ($h.res === NULL)\n\tthrow \"INVALID-ORG\", sprintf(\"h3g_legal_entity_info.f_get_org_id returned NULL with argument %y\", $org);\n\n    return $h.res;\n%endif\n}\n\n#! returns the set_of_books_id associated with the current object - the org_name is taken from the current object's name\n/** @param $ds the datasource or datasourcepool object to use\n\n    @return the set_of_books_id associated with the current object\n\n    @throw INVALID-ORG the h3g_legal_entity_info function did not return any set_of_books_id for the given org name\n*/\nsoftint sub sepl_get_set_of_books_id(object $ds) {\n    return sepl_get_set_of_books_id($ds, sepl_get_org_name());\n}\n\n#! returns the set_of_books_id associated with the current object\n/** @param $ds the datasource or datasourcepool object to use\n    @param $org the org name to use for the lookup (in the format \\c \"UK_OPCO\" etc)\n\n    @return the set_of_books_id associated with the current object\n\n    @throw INVALID-ORG the h3g_legal_entity_info.f_get_org_id function did not return any org_id for the given org name\n*/\nsoftint sub sepl_get_set_of_books_id(object $ds, string $org) {\n    my hash $h = $ds.select(\"begin :res := h3g_legal_entity_info.f_get_set_of_bks_id(%v); end;\", Type::String, $org);\n    if ($h.res === NULL)\n        throw \"INVALID-ORG\", sprintf(\"h3g_legal_entity_info.f_get_set_of_bks_id returned NULL with argument %y\", $org);\n\n    return $h.res;\n}\n\n#! reads a file and returns the contents of the file\n/** @param $path the file's path\n    @param $enc the optional encoding of the file; if this variable is not given, then the file will be returned in UTF-8 encoding\n\n    @return the contents of the file\n\n    @throw SEPL-FILE-OPEN-ERROR there was an error opening the file; this error gets a RETRY in workflow in order to work around an unknown filesystem synchronization problem\n*/\nstring sub sepl_read_file(string $path, string $enc = \"utf8\") {\n    my File $f($enc);\n    try {\n        $f.open2($path);\n    }\n    catch (hash $ex) {\n        if ($ex.err == \"FILE-OPEN2-ERROR\")\n            throw FILE_OPEN_ERROR, $ex.desc;\n        rethrow;\n    }\n    return $f.read(-1);\n}\n\n#! reads a file and returns the contents of the file as a binary object\n/** @param $path the file's path\n\n    @return the contents of the file as a binary object\n\n    @throw SEPL-FILE-OPEN-ERROR there was an error opening the file; this error gets a RETRY in workflow in order to work around an unknown filesystem synchronization problem\n*/\nbinary sub sepl_read_file_bin(string $path) {\n    my File $f();\n    try {\n        $f.open2($path);\n    }\n    catch (hash $ex) {\n        if ($ex.err == \"FILE-OPEN2-ERROR\")\n            throw FILE_OPEN_ERROR, $ex.desc;\n        rethrow;\n    }\n    return $f.readBinary(-1);\n}\n\n#! returns a QorusSystemAPIHelper with http properties applied by using the system.remote service\n/** @param $remote the name of the remote service\n    @param $props optional props to apply to the QorusSystemAPIHelper object before returning it\n\n    @return a QorusSystemAPIHelper with http properties applied by using the system.remote service\n*/\nQorusSystemAPIHelper sub sepl_remote_get(string $remote, *hash $props) {\n    my QorusSystemAPIHelper $rv = $omqservice.system.remote.get($remote);\n\n    if (exists $props.timeout)\n\t$rv.setTimeout($props.timeout);\n    if (exists $props.connect_timeout)\n\t$rv.setConnectTimeout($props.connect_timeout);\n    if (exists $props.proxy)\n\t$rv.setProxyURL($props.proxy);\n\n    return $rv;\n}\n\n#! substitutes $cc in a path template string with the current country name\nstring sub process_path(string $path) {\n    return regex_subst($path, \"\\\\$cc\", sepl_get_cc_lwr());\n}\n\n#! substitutes $CC in a workflow template string with the current country name\nstring sub process_workflow(string $wf) {\n    return $wf !~ /\\$CC/ ? $wf : regex_subst($wf, \"\\\\$CC\", sepl_get_cc());\n}\n\n#! substitutes $cc or $CC in a workflow template string with the current country name (lower and upper case, respectively)\nstring sub process_cc_string(string $str) {\n    $str = replace($str, \"$CC\", sepl_get_cc());\n    return replace($str, \"$cc\", sepl_get_cc_lwr());\n}\n\n#! substitutes $cc or $CC in a workflow template string with the current country name (lower and upper case, respectively)\nstring sub process_cc_string_intern(string $str, string $cc, string $CC) {\n    $str = replace($str, \"$CC\", $CC);\n    return replace($str, \"$cc\", $cc);\n}\n\n#! sets full paths to working dirs from system properties or from FileDefaults if no suitable property is set\n/** @param $props a hash of system properties\n\n    @returns a hash of full paths to file working directories\n\n    @throw MISSING-BASE-PATH this exception is thrown if \\c \"base_path\" is not set in the passed property hash\n*/\nhash sub process_paths(hash $props) {\n    return process_paths_intern($props, sepl_get_cc_lwr(), sepl_get_cc());\n}\n\nconst PathProps = (\"rj_wf_path\", \"rj_base_dir_in\", \"bhub_base_path_in\", \"bhub_base_path_out\", \"utl_wf_path\", \"sono_wf_path\");\n\nconst SubDirs = (\"import\", \"arch\", \"work\", \"output\", \"error\", \"tmp\", \"discard\");\n\nhash sub do_subdir_props(hash $props, string $base, string $pfx, string $cc, string $CC) {\n    if (!$pfx.empty())\n\t$pfx += \"_\";\n\n    foreach my string $d in (SubDirs) {\n\tmy *string $dir = $props.($pfx + $d);\n\t$props.($pfx + $d + \"_path\") = process_cc_string_intern(sprintf(\"%s/%s/\", $base, exists $dir ? $dir : FileDefaults.$d), $cc, $CC);\n    }\n\n    return $props;\n}\n\nhash sub process_paths_intern(hash $props, string $cc, string $CC) {\n    if ($props.base_path) {\n\t$props.base_path = process_cc_string_intern($props.base_path, $cc, $CC);\n\t$props = do_subdir_props($props, $props.base_path, \"\", $cc, $CC);\n    }\n\n    if ($props.utl_base_path) {\n\t$props.utl_base_path = process_cc_string_intern($props.utl_base_path, $cc, $CC);\n\t$props = do_subdir_props($props, $props.utl_base_path, \"utl\", $cc, $CC);\n\n        if (!$props.utl_wf_path)\n            $props.utl_wf_path = $props.utl_base_path + \"/\" + \"wf\";\n    }\n\n    if ($props.vcc_base_path) {\n\t$props.vcc_base_path = process_cc_string_intern($props.vcc_base_path, $cc, $CC);\n\t$props = do_subdir_props($props, $props.vcc_base_path, \"vcc\", $cc, $CC);\n    }\n\n    if ($props.sono_base_path) {\n\t$props.sono_base_path = process_cc_string_intern($props.sono_base_path, $cc, $CC);\n\t$props = do_subdir_props($props, $props.sono_base_path, \"sono\", $cc, $CC);\n\n        if (!$props.sono_wf_path)\n            $props.sono_wf_path = $props.sono_base_path + \"/\" + \"wf\";\n    }\n\n    if ($props.gemalto_base_path) {\n\t$props.gemalto_base_path = process_cc_string_intern($props.gemalto_base_path, $cc, $CC);\n\t$props = do_subdir_props($props, $props.gemalto_base_path, \"gemalto\", $cc, $CC);\n    }\n\n    if ($props.orange_gl_base_path) {\n\t$props.orange_gl_base_path = process_cc_string_intern($props.orange_gl_base_path, $cc, $CC);\n\t$props = do_subdir_props($props, $props.orange_gl_base_path, \"orange_gl\", $cc, $CC);\n    }\n\n    if ($props.b4n_base_path) {\n\t$props.b4n_base_path = process_cc_string_intern($props.b4n_base_path, $cc, $CC);\n\t$props = do_subdir_props($props, $props.b4n_base_path, \"b4n\", $cc, $CC);\n    }\n\n    foreach my string $p in (PathProps) {\n\tif ($props.$p)\n\t    $props.$p = process_cc_string_intern($props.$p, $cc, $CC);\n    }\n\n    return $props;\n}\n\n#! returns a new filename, prepending the msepl and source system to the filename\n/** @param $msepl the name of the msepl instance that processed (or is procesing) the file\n    @param $source_system the name of the source system (ie \\c \"UTL\", \\c \"RJ\", etc)\n    @param $filename the filename of the file\n\n    @return a new filename, with the msepl and source system prepended to the filename\n*/\nstring sub sepl_make_filename(string $msepl, string $source_system, string $filename) {\n    return sprintf(\"%s-%s-%s\", $msepl, $source_system, $filename);\n}\n\n#! processes inbound data when received by iSEPL and saves to the import directory\n/** @param $props a hash of properties; at least the key set in the $dir_tag argument must have a value\n    @param $data the order data; normally the staticdata of a workflow order, with the following keys:\n    - \\c isepl_received: if this key is set, then the $isepl_received argument is ignored\n    - \\c ctime: the value of this key is returned as the \\c \"msepl_received\" key in the return value\n    - \\c filename: this should be given as the incoming filename; if not, an artificial filename is created\n    - \\c msepl: this must be set to the MSEPL instance sending the file (ex: \\c \"MSEPL-UK\")\n    - \\c msepl_instance: the instance name of the MSEPL instance that sent the file\n    - \\c msepl_wfiid: if this key does not already exist, and this function is called directly from a workflow, then it is set to the current wfiid\n    @param $dir_tag the tag used to for finding the complete path in the $props argument for saving the file\n    @param $isepl_received the date used for setting the $isepl_received value in the return hash; set only if an \\c \"isepl_received\" key is not set in the $data hash\n    @param $add_uuid if this value is true and the $data.filename value does not have a uuid value appended to it already, then one will be generated and appeded to the file name\n\n    @return a hash of processed order information, corresponding to the $data hash with the following differences:\n    - \\c isepl_received: if this key is not set in the incoming $data, this this value will be set to the $isepl_received parameter value\n    - \\c filename: the new complete filename of the file as saved by this function\n    - \\c orig_filname: the original filename (without any path component), also with any uuid suffix stripped from the name\n    - \\c uuid: any UUID that was appended to the original filename, or a new UUID created if the $add_uuid arugment is \\c True\n    - \\c msepl_wfiid: if this was not set in the incoming $data; it will be set in the return hash (otherwise it is left as-is)\n    - \\c orderkeys: a hash of potential order keys:\n      - \\c filename: the original filename, corresponding to \\c \"orig_filename\" above\n      - \\c isepl-filename: the current isepl filename, with the path component removed\n      - \\c uuid: the filename uuid either retrieved from the original filename or created if $add_uuid is \\c True\n\n    @throw FILE-OPEN2-ERROR there was an error creating the output file\n*/\nhash sub process_in_data(hash $props, hash $data, string $dir_tag = \"import_path\", date $isepl_received = now_us(), bool $add_uuid = True, string $data_tag = \"xml\") {\n    # set isepl file received timestamp\n    if (!exists $data.isepl_received)\n\t$data.isepl_received = $isepl_received;\n\n    # set the \"msepl_received\" tag\n    if (!exists $data.msepl_received)\n\t$data.msepl_received = exists $data.ctime ? remove $data.ctime : now_us();\n\n    # FIXME: remove when UK release updated\n    if (!exists $data.filename)\n        $data.filename = sprintf(\"unknown-%s-%s\", $data.source_system, UUID::get());\n    if (!exists $data.msepl)\n        $data.msepl = \"MSEPL-\" + sepl_get_cc();\n    if (!exists $data.msepl_instance)\n        $data.msepl_instance = getSystemInfo().\"instance-key\";\n\n    # check input data\n    foreach my string $k in (InboundDataTags + $data_tag) {\n        if (!exists $data.$k)\n            throw \"INBOUND-DATA-ERROR\", sprintf(\"data missing %y tag (data keys=%y)\", $k, keys $data);\n    }\n\n    # GB150825 make sure data is empty or only whitespace\n    if ($data.$data_tag =~ /^\\s*$/)\n        throw \"INBOUND-DATA-ERROR\", sprintf(\"input data tag %y is empty; without input data further processing is impossible\", $data_tag);\n    log(LL_INFO, \"%y: %y\", $data_tag, $data.$data_tag);\n\n%ifdef QorusWorkflow\n    # set this wfiid as msepl_wfiid if not already set\n    if (!exists $data.msepl_wfiid)\n        $data.msepl_wfiid = getWorkflowInstanceData(\"workflow_instanceid\");\n%endif\n\n    # separate uuid from original filename\n    my (*string $ofn, *string $uuid) = ($data.filename =~ x/(.*)-([0-9a-f]+-[0-9a-f]+-[0-9a-f]+-[0-9a-f]+-[0-9a-f]+)$/i);\n    $ofn = !exists $ofn ? basename($data.filename) : basename($ofn);\n\n    $data.orig_filename = $ofn;\n\n    if (!exists $uuid && $add_uuid) {\n\t$uuid = UUID::get();\n\t$data.filename += \"-\" + $uuid;\n    }\n\n    # make isepl filename\n    my string $fname = sprintf(\"%s%s\", $props.$dir_tag, sepl_make_filename($data.msepl, $data.source_system, $data.filename));\n\n    log(LL_DEBUG_1, \"submit: writing: '%s'\", $fname);\n\n    my File $f();\n    $f.open2($fname, O_CREAT | O_TRUNC | O_WRONLY, 0644);\n    $f.write($data.$data_tag);\n    $f.close();\n\n    # reuse data for staticdata\n    $data -= $data_tag;\n    $data.filename = $fname;\n\n    # save order keys for new order\n    if (!exists $data.orderkeys.filename)\n        $data.orderkeys.filename = $ofn;\n    if (!exists $data.orderkeys.\"isepl-filename\") {\n\tmy string $bn = basename($fname);\n\tif (strlen($bn) <= ORDER_INSTANCE_KEYS_VALUE_LEN)\n\t    $data.orderkeys.\"isepl-filename\" = $bn;\n    }\n    if (!exists $data.orderkeys.uuid)\n        $data.orderkeys.uuid = $uuid;\n    if (!exists $data.uuid)\n        $data.uuid = $uuid;\n\n    return $data;\n}\n\n#! moves a file by copying and deleting the original file so that files can be moved between filesystems\n/**\n    @throw FILE-OPEN2-ERROR there was an error creating the output file\n    @throw SEPL-FILE-OPEN-ERROR there was an error opening the input file; this error gets a RETRY in workflow in order to work around an unknown filesystem synchronization problem\n*/\nsub sepl_move_file(string $source, string $target) {\n    # open output file\n    my File $fo();\n    $fo.open2($target, O_CREAT | O_TRUNC | O_WRONLY);\n\n    my File $fi();\n    try {\n        $fi.open2($source);\n    }\n    catch (hash $ex) {\n        if ($ex.err == \"FILE-OPEN2-ERROR\")\n            throw FILE_OPEN_ERROR, $ex.desc;\n        rethrow;\n    }\n\n    my *binary $data = $fi.readBinary(-1);\n    if (exists $data && $fo.write($data) == -1)\n        throw \"ARCHIVE-ERROR\", sprintf(\"could not create target file %s: %s\", $target, strerror(errno()));\n\n    unlink($source);\n}\n\n#! returns a date on the same daty in Vienna at midnight\ndate sub sepl_get_midnight(string $date) {\n    my date $d = date($date);\n    return date(sprintf(\"%04d-%02d-%02d\", $d.years(), $d.months(), $d.days()));\n}\n\n%ifdef QorusWorkflow\n#! save a UUID in the \\c \"orderkeys\" key of dynamic data for use with GSLS wf order creation and validation, because the MSEPL wfiid is not unique\nstring sub sepl_save_gsls_uuid() {\n    my *hash $ok = getDynamicData(\"orderkeys\");\n    $ok.msepl_wf_uuid = UUID::get();\n    updateDynamicData((\"orderkeys\": $ok));\n    return $ok.msepl_wf_uuid;\n}\n\n#! checks if the order should go to error the first time\nsub sepl_scmhub_check() {\n    my *hash $dd = getDynamicData();\n\n    # if flagged to go to error\n    if ($dd.scmGoToError) {\n        # remove error flag so this happens only the first time\n        updateDynamicData((\"scmGoToError\": False));\n        # raise error\n        throw SCM_SPLIT_ERROR, \"This order was created by the parent workflow to document that batch order splitting was necessary; some data could be processed successfully; some not; see parent order for error details\";\n    }\n}\n\n#! processes the return value of an scmhub \"process\" call and returns a list of errored IDs\nsoftlist sub sepl_scmhub_check_ret(list $data, hash $ret, bool $raiseAllError = True, *string $req) {\n    return keys sepl_scmhub_check_ret_hash($data, $ret, $raiseAllError, $req);\n}\n\n#! processes the return value of an scmhub \"process\" call and returns a hash of errored IDs (value -> True) for quick lookups\n/** @param $data the data submitted to the scmhub\n    @param $ret the return value from the scmhub\n    @param $raiseAllError if set to False no ERROR::SCMHUB_ERROR\n            \"all records were rejected by the scmhub, so the order will\n             not be split and this order will instead go to ERROR\"\n             will be raised and all needs to be handled upstream\n */\n*hash sub sepl_scmhub_check_ret_hash(list $data, hash $ret, bool $raiseAllError = True, *string $req, bool $do_warnings = True) {\n    $ret.x_status = $ret.x_status[0];\n    # initially check for whole batch error code\n    if ($ret.x_status.STATUS_CODE != 0 && !$ret.x_param_out) {\n        log(LL_IMPORTANT, \"scmhub call returned an error status code with an empty output collection: request: %s status: %y\", $req, $ret.x_status);\n\n        # top level timeout (legacy implementation)\n        if ($ret.x_status.ERROR_DESCRIPTION == \"Time out was occured\")\n            throw ERROR::SCMHUB_TIMEOUT, \"Time out was occured\";\n\n        my int $size = $data.size();\n        # make sure the list isn't more than 5 elements long\n        splice $data, 5;\n        throw ERROR::SCMHUB_ERROR, sprintf(\"scmhub call returned an error: request: %s code: %y description: %s args: %y (%s)\", $req, $ret.x_status.ERROR_CODE, $ret.x_status.ERROR_DESCRIPTION, $data, $size > 5 ? sprintf(\"the request data was truncated; original size: %d\", $size) : \"complete argument list\");\n    }\n\n    # if there is not data in x_param_out we have to throw an error\n    if (!elements $ret.x_param_out){\n        throw ERROR::SCMHUB_ERROR, sprintf(\"no data in x_param_out, even though STATUS_CODE==0: request: %s\", $req);\n    }\n\n    # line level timeout - check if more than 50% of the lines have timed out, then throw a retry\n    {\n        my int $tc = 0;\n        map ++$tc, $ret.x_param_out, ($1.STATUS == \"E\" && ($1.ERROR_CODE == \"TIMEOUT\" || $1.ERROR_MSG == \"Time-Out\" || $1.ERROR_MSG == \"User-Defined Exception\"));\n        if ($tc && $tc > ($data.size() / 2))\n            throw ERROR::SCMHUB_TIMEOUT, sprintf(\"line level timeouts: %d (input lines: %d); more than 50% of the lines in the response timed out so the workflow order will get a retry\", $tc, $data.size());\n    }\n\n    # get list of errored transaction IDs\n    my hash $eh;\n\n    # get error count\n    my int $ec = 0;\n    foreach my hash $eph in (select $ret.x_param_out, $1.STATUS != \"C\") {\n        # find input data for logging\n        my any $ih = (select $data, $1.QORUS_ROW_ID == $eph.QORUS_ROW_ID);\n        if ($ih.lsize() == 1)\n            $ih = $ih[0];\n\n        # make sure that scmhub error results are logged in the log file and also visible in the GUI\n        if ($do_warnings)\n            swarning(SCMHUB_RESULT, sprintf(\"scmhub returned an error: request: %s, arg: %y, result: %y\", $req, $ih, $eph));\n        # make sure the QORUS_ROW_ID value is set\n        if (exists $eph.QORUS_ROW_ID)\n            $eh.($eph.QORUS_ROW_ID) = True;\n        else\n            log(LL_INFO, \"scmhub did not return a QORUS_ROW_ID value in the error hash (logged above)\");\n        ++$ec;\n    }\n\n    if (!elements $ret.invalid && !$ret.x_status.STATUS_CODE && !$ec)\n        return;\n\n    if (elements $ret.invalid) {\n        log(LL_IMPORTANT, \"scmhub call validation rejected %d row%s: %N\", elements $ret.invalid, elements $ret.invalid == 1 ? \"\" : \"s\", $ret.invalid);\n        # add transaction_id values to the $errors list\n        map $eh.($1.QORUS_ROW_ID) = True, $ret.invalid;\n    }\n\n    if ($raiseAllError && elements $eh == elements $data) {\n        log(LL_IMPORTANT, \"All records were rejected: %n\", $ret.x_status);\n        log(LL_INFO, \"    returning: %n\", $ret.x_param_out);\n        my int $size = $data.size();\n        # make sure the list isn't more than 5 elements long\n        splice $data, 5;\n        throw ERROR::SCMHUB_ERROR, sprintf(\"all records were rejected by the scmhub, so the order will not be split and this order will instead go to ERROR: scmhub: req: %s status: %y (return data: %y, args: %y (%s))\", $req, $ret.x_status, $ret.x_param_out, $data, $size > 5 ? sprintf(\"the request data was truncated; original size: %d\", $size) : \"complete argument list\");\n    }\n\n    return $eh;\n}\n\n#! processes the return value of an scmhub \"process\" call; throws an SCMHUB_ERROR if there are any errors in the call\n/** @param $data the data submitted to the scmhub\n    @param $ret the return value from the scmhub\n */\nsub sepl_scmhub_verify_ret_hash(list $data, hash $ret, *string $req) {\n    # initially check for whole batch error code\n    if ($ret.x_status[0].STATUS_CODE != 0 && !$ret.x_param_out) {\n        log(LL_IMPORTANT, \"scmhub call returned an error status code with an empty output collection: request: %s status: %y\", $req, $ret.x_status);\n        my int $size = $data.size();\n        # make sure the list isn't more than 5 elements long\n        splice $data, 5;\n        throw ($ret.x_status.ERROR_DESCRIPTION == \"Time out was occured\" ? ERROR::SCMHUB_TIMEOUT : ERROR::SCMHUB_ERROR), sprintf(\"scmhub call returned an error: request: %s status: %y args: %y (%s)\", $req, $ret.x_status, $data, $size > 5 ? sprintf(\"the request data was truncated; original size: %d\", $size) : \"complete argument list\");\n    }\n\n    # line level timeout - check if more than 50% of the lines have timed out, then throw a retry\n    {\n        my int $tc = 0;\n        map ++$tc, $ret.x_param_out, ($1.STATUS == \"E\" && ($1.ERROR_CODE == \"TIMEOUT\" || $1.ERROR_MSG == \"Time-Out\" || $1.ERROR_MSG == \"User-Defined Exception\"));\n        if ($tc && $tc > ($data.size() / 2))\n            throw ERROR::SCMHUB_TIMEOUT, sprintf(\"line level timeouts: %d (input lines: %d); more than 50% of the lines in the response timed out so the workflow order will get a retry\", $tc, $data.size());\n    }\n\n    # get error count\n    my int $ec = 0;\n    map ++$ec, $ret.x_param_out, $1.STATUS != \"C\";\n\n    # log errors\n    if ($ec)\n        throw ERROR::SCMHUB_ERROR, sprintf(\"scmhub errors (request: %y): %N\", $req, (map $1, $ret.x_param_out, $1.STATUS != \"C\"));\n\n    if (elements $ret.invalid)\n        throw ERROR::SCMHUB_ERROR, sprintf(\"scmhub call validation (request: %y) rejected %d row%s: %N\", $req, elements $ret.invalid, elements $ret.invalid == 1 ? \"\" : \"s\", $ret.invalid);\n}\n\n#! returns the party code from the org name\nstring sub get_party_from_org(string $org_name) {\n    switch ($org_name) {\n\tcase \"UK_OPCO\":\n\t    return \"UTL\";\n\n\tcase \"IE_OPCO\":\n\t    return \"ADS\";\n    }\n\n    throw \"ORG-NAME-ERROR\", sprintf(\"cannot map ORG_NAME value %y to an scmhub party code\", $org_name);\n}\n%endif\n\nhash sub mon_database(string $name, string $dsname) {\n    my hash $ret = (\n            \"code\" : 0,\n            \"name\" : $name,\n        );\n    try {\n        my OracleDatasource $ds($dsname);\n        $ds.select(\"select sysdate from dual\");\n        $ret.desc = \"OK\";\n    }\n    catch ($ex) {\n        $ret.code = 1;\n        $ret.desc = sprintf(\"%s: %s\", $ex.err, $ex.desc);\n    }\n\n    return $ret;\n}\n\nstring sub sepl_make_path() {\n    return $argv ? normalize_dir($argv.join('/')) : \"\";\n}\n\nsub check_path(string $path, string $type, bool $write = False) {\n    my *hash $h = hstat($path);\n    if (!exists $h)\n        throw \"DIR-ERROR\", sprintf(\"%y: %s path does not exist\", $path, $type);\n    if ($h.type != \"DIRECTORY\")\n        throw \"DIR-ERROR\", sprintf(\"%y: %s path is not a directory (%s)\", $path, $type, $h.type);\n\n    # check if the directory is readable\n    if (!is_readable($path))\n        throw \"DIR-ERROR\", sprintf(\"%y: %s path is not readable\", $path, $type);\n\n    # check if the directory is writable\n    if ($write && !is_writable($path)) {\n        throw \"DIR-ERROR\", sprintf(\"%y: %s path is not writable\", $path, $type);\n    }\n}\n\n# moved to standalone lib in Rossini\ndeprecated sub sepl_create_master_order(string $wfname, softbool $condition, *hash $order_hash) {\n    # check READY or IN PROGRESS in the beginning\n    my *hash $wfinfo = $omqservice.system.omqmap.rlookupworkflow($wfname);\n    my softint $wfid = $wfinfo{$wfinfo.lastversion}.workflowid;\n    my list $wfiids = $omqservice.system.info.getWorkflowInstances($wfid, ('READY', 'IN-PROGRESS', 'SCHEDULED'), now()-2D, 1);\n    if ($wfiids.size()) {\n        log(LL_INFO, \"Do not start workflow becasue there is at least one WFI in READY or IN-PROGRESS\");\n        return;\n    }\n\n    if ($condition) {\n        log(LL_INFO, \"Creating %s order instance\", $wfname);\n        # cannot use create_order here because it fails in amris with PO_REQUIRE_TYPES/STRICT ARGS\n        $order_hash.staticdata.\"created-by\" = \"sepl_create_master_order\";\n        createOrder($wfname, NOTHING, $order_hash);\n    }\n    else {\n        log(LL_INFO, \"WFI creation skipped because code condition is not met\");\n    }\n}\n","created": "2015-01-20 12:56:21.999155 +01:00","modified": "2015-01-20 12:56:21.999155 +01:00","createdby": "omq","modifiedby": "omq","tags": {},"source": "/Users/pchalupny/workspace/erp-sepl/src/libraries/sepl-lib-v1.0.qfd","offset": "7","host": "panda-2.local","user": "pchalupny"},{"name": "sepl-inbound-lib","version": "2.0","id": 87,"function_type": "GENERIC","description": "Common SEPL library functions for inbound Qorus code (requires the Mapper class object)","author": "David Nichols (Qore Technologies, sro)","body": "%require-types\n\n%requires SqlUtil\n\n#! table descriptions for mapping classes - varchar2 column widths and numeric fields\nconst TableDescriptions = (\n    \"gsi_brep_trans\": (\n        \"transaction_id\": (\"sequence\": \"gsi_transaction_id_s\"),\n        \"message_id\": (\"sequence\": \"gsi_message_id_s\"),\n    ),\n    \n    \"gsi_snr\": (\n        \"transaction_id\": (\"sequence\": \"gsi_transaction_id_s\"),\n        \"message_id\": (\"sequence\": \"gsi_message_id_s\"),\n    ),\n\n    \"gsi_brep_trans2\": (\n        \"transaction_id\": (\"sequence\": \"gsi_transaction_id_s\"),\n        \"message_id\": (\"sequence\": \"gsi_message_id_s\"),\n    ),\n    \n    \"gsi_snr2\": (\n        \"transaction_id\": (\"sequence\": \"gsi_transaction_id_s\"),\n        \"message_id\": (\"sequence\": \"gsi_message_id_s\"),\n    ),\n\n    \"gsi_retail_header_data\": (\n        \"id\": (\"sequence\": \"gsi_retail_header_data_s\"),\n    ),\n\n    \"gsi_retail_detail_data\": (\n        \"id\": (\"sequence\": \"gsi_retail_detail_data_s\"),\n    ),\n\n    \"gsi_retail_payment_data\": (\n        \"id\": (\"sequence\": \"gsi_retail_payment_data_s\"),\n    ),\n\n    \"gsi_stock_reconciliation\": (\n        \"id\": (\"sequence\": \"gsi_stock_reconciliation_s\"),\n    ),\n\n    \"gsi_requisitions_interface\": (\n        \"id\": (\"sequence\": \"gsi_requisitions_interface_s\"),\n    ),\n\n    \"gsi_oe_headers_iface\": (\n        \"id\": (\"sequence\": \"gsi_oe_headers_iface_s\"),\n    ),\n\n    \"gsi_oe_lines_iface\": (\n        \"id\": (\"sequence\": \"gsi_oe_lines_iface_s\"),\n    ),\n\n    \"gsi_oe_snr_iface\": (\n        \"id\": (\"sequence\": \"gsi_oe_snr_iface_s\"),\n    ),\n    \n    \"gsi_parties\": (\n        # NOTE: temporarily use gsi_message_id_s for the id field since we don't know which other one to use\n        \"id\": (\"sequence\": \"gsi_message_id_s\"),\n        # NOTE: temporarily use gsi_message_id_s for the id field since we don't know which other one to use\n        \"party_id\": (\"sequence\": \"gsi_message_id_s\"),\n    ),\n\n    \"gsi_commissioning\": (\n        \"id\": (\"sequence\": \"gsi_commissioning_s\"),\n    ),\n\n    \"gsi_order_header\": (\n        \"transaction_id\": (\"sequence\": \"gsi_transaction_id_s\"),\n        \"message_id\": (\"sequence\": \"gsi_message_id_s\"),\n    ),\n\n    \"gsi_order_address\": (\n        \"transaction_id\": (\"sequence\": \"gsi_transaction_id_s\"),\n    ),\n\n    \"gsi_order_line\": (\n        \"transaction_id\": (\"sequence\": \"gsi_transaction_id_s\"),\n        \"message_id\": (\"sequence\": \"gsi_message_id_s\"),\n    ),\n\n    \"gsi_customers\": (\n        \"id\": (\"sequence\": \"gsi_customers_s\"),\n    ),\n\n    \"h3g_gl_orange_sap_data\": (\n        \"id\": (\"sequence\": \"h3g_gl_orange_sap_data_s\"),\n    ),\n    \n    \"h3g_omif.h3g_gl_orange_rmca_data\": (\n        \"id\": (\"sequence\": \"h3g_omif.h3g_gl_orange_sap_data_s\"),\n    ),\n\n    \"h3g_ran_items\": (\n        \"trx_id\": (\"sequence\": \"h3g_ran_items_seq\"),\n    ),\n\n    \"h3g_ran_purchase_orders\": (\n        \"trx_id\": (\"sequence\": \"h3g_ran_purchase_orders_seq\"),\n    ),\n\n    \"h3g_omif.h3g_ran_receiving_trx_spl\": (\n        \"trx_id\": (\"sequence\": \"h3g_omif.h3g_ran_receiving_trx_spl_seq\"),\n    ),\n\n    \"h3g_omif.h3g_ran_material_trx_spl\": (\n        \"trx_id\": (\"sequence\": \"h3g_omif.h3g_ran_material_trx_spl_seq\"),\n    ),\n\n    \"gsi_fraud_secu_data\": (\n        \"id\": (\"sequence\": \"gsi_fraud_s\"),\n    ),\n    \n    \"h3g_omif.h3g_icrs_ap_trans_import\": (\n        \"id\": (\"sequence\": \"h3g_omif.h3g_icrs_ap_icrs_trans_id_s\"),\n    ),\n    \n    \"h3g_omif.h3g_icrs_ar_trans_import\": (\n        \"id\": (\"sequence\": \"h3g_omif.h3g_icrs_ar_icrs_trans_id_s\"),  \n    ),\n    \n    \"h3g_omif.h3g_icrs_gl_trans_import\": (\n        \"id\": (\"sequence\": \"h3g_omif.h3g_icrs_gl_icrs_trans_id_s\"),\n    ),\n\n    );\n\nconst RefUpdateKeys = (\n    \"gsi_brep_trans\": \"transaction_id\",\n    \"gsi_snr\": \"transaction_id\",\n\n    \"gsi_customers\": \"bind_id\",\n    \"gsi_oe_headers_iface\": \"bind_id\",\n    \"gsi_oe_lines_iface\": \"bind_id\",\n    \"gsi_oe_snr_iface\": \"bind_id\",\n\n    \"gsi_retail_header_data\": \"id\",\n    \"gsi_retail_detail_data\": \"retail_header_id\",\n    \"gsi_retail_payment_data\": \"retail_header_id\",\n\n    \"gsi_requisitions_interface\": \"id\",\n    \"gsi_stock_reconciliation\": \"id\",\n    );\n\n#! returns the current date\nconst CurrentDateFilter = date sub (any $v, hash $rec) { return now_us(); };\n\nconst EbsDefaultMap = (\n    \"org_id\": (\"name\": \"_org_id\"),\n    \"org_name\": (\"name\": \"_org_name\"),\n    \"status\": (\"name\": \"_status\"),\n    \"created_date\": (\"code\": CurrentDateFilter),\n    );\n\n#! default mappings for admin fields in global staging - msepl\nconst EbsMseplDefaultMap = EbsDefaultMap + (\n    \"m_sepl_begin_date\": (\"name\": \"_msepl_received\"),\n    \"m_sepl_created_by_user\": (\"name\": \"_current_name\"),\n    \"m_sepl_created_date\": (\"code\": CurrentDateFilter),\n    \"m_sepl_environment\": (\"name\": \"_msepl\"),\n    \"m_sepl_instance\": (\"name\": \"_qorus_instance\"),\n    \"m_sepl_updated_date\": (\"code\": CurrentDateFilter),\n    \"m_sepl_updated_by_user\": (\"name\": \"_current_name\"),\n    );\n\n#! default mappings for admin fields in global staging - isepl\nconst EbsIseplDefaultMap = EbsDefaultMap + (\n    \"m_sepl_instance\": (\"name\": \"_msepl_instance\"),\n    \"i_sepl_begin_date\": (\"name\": \"_isepl_received\"),\n    \"i_sepl_created_by_user\": (\"name\": \"_current_name\"),\n    \"i_sepl_created_date\": (\"code\": CurrentDateFilter),\n    \"i_sepl_environment\": (\"name\": \"_isepl\"),\n    \"i_sepl_instance\": (\"name\": \"_qorus_instance\"),\n    \"i_sepl_updated_date\": (\"code\": CurrentDateFilter),\n    \"i_sepl_updated_by_user\": (\"name\": \"_current_name\"),\n    );\n\n#! ensures \"update_keys\" entries are present for each table in \"tablelist\"\nhash sub sepl_check_update_keys(hash $props) {\n    foreach my string $t in ($props.tablelist) {\n        if (!exists $props.update_keys.$t)\n            $props.update_keys.$t = sepl_get_key($t, $props);\n    }\n\n    return $props;\n}\n\n%ifdef QorusWorkflow\nconst WfiidField = (\"code\": softint sub (any $x, hash $rec) { return getWorkflowInstanceData(\"workflow_instanceid\"); });\nconst MseplWorkflowMap = (\n    \"m_sepl_created_id\": WfiidField,\n    );\nconst IseplWorkflowMap = (\n    \"i_sepl_created_id\": WfiidField,\n    );\n%endif\n\n#! this class provides an easy way to map row data to a single table\nclass EbsSingleTableInboundMapper inherits public SingleTableInboundMapper {\n    private {\n\t#! static map data to be added to every record mapped\n\t*hash $.staticMapData;\n\n\t#! time zone to set before every insert\n\tTimeZone $.vienna(\"Europe/Vienna\");\n    }\n\n    public {\n\t# bit field values\n\tconst MSEPL = (1 << 0);\n\tconst ISEPL = (1 << 1);\n\tconst MISEPL = (MSEPL | ISEPL);\n    }\n\n    #! builds the object based on a hash providing field mappings, data constraints, and optionally logic; this variant takes a Datasource/DatasourcePool or other wrapper class as an argument directly\n    /** The map hash will be processed with table properties added from the TableDescriptions hash; throws an exception if the table is not recognized or if a field name in the map is not recognized or if a NOT NULL field is not mapped\n\n\t@param $ds the Datasource/DatasourcePool or other wrapper class to do the inserts\n        @param $table_name the name of the table to insert into\n        @param $map a hash providing field mappings; each hash key is the name of the target record (Oracle column); each value is either \\c True (meaning no translations are done; the data is copied 1:1) or a hash with the following fields providing information about how the input records should be translated (all fields are optional):\n\t- \\c name: the value of this key gives the name of the input field; only use this if the input record name is different than the column name\n        - \\c code: a closure or call reference to process the field\n        - \\c maxlen: an integer giving the maximum field length in bytes; note that if any fields contain this key, the $enc argument must be supplied as well\n        - \\c trunc: assign to boolean True if the field should be truncated if over the maximum field length; this key can only be set to \\c True if the \\c \"maxlen\" key is also given\n        - \\c mand: assign to boolean True if the field is mandatory and an exception should be thrown if no input data is supplied\n        - \\c type: this gives the field type, can be \\c \"number\": field accepts only numeric values (any non-numeric values on input will cause an exception to be thrown when mapping) or \\c \"date\": date field\n        - \\c sequence: this field is populated from a sequence, the name of which is given as the value of this key\n        @param $extra_fields an optional list of additional field names for each insert\n        @param $crec an optional constant hash of column names and values to add to each insert\n\t@param $sepl_type MSEPL if this is an mSEPL-only workflow, ISEPL if this is an iSEPL-only workflow, and MISEPL if this workflow is both MSEPL and ISEPL (affects default mappings applied to admin columns - note that default mappings will only be added if a mapping doesn't already exist in the map passed as an argument)\n\n        @throw MAP-ERROR the map hash has a logical error (ex: 'trunc' key given without 'maxlen', invalid map key)\n\t@throw UNKNOWN-TABLE table name not recognized (not present in the TableDescriptions hash)\n\t@throw UNKNOWN-COLUMN field name not recognized (not present in the TableDescriptions hash)\n\t@throw MISSING-COLUMN map is missing a mapping for a column with a NOT NULL constraint\n    */\n    constructor(OracleDatasource $ds, string $table_name, hash $map, *softlist $extra_fields, *hash $crec, int $sepl_type = MISEPL) : SingleTableInboundMapper($ds, $table_name, EbsSingleTableInboundMapper::fixMap($ds, $map, $table_name, $extra_fields, $crec, MISEPL), $extra_fields, $crec) {\n        $.doInit($table_name);\n    }\n\n    #! builds the object based on a hash providing field mappings, data constraints, and optionally logic; this variant takes a Datasource/DatasourcePool or other wrapper class as an argument directly\n    /** The map hash will be processed with table properties added from the TableDescriptions hash; throws an exception if the table is not recognized or if a field name in the map is not recognized or if a NOT NULL field is not mapped\n\n\t@param $dsp the DatasourcePool or other wrapper class to do the inserts\n        @param $table_name the name of the table to insert into\n        @param $map a hash providing field mappings; each hash key is the name of the target record (Oracle column); each value is either \\c True (meaning no translations are done; the data is copied 1:1) or a hash with the following fields providing information about how the input records should be translated (all fields are optional):\n\t- \\c name: the value of this key gives the name of the input field; only use this if the input record name is different than the column name\n        - \\c code: a closure or call reference to process the field\n        - \\c maxlen: an integer giving the maximum field length in bytes; note that if any fields contain this key, the $enc argument must be supplied as well\n        - \\c trunc: assign to boolean True if the field should be truncated if over the maximum field length; this key can only be set to \\c True if the \\c \"maxlen\" key is also given\n        - \\c mand: assign to boolean True if the field is mandatory and an exception should be thrown if no input data is supplied\n        - \\c type: this gives the field type, can be \\c \"number\": field accepts only numeric values (any non-numeric values on input will cause an exception to be thrown when mapping) or \\c \"date\": date field\n        - \\c sequence: this field is populated from a sequence, the name of which is given as the value of this key\n        @param $extra_fields an optional list of additional field names for each insert\n        @param $crec an optional constant hash of column names and values to add to each insert\n\t@param $sepl_type MSEPL if this is an mSEPL-only workflow, ISEPL if this is an iSEPL-only workflow, and MISEPL if this workflow is both MSEPL and ISEPL (affects default mappings applied to admin columns - note that default mappings will only be added if a mapping doesn't already exist in the map passed as an argument)\n\n        @throw MAP-ERROR the map hash has a logical error (ex: 'trunc' key given without 'maxlen', invalid map key)\n\t@throw UNKNOWN-TABLE table name not recognized (not present in the TableDescriptions hash)\n\t@throw UNKNOWN-COLUMN field name not recognized (not present in the TableDescriptions hash)\n\t@throw MISSING-COLUMN map is missing a mapping for a column with a NOT NULL constraint\n    */\n    constructor(OracleDatasourcePool $dsp, string $table_name, hash $map, *softlist $extra_fields, *hash $crec, int $sepl_type = MISEPL) : SingleTableInboundMapper($dsp, $table_name, EbsSingleTableInboundMapper::fixMap($dsp, $map, $table_name, $extra_fields, $crec, $sepl_type), $extra_fields, $crec) {\n        $.doInit($table_name);\n    }\n\n    private doInit(string $table_name) {\n\t$.staticMapData += (\n\t    \"_current_name\": sepl_get_current_name(),\n\t    \"_qorus_instance\": getSystemInfo().\"instance-key\",\n\t    \"_status\": \"I\",\n\t    \"_isepl\": \"ISEPL-AT\",\n\t    );\n\n        if ($.map.org_id) {\n            my string $org_name = sepl_get_org_name();\n            $.staticMapData += (\n                \"_org_name\": $org_name,\n                \"_org_id\": sepl_get_org_id(new OracleDatasource(sepl_single_prop_get(\"local_staging\")), $org_name),\n                );\n        }\n    }\n\n    #! inserts a row into the target table based on a mapped input record; does not commit the transaction\n    /** @param $rec the input record\n        @param $extra_values an optional list of extra values to add to the field list; if any extra fields were defined in the constructor, then the extra values must be given here\n        @param $ll an option log level argument, if this argument is present, then the SQL and arguments will be logged with the given log level\n\n        @return a hash of the row values inserted (row name: value), not including the extra values\n\n        @throw MISSING-INPUT a field marked mandatory is missing\n        @throw STRING-TOO-LONG a field value exceeds the maximum value and the 'trunc' key is not set\n        @throw INVALID-NUMBER the field is marked as numeric but the input value contains non-numeric data        \n    */\n    hash insertRowNoCommit(hash $rec, softlist $extra_values, *int $ll) {\n\t# set and restore thread-local time zone region after every insert\n        my *TimeZone $tz = get_thread_tz();\n        set_thread_tz($.vienna);\n        on_exit set_thread_tz($tz);\n\treturn SingleTableInboundMapper::$.insertRowNoCommit($rec, $extra_values, $ll);\n    }\n\n    #! returns a map hash with table properties added from the TableDescriptions hash; throws an exception if the table is not recognized or if a field name in the map is not recognized\n    /** make sure the table name and all column names are in lower-case\n\t@param $map the map hash\n\t@param $table_name the name of the table\n\t@param $extra_fields an optional list of extra fields that will be added to each insert\n        @param $crec an option hash of constant values for each row\n        @param $sepl_type either MSEPL or ISEPL which determines the admin columns set for each row\n\n\t@return the map hash with table attributes added (numeric fields and varchar2 field widths)\n\n\t@throw UNKNOWN-TABLE table name not recognized (not present in the TableDescriptions hash)\n\t@throw UNKNOWN-COLUMN field name not recognized (not present in the TableDescriptions hash)\n\t@throw MISSING-COLUMN map is missing a mapping for a column with a NOT NULL constraint\n    */\n    static hash fixMap(AbstractDatasource $ds, hash $map, string $table_name, *softlist $extra_fields, *hash $crec, int $sepl_type) {\n        my Table $t($ds, $table_name);\n        my Columns $c = $t.describe();\n\n\tmy *hash $h = TableDescriptions.$table_name;\n\n        if (!exists $h)\n            throw \"UNKNOWN-TABLE\", sprintf(\"EbsSingleTableInboundMapper::constructor() cannot apply any configuration for unknown table %y\", $table_name);\n\n        # add column definitions from real table description\n        foreach my AbstractColumn $col in ($c.iterator()) {\n            my string $cn = $col.name.lwr();\n            my reference $ch = \\$h.$cn;\n            #my bool $log = !$ch;\n            switch ($col.qore_type) {\n                case \"string\": $ch += (\"maxlen\": $col.size, \"trunc\": True); break;\n                case \"number\": $ch.type = \"number\"; break;\n                case \"date\": $ch.type = \"date\"; break;\n                default: throw \"TABLE-ERROR\", sprintf(\"column %s.%s has unknown native type %y\", $table_name, $cn, $col.native_type);\n            }\n            if (!$col.nullable && !exists $col.def_val)\n                $ch.mand = True;\n\n            #if ($log) log(LL_DEBUG_2, \"adding desc for column %s.%s: %y\", $table_name, $cn, $ch);\n        }\n\n\t# add default mappings depending on the sepl type - only if the mapping doesn't already exist\n\tif ($sepl_type & MSEPL) {\n\t    foreach my string $k in (keys EbsMseplDefaultMap) {\n\t\tif (!exists $map.$k && !exists $crec.$k && exists $h.$k)\n\t\t    $map.$k = EbsMseplDefaultMap.$k;\n\t    }\n\t}\n\tif ($sepl_type & ISEPL) {\n\t    foreach my string $k in (EbsIseplDefaultMap.keyIterator()) {\n                #log(LL_DEBUG_2, \"k: %y map: %y crec: %y h: %y\", $k, $map.$k, $crec.$k, $h.$k);\n\t\tif (!exists $map.$k && !exists $crec.$k && exists $h.$k)\n\t\t    $map.$k = EbsIseplDefaultMap.$k;\n\t    }\n\t}\n\n%ifdef QorusWorkflow\n\tif ($sepl_type & MSEPL)\n            $h += MseplWorkflowMap;\n\tif ($sepl_type & ISEPL)\n            $h += IseplWorkflowMap;\n%endif\n\n\tforeach my string $k in (($map + $crec).keyIterator()) {\n\t    if (!exists $h.$k)\n\t\tthrow \"UNKNOWN-COLUMN\", sprintf(\"EbsSingleTableInboundMapper::constructor() cannot apply any configuration for unknown column %s.%s\", $table_name, $k);\n\n            # convert to a hash if the value of the column is a string (giving the source key name)\n            my int $t = $map.$k.typeCode();\n            switch ($t) {\n                case NT_STRING: $map.$k = ($map.$k =~ /\\./ ? (\"struct\": $map.$k.split(\".\")) : (\"name\": $map.$k)); break;\n                case NT_CALLREF:\n                case NT_CLOSURE: $map.$k = (\"code\": $map.$k); break;\n                default: if ($t != NT_HASH) $map.$k = hash(); break;\n            }\n\n\t    # apply column descriptions to map; do not apply sequence and closures to mappings given by the caller\n\t    $map.$k += $h.$k - (\"sequence\", \"code\");\n\t}\n\n\t# make sure that all mandatory fields have mappings\n\tforeach my string $k in ($h.keyIterator()) {\n\t    # apply sequences and closures automatically and check for missing mappings for mandatory (ie not null) columns\n\t    if (!exists $map.$k && !exists $crec.$k) {\n\t\t# apply default mappings with sequences or closure values\n\t\tif (exists $h.$k.sequence || exists $h.$k.code)\n\t\t    $map.$k = $h.$k;\n\t\telse if ($h.$k.mand && !inlist($k, $extra_fields))\n\t\t    throw \"MISSING-COLUMN\", sprintf(\"the map passed to EbsSingleTableInboundMapper::constructor() is missing a mapping for mandatory (ie NOT NULL) column %s.%s\", $table_name, $k);\n\t    }\n\t}\n        \n        #log(LL_DEBUG_2, \"map: %N\", $map);\n\treturn $map;\n    }\n\n   #! processes the input record and returns a hash of the mapped values where the keys in the hash returned are the target field names; the order of the fields in the hash returned is the same order as the keys in the map hash.\n    /** @param $rec the record to translate\n\n        @return a hash of field values in the target format based on the input data and processed according to the logic in the map hash\n\n        @throw MISSING-INPUT a field marked mandatory is missing\n        @throw STRING-TOO-LONG a field value exceeds the maximum value and the 'trunc' key is not set\n        @throw INVALID-NUMBER the field is marked as numeric but the input value contains non-numeric data\n    */\n    private hash mapData(hash $rec) {\n%ifdef QorusWorkflow\n\tmy hash $sd = getStaticData();\n        my hash $wfhd = (\n\t    \"_msepl_received\": $sd.\"msepl_received\",\n\t    \"_isepl_received\": $sd.\"isepl_received\",\n\n\t    \"_msepl_instance\": $sd.\"msepl_instance\",\n\t    \"_msepl\": $sd.msepl,\n\t    );\n\n        #log(LL_DETAIL_2, \"rec=%N\", ($rec + $.staticMapData + $wfhd));\n\treturn SingleTableInboundMapper::$.mapData($rec + $.staticMapData + $wfhd);\n%else\n\treturn SingleTableInboundMapper::$.mapData($rec + $.staticMapData);\n%endif\n    }\n\n   #! processes the input record and returns a hash of the mapped values where the keys in the hash returned are the target field names; the order of the fields in the hash returned is the same order as the keys in the map hash; also uses the constant record as given in the constructor and ensures dates are in the target time zone\n    /** @param $rec the record to translate\n\n        @return a hash of field values in the target format based on the input data and processed according to the logic in the map hash\n\n        @throw MISSING-INPUT a field marked mandatory is missing\n        @throw STRING-TOO-LONG a field value exceeds the maximum value and the 'trunc' key is not set\n        @throw INVALID-NUMBER the field is marked as numeric but the input value contains non-numeric data\n    */\n    hash mapDataHash(hash $rec) {\n\t# set and restore thread-local time zone region after every insert\n        my *TimeZone $tz = get_thread_tz();\n        set_thread_tz($.vienna);\n        on_exit set_thread_tz($tz);\n\n        return $.mapData($rec + $.crec);\n    }\n}\n\n#! fakes an scmhub \"write\" call response - should only be used when developing/debugging\nhash sub sepl_fake_scmhub_call(string $svc, *list $data) {\n    log(LL_DEBUG_2, \"%s data: %N\", $svc, $data);\n    my list $el = ();\n\n    my bool $do_errs = !parse_boolean(getInstanceData(\"no-scmhub-errors\"));\n\n    # generate random errors\n    if ($do_errs) {\n        foreach my hash $row in ($data) {\n            # 20% chance of an error\n            if (rand() % 5)\n                continue;\n            $el += (\n                \"QORUS_ROW_ID\": $row.QORUS_ROW_ID,\n                \"STATUS\": \"E\",\n                \"ERROR_MSG\": NULL,\n                );\n        }\n    }\n\n    my hash $ret = (\n\t\"x_status\": list((\"STATUS_CODE\": 0, \"ERROR_CODE\": NULL, \"ERROR_DESCRIPTION\": NULL)),\n\t\"x_param_out\": $el,\n\t);\n    log(LL_INFO, \"FAKE_SCMHUB: faked scmhub %s response with errors/rows: %d / %d\", $svc, elements $el, elements $data);\n    log(LL_DEBUG_2, \"%s response: %N\", $svc, $ret);\n    return $ret;\n}\n\n#! calls an scmhub service and returns the result; does not commit the transaction\nhash sub sepl_exec_scmhub_nocommit(object $ds, string $svc, list $data) {\n    log(LL_DEBUG_2, \"%s data: %N\", $svc, $data);\n    my date $start = now_us();\n    my hash $ret = $omqservice.user.$svc.process($ds, $data);\n    my date $end = now_us();\n    log(LL_DETAIL_1, \"%s: got %d record%s in %y\", $svc, elements $data, elements $data == 1 ? \"\" : \"s\", $end - $start);\n    log(LL_DEBUG_2, \"%s response: %N\", $svc, $ret);\n    \n    return $ret;\n}\n\n#! calls an scmhub service and returns the result; commits the transaction\nhash sub sepl_exec_scmhub(object $ds, string $svc, list $data) {\n    on_success $ds.commit();\n    on_error $ds.rollback();\n\n    return sepl_exec_scmhub_nocommit($ds, $svc, $data);\n}\n\n#! returns the name of the key to use for the table\nstring sub sepl_get_key(string $table, *hash $props) {\n    my *hash $update_keys = $props.update_keys;\n    if ($update_keys.$table)\n        return $update_keys.$table;\n\n    my *string $k = RefUpdateKeys.$table;\n    if (!$k)\n        throw \"TABLE-ERROR\", sprintf(\"no update key definition for table %y\", $table);\n\n    return $k;\n}\n\n#! returns a hash of common isepl column data\nhash sub sepl_get_data_isepl() {\n    # get wf name\n    my string $wf = sepl_get_current_name();\n    # get wfiid\n    my softint $wfiid = getWorkflowInstanceData(\"workflow_instanceid\");\n\n    return (\n\t\"I_SEPL_CREATED_ID\" : $wfiid,\n\t\"I_SEPL_UPDATED_ID\" : $wfiid,\n\t\"I_SEPL_NAME\" : $wf,\n\t\"I_SEPL_STATUS\" : 'C',\n\t\"I_SEPL_BEGIN_DATE\" : now_us(),\n\t\"I_SEPL_INSTANCE\" : getSystemInfo().\"instance-key\",\n\t\"I_SEPL_ENVIRONMENT\" : 'ISEPL-AT',\n\t\"I_SEPL_CREATED_BY_USER\" : $wf,\n\t\"I_SEPL_UPDATED_DATE\" : now_us(),\n\t\"I_SEPL_UPDATE_BY_USER\" : $wf,\n\t);\n}\n\n#! takes a hash of store IDs to transaction IDs and returns a hash of store ID & party code info and processes errors (marks errored transaction IDs in an error hash) \nhash sub sepl_scmhub_ret_party_code_from_epos_id(object $ds, hash $loc, reference $errh) {\n    log(LL_DETAIL_1, \"sepl_scmhub_ret_party_code_from_epos_id() about to look up %d party codes from store IDs\", elements $loc);\n\n    my list $data = ();\n    foreach my softstring $sid in (keys $loc) {\n\t$data += (\"EPOS_ID\": $sid,\n\t\t  \"QORUS_ROW_ID\": $sid,\n\t    );\n    }\n\n    my hash $ret;\n\n%ifdef QoreDebug\n    # fake response list\n    my list $fl = ();\n    # error count\n    my int $ec = 0;\n    my bool $do_errs = !parse_boolean(getInstanceData(\"no-scmhub-errors\"));\n    foreach my softstring $sid in (keys $loc) {\n\t# 10% chance of error on every record\n\tif ($do_errs && !(rand() % 10)) {\n\t    ++$ec;\n\t  $fl += (\n\t      \"PARTY_CODE\": NULL, \n\t      \"QORUS_ROW_ID\": $sid,\n\t      \"STATUS\": \"E\",\n\t      \"ERROR_MSG\": NULL,\n\t      );\n\t}\n\telse {\n\t  $fl += (\n\t      \"PARTY_CODE\": $sid, \n\t      \"QORUS_ROW_ID\": $sid,\n\t      \"STATUS\": \"C\",\n\t      \"ERROR_MSG\": NULL,\n\t      );\n\t}\n    }\n\n    $ret = (\n\t\"x_status\": list((\"STATUS_CODE\": 0, \"ERROR_CODE\": NULL, \"ERROR_DESCRIPTION\": NULL)),\n\t\"x_param_out\": $fl,\n\t);\n    log(LL_INFO, \"FAKE_SCMHUB: generated %d correct, %d errors, %d total in fake scm-ret_party_code response\", elements $fl - $ec, $ec, elements $fl);\n    log(LL_DEBUG_2, \"data: %N\", $data);\n    log(LL_DEBUG_2, \"ret: %N\", $ret);\n%else\n    $ret = sepl_exec_scmhub($ds, \"scm-ret_party_code\", $data);\n%endif\n\n    my list $errs = sepl_scmhub_check_ret($data, $ret, True, \"scm-ret_party_code\");\n\n    # process errors already logged\n    foreach my string $sid in ($errs) {\n\t# set transaction hash keys to True in error hash\n\tforeach my softstring $tid in ($loc.$sid)\n\t    $errh.$tid = True;\n    }\n\n    # create return hash and check for lookup failures\n    my hash $rv = hash();\n    foreach my hash $h in ($ret.x_param_out) {\n\tmy softstring $sid = $h.QORUS_ROW_ID;\n\tif ($h.STATUS != \"C\" || !strlen($h.PARTY_CODE)) {\n            swarning(SCMHUB_ERROR_INFO, sprintf(\"SCM-HUB party lookup failed for storeid %y; affects %d key%s (result: %y)\", $sid, elements $loc.$sid, elements $loc.$sid == 1 ? \"\" : \"s\", $h));\n\t    log(LL_DETAIL_1, \"missing lookup for storeid %y affects the following key IDs: %y\", $sid, $loc.$sid);\t\t\n\t    \n\t    # set transaction hash keys to True in error hash\n\t    foreach my softstring $tid in ($loc.$sid)\n\t\t$errh.$tid = True;\n\t}\n\telse\n\t    $rv.$sid = $h.PARTY_CODE;\n    }\n\n    return $rv;\n}\n\n#! apply updates from scmhub lookup info\n/** \n    @param $uk a hash of table names to key names\n    @param $valmap a map of source values to target values\n    @param $stmap a map of source values to impacted rows; the values are lists of key values (for the columns in the $uk hash) for the impacted rows\n    @param $domap a closure returning the update value for the following 2 arguments:\n    - string: table name\n    - any: the value of $valmap for that particular source value\n\n    @return an update hash\n*/\nsub sepl_apply_updates(hash $uk, hash $valmap, hash $stmap, code $domap, reference $uh) {\n    # iterate through each table\n    foreach my string $t in (keys $uk) {\n        # get key name for table\n        my string $k = $uk.$t;\n        \n        # iterate through each lookup entry\n        foreach my string $sk in (keys $valmap) {\n            # add updates to each impacted row\n\n            if (!exists $stmap.$sk)\n                throw \"APPLY-UPDATE-ERROR\", sprintf(\"cannot find source value %y in stmap: %y (valmap: %y)\", $sk, $stmap, $valmap);\n\n            foreach my softstring $id in ($stmap.$sk) {\n                # apply updates using the domap closure\n                my *hash $mr = $domap($t, $valmap.$sk);\n                if (exists $mr)\n                    $uh.$t.$k.$id += $mr;\n            }\n        }\n    }\n\n    log(LL_DEBUG_2, \"sepl_apply_updates() uh: %N\", $uh);\n}\n\n#! takes a hash of storeIDs -> transactionIDs, a hash of storeID & party code info and returns a hash of store IDs -> org IDs and subventory info - also processes the error hash\nhash sub sepl_scmhub_ret_org_info_from_party_code(object $ds, hash $loc, hash $ph, reference $errh) {\n    log(LL_DETAIL_1, \"sepl_scmhub_ret_org_info_from_party_code() about to look up %d party codes\", elements $ph);\n\n    my list $data = ();\n    foreach my softstring $sid in (keys $ph) {\n\t$data += (\"PARTY_CODE\": $ph.$sid,\n\t\t  \"QORUS_ROW_ID\": $sid,\n\t    );\n    }\n\n\n    my hash $ret;\n\n%ifdef QoreDebug\n    # fake response list\n    my list $fl = ();\n    # error count\n    my int $ec = 0;\n    my bool $do_errs = !parse_boolean(getInstanceData(\"no-scmhub-errors\"));\n    foreach my softstring $sid in (keys $ph) {\n\t# 10% chance of error on every record\n\tif ($do_errs && !(rand() % 10)) {\n\t    ++$ec;\n            $fl += (\n                \"ORGANIZATION_CODE\": NULL, \n                \"SUBINVENTORY\": NULL,\n                \"QORUS_ROW_ID\": $sid,\n                \"STATUS\": \"E\",\n                \"ERROR_MSG\": NULL,\n                );\n\t}\n\telse {\n            $fl += (\n                \"ORGANIZATION_CODE\": $ph.$sid,\n                \"SUBINVENTORY\": $ph.$sid,\n                \"QORUS_ROW_ID\": $sid,\n                \"STATUS\": \"C\",\n                \"ERROR_MSG\": NULL,\n                );\n\t}\n    }\n\n    $ret = (\n\t\"x_status\": list((\"STATUS_CODE\": 0, \"ERROR_CODE\": NULL, \"ERROR_DESCRIPTION\": NULL)),\n\t\"x_param_out\": $fl,\n\t);\n    log(LL_INFO, \"FAKE_SCMHUB: generated %d correct, %d errors, %d total in fake scmhub scm-ret_org_info response\", elements $fl - $ec, $ec, elements $fl);\n    log(LL_DEBUG_2, \"data: %N\", $data);\n    log(LL_DEBUG_2, \"ret: %N\", $ret);\n%else\n    $ret = sepl_exec_scmhub($ds, \"scm-ret_org_info\", $data);\n%endif\n    my list $errs = sepl_scmhub_check_ret($data, $ret, True, \"scm-ret_org_info\");\n\n    # process errors already logged\n    foreach my string $sid in ($errs) {\n\t# set transaction hash keys to True in error hash\n\tforeach my softstring $tid in ($loc.$sid)\n\t    $errh.$tid = True;\n    }\n\n    # create return hash and check for lookup failures\n    my hash $rv = hash();\n    foreach my hash $h in ($ret.x_param_out) {\n\tmy softstring $sid = $h.QORUS_ROW_ID;\n\tif ($h.STATUS != \"C\" || !strlen($h.SUBINVENTORY)) {\n\t    swarning(SCMHUB_ERROR_INFO, sprintf(\"SCM-HUB organization lookup failed for storeid %y; affects %d key%s (result: %y)\", $sid, elements $loc.$sid, elements $loc.$sid == 1 ? \"\" : \"s\", $h));\n\t    log(LL_DETAIL_1, \"missing lookup for storeid %y affects the following key IDs: %y\", $sid, $loc.$sid);\t\t\n\t    \n\t    # set transaction hash keys to True in error hash\n\t    foreach my softstring $tid in ($loc.$sid)\n\t\t$errh.$tid = True;\n\t}\n\telse\n\t    $rv.$sid = $h.(\"ORGANIZATION_CODE\", \"SUBINVENTORY\");\n    }\n\n    return $rv;\n}\n\n#! takes a list of product IDs (EANs) and returns a hash mapping from EAN -> item number\nhash sub sepl_scmhub_ret_item_number_from_ean(object $ds, string $org_name, hash $dg, reference $errh) {\n    my list $data = ();\n    # lookup hash\n    my hash $lh;\n    {\n        my int $c = 0;\n        foreach my string $ean in (keys $dg) {\n            $lh.$c = $ean;\n            $data += (\n                \"LEGAL_ENTITY\": $org_name, \n                \"EAN\": $ean,\n                \"QORUS_ROW_ID\": $c,\n                );\n            ++$c;\n        }\n    }\n\n    my hash $ret;\n\n%ifdef QoreDebug\n    # fake response list\n    my list $fl = ();\n    # error count\n    my int $ec = 0;\n    {\n        my int $c = 0;\n        my bool $do_errs = !parse_boolean(getInstanceData(\"no-scmhub-errors\"));\n        foreach my string $ean in (keys $dg) {\n            # 10% chance of error on every record\n            if ($do_errs && !(rand() % 10)) {\n            #if (!$#) {\n                ++$ec;\n                $fl += (\n                    \"ITEM_NUMBER\": NULL, \n                    \"QORUS_ROW_ID\": $c++,\n                    \"STATUS\": \"E\",\n                    \"ERROR_MSG\": NULL,\n                    );\n            }\n            else {\n                $fl += (\n                    \"ITEM_NUMBER\": $ean + \"1\", \n                    \"QORUS_ROW_ID\": $c++,\n                    \"STATUS\": \"C\",\n                    \"ERROR_MSG\": NULL,\n                    );\n            }\n        }\n    }\n\n    $ret = (\n\t\"x_status\": list((\"STATUS_CODE\": 0, \"ERROR_CODE\": NULL, \"ERROR_DESCRIPTION\": NULL)),\n\t\"x_param_out\": $fl,\n\t);\n    log(LL_INFO, \"FAKE_SCMHUB: generated %d correct, %d errors, %d total in fake scm-ret_item_number response\", elements $fl - $ec, $ec, elements $fl);\n    log(LL_DEBUG_2, \"data: %N\", $data);\n    log(LL_DEBUG_2, \"ret: %N\", $ret);\n%else\n    $ret = sepl_exec_scmhub($ds, \"scm-ret_item_number\", $data);\n%endif\n\n    my *hash $eh = sepl_scmhub_check_ret_hash($data, $ret, True, \"scm-ret_item_number\", False);\n\n    # process errors already logged\n    foreach my string $c in ($eh.keyIterator()) {\n        my string $ean = $lh.$c;\n\t# set transaction hash keys to True in error hash\n\tforeach my softstring $tid in ($dg.$ean)\n\t    $errh.$tid = True;\n    }\n\n    # missing ean hash\n    my hash $mh;\n\n    # create return hash and check for lookup failures\n    my hash $rv = hash();\n    foreach my hash $h in ($ret.x_param_out) {\n        my softstring $c = $h.QORUS_ROW_ID;\n        my string $ean = $lh.$c;\n\n        if ($h.STATUS != \"C\" || !strlen($h.ITEM_NUMBER)) {\n            $mh.$ean = True;\n\n\t    #swarning(SCMHUB_ERROR_INFO, sprintf(\"SCM-HUB item number lookup failed for ean %y; affects %d key%s (result: %y)\", $ean, elements $dg.$ean, elements $dg.$ean == 1 ? \"\" : \"s\", $h));\n\t    log(LL_DETAIL_1, \"missing lookup for ean %y affects the following key IDs: %y\", $ean, $dg.$ean);\t\t\n\t    \n\t    # set transaction hash keys to True in error hash\n\t    foreach my softstring $tid in ($dg.$ean)\n\t\t$errh.$tid = True;\n\t}\n\telse\n\t    $rv.$ean = $h.ITEM_NUMBER;\n    }\n\n    if ($mh)\n        swarning(SCMHUB_ERROR_SUMMARY, sprintf(\"SCM-HUB return item number lookup failed due to missing items for the following EAN codes: %y\", $mh.keys()));\n\n    return $rv;\n}\n\n#! processes item stockable flag info\n# dg: hash mapping EAN -> transaction_id\n# eh: hash mapping EAN -> item_number\nnothing sub sepl_scmhub_ret_item_stockable(object $ds, string $org_name, hash $dg, hash $eh, reference $errh, reference $skiph, string $input = \"ean\") {\n    my list $data = ();\n    # lh: lookup hash mapping QORUS_ROW_ID -> EAN\n    my hash $lh;\n    {\n        my int $c = 0;\n        foreach my string $id in ($eh.keyIterator()) {\n            $lh.$c = $id;\n            $data += (\n                \"LEGAL_ENTITY_CODE\": $org_name, \n                \"ITEM_NUMBER\": $eh.$id,\n                \"QORUS_ROW_ID\": $c,\n                );\n            ++$c;\n        }\n    }\n\n    my hash $ret;\n\n%ifdef QoreDebug\n    # fake response list\n    my list $fl = ();\n    # error count\n    my int $ec = 0;\n    {\n        my int $c = 0;        \n        foreach my string $id in (keys $eh) {\n            # to avoid warning\n            delete $id;\n            my bool $do_errs = !parse_boolean(getInstanceData(\"no-scmhub-errors\"));\n            # 10% chance of error on every record\n            if ($do_errs && !(rand() % 10)) {\n                ++$ec;\n                $fl += (\n                    \"MIT_STOCKABLE\": NULL, \n                    \"QORUS_ROW_ID\": $c++,\n                    \"STATUS\": \"E\",\n                    \"ERROR_MSG\": NULL,\n                    );\n            }\n            else {\n                $fl += (\n                    # 80 % stockabke\n                    \"MIT_STOCKABLE\": ($do_errs && !(rand() % 5)) ? \"N\" : \"Y\", \n                    \"QORUS_ROW_ID\": $c++,\n                    \"STATUS\": \"C\",\n                    \"ERROR_MSG\": NULL,\n                    );\n            }\n        }\n    }\n\n    $ret = (\n\t\"x_status\": list((\"STATUS_CODE\": 0, \"ERROR_CODE\": NULL, \"ERROR_DESCRIPTION\": NULL)),\n\t\"x_param_out\": $fl,\n\t);\n    log(LL_INFO, \"FAKE_SCMHUB: generated %d correct, %d errors, %d total in fake scm-ret_itm_stckble_flag response\", elements $fl - $ec, $ec, elements $fl);\n    log(LL_DEBUG_2, \"data: %N\", $data);\n    log(LL_DEBUG_2, \"ret: %N\", $ret);\n%else\n    $ret = sepl_exec_scmhub($ds, \"scm-ret_itm_stckble_flag\", $data);\n%endif\n\n    # do not raise detailed warnings for this call; summary warnings will be issued below\n    my *hash $terrh = sepl_scmhub_check_ret_hash($data, $ret, True, \"scm-ret_itm_stckble_flag\", False);\n\n    # process errors already logged\n    foreach my string $id in ($terrh.keyIterator()) {\n\t# set transaction hash keys to True in error hash\n        map $errh.$1 = True, $dg.($lh.$id);\n    }\n    \n    # missing item hash\n    my hash $mh;\n    # not stockable hash\n    my hash $nh;\n\n    # check for lookup failures\n    foreach my hash $h in ($ret.x_param_out) {\n        my softstring $c = $h.QORUS_ROW_ID;\n        my string $id = $lh.$c;\n\n\tif ($h.STATUS != \"C\" || !$h.MIT_STOCKABLE) {\n            $mh.$id = True;\n\t    #swarning(SCMHUB_ERROR_INFO, sprintf(\"SCM-HUB item stockable flag lookup failed for %s %y; affects %d key%s (result: %y)\", $input, $id, elements $dg.$id, elements $dg.$id == 1 ? \"\" : \"s\", $h));\n\t    log(LL_INFO, \"missing lookup for %s %y affects the following key IDs: %y\", $input, $id, $dg.$id);\t\t\n\t    \n\t    # set transaction hash keys to True in error hash\n\t    foreach my softstring $tid in ($dg.$id)\n\t\t$errh.$tid = True;\n\t}\n\telse if ($h.MIT_STOCKABLE == \"N\") {\n            $nh.$id = True;\n\t    #swarning(SCMHUB_RESULT, sprintf(\"SCM-HUB reports item stockable flag %s %y = %y; affects %d key%s\", $input, $id, $h.MIT_STOCKABLE, elements $dg.$id, elements $dg.$id == 1 ? \"\" : \"s\"));\n\t    log(LL_DETAIL_1, \"stockable flag for %s %y = %y; affects the following key IDs: %y\", $input, $id, $h.MIT_STOCKABLE, $dg.$id);\t\t\t    \n\t    # set transaction hash keys to True in error hash\n\t    foreach my softstring $tid in ($dg.$id)\n\t\t$skiph.$tid = True;\n\t}\n    }\n    if ($nh) {\n        my string $str;\n        if ($eh.firstKey() != $eh.firstValue())\n            $str = sprintf(\", corresponding to item_numbers: %y\", $eh.($nh.keys()).values());\n        swarning(SCMHUB_RESULT, sprintf(\"SCM-HUB reports the following %s codes as non-stockable: %y%s\", $input, $nh.keys(), $str));\n    }\n    if ($mh) {\n        my string $str;\n        if ($eh.firstKey() != $eh.firstValue())\n            $str = sprintf(\", corresponding to item_numbers: %y\", $eh.($mh.keys()));\n        swarning(SCMHUB_ERROR_SUMMARY, sprintf(\"SCM-HUB item stockable flag lookup failed due to missing items for the following %s codes: %y%s\", $input, $mh.keys(), $str));\n    }\n}\n\n#! takes a hash of storeIDs -> transactionIDs, a hash of storeID & party code info and returns a hash of party codes -> storage location info and processes the error hash\nhash sub sepl_scmhub_ret_storage_area_info_from_party_code(object $ds, string $org_name, hash $loc, hash $ph, reference $errh, string $party_type = \"OWN STORE\") {\n    log(LL_DETAIL_1, \"sepl_scmhub_ret_storage_area_info_from_party_code() about to look up %d party codes\", elements $ph);\n\n    my list $data = ();\n    foreach my softstring $sid in (keys $ph) {\n\t$data += (\n\t    \"LEGAL_ENTITY_CODE\": $org_name, \n\t    \"OPERATING_PARTY_CODE\": $ph.$sid,\n\t    \"PARTY_TYPE\": $party_type,\n\t    \"QORUS_ROW_ID\": $sid,  # store ID\n\t    );\n    }\n\n    my hash $ret;\n\n%ifdef QoreDebug\n    # fake response list\n    my list $fl = ();\n    # error count\n    my int $ec = 0;\n    my bool $do_errs = !parse_boolean(getInstanceData(\"no-scmhub-errors\"));\n    foreach my softstring $sid in (keys $ph) {\n\t# 10% chance of error on every record\n\tif ($do_errs && !(rand() % 10)) {\n\t    ++$ec;\n\t  $fl += (\n\t      \"WHS_CODE\": NULL, \n\t      \"STA_CODE\": NULL,\n\t      \"QORUS_ROW_ID\": $sid,\n\t      \"STATUS\": \"E\",\n\t      \"ERROR_MSG\": NULL,\n\t      );\n\t}\n\telse {\n\t  $fl += (\n\t      \"WHS_CODE\": $ph.$sid,\n\t      \"STA_CODE\": $ph.$sid,\n\t      \"QORUS_ROW_ID\": $sid,\n\t      \"STATUS\": \"C\",\n\t      \"ERROR_MSG\": NULL,\n\t      );\n\t}\n    }\n\n    $ret = (\n\t\"x_status\": list((\"STATUS_CODE\": 0, \"ERROR_CODE\": NULL, \"ERROR_DESCRIPTION\": NULL)),\n\t\"x_param_out\": $fl,\n\t);\n    log(LL_INFO, \"FAKE_SCMHUB: generated %d correct, %d errors, %d total in fake scm-ret_storage_area_inf response\", elements $fl - $ec, $ec, elements $fl);\n    log(LL_DEBUG_2, \"data: %N\", $data);\n    log(LL_DEBUG_2, \"ret: %N\", $ret);\n%else\n    $ret = sepl_exec_scmhub($ds, \"scm-ret_storage_area_inf\", $data);\n%endif\n\n    my list $errs = sepl_scmhub_check_ret($data, $ret, True, \"scm-ret_storage_area_inf\");\n\n    # process errors already logged\n    foreach my string $sid in ($errs) {\n\t# set transaction hash keys to True in error hash\n\tforeach my softstring $tid in ($loc.$sid)\n\t    $errh.$tid = True;\n    }\n\n    # create return hash and check for lookup failures\n    my hash $rv = hash();\n    foreach my hash $h in ($ret.x_param_out) {\n\tmy softstring $sid = $h.QORUS_ROW_ID;\n\tif ($h.STATUS != \"C\" || !strlen($h.WHS_CODE) || !strlen($h.STA_CODE)) {\n\t    swarning(SCMHUB_ERROR_INFO, sprintf(\"SCM-HUB storage area lookup failed for party code %y (storeid %y); affects %d key%s (result: %y)\", $ph.$sid, $sid, elements $loc.$sid, elements $loc.$sid == 1 ? \"\" : \"s\", $h));\n\t    log(LL_DETAIL_1, \"missing lookup for party code %y (storeid %y) affects the following key IDs: %y\", $ph.$sid, $sid, $loc.$sid);\t\t\n\t    \n\t    # set transaction hash keys to True in error hash\n\t    foreach my softstring $tid in ($loc.$sid)\n\t\t$errh.$tid = True;\n\t}\n\telse {\n\t    $rv.$sid = $h;\n\t}\n    }\n\n    return $rv;\n}\n\nhash sub sepl_scmhub_get_single_org(object $ds, string $party) {\n    my list $data = \n\tlist((\n\t    \"PARTY_CODE\": $party,\n\t    \"QORUS_ROW_ID\": 0,\n\t     )\n\t);\n\n    my hash $ret;\n\n%ifdef QoreDebug\n    # fake response list\n    my list $fl = ();\n    # error count\n    my int $ec = 0;\n    $fl += (\n\t\"ORGANIZATION_CODE\": $party, \n\t\"SUBINVENTORY\": $party,\n\t\"QORUS_ROW_ID\": 0,\n\t\"STATUS\": \"C\",\n\t\"ERROR_MSG\": NULL,\n\t);\n\n    $ret = (\n\t\"x_status\": list((\"STATUS_CODE\": 0, \"ERROR_CODE\": NULL, \"ERROR_DESCRIPTION\": NULL)),\n\t\"x_param_out\": $fl,\n\t);\n    log(LL_INFO, \"FAKE_SCMHUB: generated %d correct, %d errors, %d total in fake scm-ret_org_info response\", elements $fl - $ec, $ec, elements $fl);\n    log(LL_DEBUG_2, \"data: %N\", $data);\n    log(LL_DEBUG_2, \"ret: %N\", $ret);\n%else\n    $ret = sepl_exec_scmhub($ds, \"scm-ret_org_info\", $data);\n%endif\n\n    my list $errs = sepl_scmhub_check_ret($data, $ret, True, \"scm-ret_org_info\");\n    if (elements $errs)\n\tthrow \"SCMHUB-ERROR\", sprintf(\"failed to get org info for party %y\", $party);\n\n    my hash $h = $ret.x_param_out[0];\n    if ($h.STATUS != \"C\" || !strlen($h.ORGANIZATION_CODE) || !strlen($h.SUBINVENTORY))\n\tthrow \"SCMHUB-ERROR\", sprintf(\"SCM-HUB organization lookup failed for party %y (result: %y)\", $party, $h);\n\n    my hash $rv = (\n\t\"organization_code\": $ret.x_param_out[0].ORGANIZATION_CODE,\n\t\"subinventory\": $ret.x_param_out[0].SUBINVENTORY,\n\t);\n\n    log(LL_DETAIL_1, \"scmhub got org info for party %y: %y\", $party, $rv);\n\n    return $rv;\n}\n\n%ifdef CURRENTLY_UNUSED\n#! takes a hash of item numbers -> tansactionIDs and returns a hash of item numbers -> user item type aggregation values\nhash sub sepl_scmhub_ret_usr_item_type(object $ds, string $org_name, hash $item_numbers, reference $errh) {\n    log(LL_DETAIL_1, \"sepl_scmhub_ret_usr_item_type() about to look up %d item number%s\", $item_numbers.size(), $item_numbers.size() == 1 ? \"\" : \"s\");\n\n    my list $data = ();\n    my HashIterator $hi($item_numbers);\n    while ($hi.next()) {\n\t$data += (\n\t    \"LEGAL_ENTITY\": $org_name, \n\t    \"ITEM_NUMBER\": $hi.getKey(),\n\t    \"QORUS_ROW_ID\": $hi.getKey(),\n\t    );\n    }\n\n    my hash $ret;\n\n%ifdef QoreDebug\n    # fake response list\n    my list $fl = ();\n    # error count\n    my int $ec = 0;\n    my bool $do_errs = !parse_boolean(getInstanceData(\"no-scmhub-errors\"));\n    foreach my softstring $id in (keys $item_numbers) {\n\t# 10% chance of error on every record\n\tif ($do_errs && !(rand() % 10)) {\n\t    ++$ec;\n            $fl += (\n                \"ITEM_TYPE_AGGREGATION\": NULL, \n                \"STA_CODE\": NULL,\n                \"QORUS_ROW_ID\": $id,\n                \"STATUS\": \"E\",\n                \"ERROR_MSG\": \"Ooops, I did it again, la la la la, I love Britney Spears! signed: Marian Bonda\",\n                );\n\t}\n\telse {\n            $fl += (\n                \"ITEM_TYPE_AGGREGATION\": \"DEVICE\",\n                \"STA_CODE\": $id,\n                \"QORUS_ROW_ID\": $id,\n                \"STATUS\": \"C\",\n                \"ERROR_MSG\": NULL,\n                );\n\t}\n    }\n\n    $ret = (\n\t\"x_status\": list((\"STATUS_CODE\": 0, \"ERROR_CODE\": NULL, \"ERROR_DESCRIPTION\": NULL)),\n\t\"x_param_out\": $fl,\n\t);\n    log(LL_INFO, \"FAKE_SCMHUB: generated %d correct, %d errors, %d total in fake scm-ret_usr_item_type response\", elements $fl - $ec, $ec, elements $fl);\n    log(LL_DEBUG_2, \"data: %N\", $data);\n    log(LL_DEBUG_2, \"ret: %N\", $ret);\n%else\n    $ret = sepl_exec_scmhub($ds, \"scm-ret_usr_item_type\", $data);\n%endif\n    \n    my *hash $eh = sepl_scmhub_check_ret_hash($data, $ret, True, \"scm-ret_usr_item_type\");\n\n    # process errors already logged\n    foreach my string $iid in (keys $eh) {\n        # set transaction hash keys to True in error hash\n        map $errh.$1 = True, $item_numbers.$iid;\n    }\n\n    # create return hash and check for lookup failures\n    my hash $rv = hash();\n    foreach my hash $h in ($ret.x_param_out) {\n        my softstring $iid = $h.QORUS_ROW_ID;\n    \tif ($h.STATUS != \"C\" || !$h.ITEM_TYPE_AGGREGATION) {\n            swarning(SCMHUB_ERROR_INFO, sprintf(\"SCM-HUB user item type aggregation failed for item number %y; affects %d key%s (result: %y)\", $iid, elements $item_numbers.$iid, elements $item_numbers.$iid == 1 ? \"\" : \"s\", $h));\n            log(LL_DETAIL_1, \"missing lookup for item number %y affects the following key IDs: %y\", $iid, $item_numbers.$iid);\t\t\n\t    \n    \t    # set transaction hash keys to True in error hash\n            map $errh.$1 = True, $item_numbers.$iid;\n        } else {\n            $rv.$iid = $h.ITEM_TYPE_AGGREGATION;\n        }\n    }\n    \n    return $rv;\n}\n%endif\n\n%ifdef CURRENTLY_UNUSED\n#! takes a hash of transactionIDs -> operating party, party type, item number (stock_code) and returns a hash of transactionID -> usim item number, mobile item number and processes the error hash\nhash sub sepl_scmhub_ret_wrk_req_comp_i(object $ds, string $org_name, hash $data_hash, reference $errh) {\n    log(LL_DETAIL_1, \"sepl_scmhub_ret_wrk_req_comp_i() about to look up %d wrk req comp infomrmation\", elements $data_hash);\n\n    my list $data = ();\n    foreach my softstring $id in (keys $data_hash) {\n\t$data += (\n\t    \"LEGAL_ENTITY\": $org_name,\n            \"OPERATING_PARTY\": $data_hash.$id.operating_party,\n            \"PARTY_TYPE\": $data_hash.$id.party_type,\n\t    \"ITEM_NUMBER\": $data_hash.$id.item_number,     \t    \n\t    \"QORUS_ROW_ID\": $id,\n\t    );\n    }\n\n    my hash $ret;\n\n%ifdef QoreDebug\n    # fake response list\n    my list $fl = ();\n    # error count\n    my int $ec = 0;\n    my bool $do_errs = !parse_boolean(getInstanceData(\"no-scmhub-errors\"));\n    foreach my softstring $id in (keys $data_hash) {\n\t# 10% chance of error on every record\n\tif ($do_errs && !(rand() % 10)) {\n\t    ++$ec;\n\t  $fl += (\n\t      \"USIM_ITEM_NUMBER\": NULL,\n\t      \"MOBILE_ITEM_NUMBER\": NULL,\n\t      \"STA_CODE\": NULL,\n\t      \"QORUS_ROW_ID\": $id,\n\t      \"STATUS\": \"E\",\n\t      \"ERROR_MSG\": NULL,\n\t      );\n\t}\n\telse {\n\t  $fl += (\n\t      \"USIM_ITEM_NUMBER\": $data_hash.$id,\n\t      \"MOBILE_ITEM_NUMBER\": $data_hash.$id,\n\t      \"STA_CODE\": $data_hash.$id,\n\t      \"QORUS_ROW_ID\": $id,\n\t      \"STATUS\": \"C\",\n\t      \"ERROR_MSG\": NULL,\n\t      );\n\t}\n    }\n\n    $ret = (\n\t\"x_status\": list((\"STATUS_CODE\": 0, \"ERROR_CODE\": NULL, \"ERROR_DESCRIPTION\": NULL)),\n\t\"x_param_out\": $fl,\n\t);\n    log(LL_INFO, \"FAKE_SCMHUB: generated %d correct, %d errors, %d total in fake scm-ret_wrk_req_comp_i response\", elements $fl - $ec, $ec, elements $fl);\n    log(LL_DEBUG_2, \"data: %N\", $data);\n    log(LL_DEBUG_2, \"ret: %N\", $ret);\n%else\n    $ret = sepl_exec_scmhub($ds, \"scm-ret_wrk_req_comp_i\", $data);\n%endif\n\n    $errh += sepl_scmhub_check_ret_hash($data, $ret, True, \"scm-ret_wrk_req_comp_i\");\n\n    # create return hash and check for lookup failures\n    my hash $rv = hash();\n    foreach my hash $h in ($ret.x_param_out) {\n        my softstring $id = $h.QORUS_ROW_ID;\n        if ($h.STATUS != \"C\" || (!$h.USIM_ITEM_NUMBER || !$h.MOBILE_ITEM_NUMBER)) {\n            swarning(SCMHUB_ERROR_INFO, sprintf(\"SCM-HUB retrieve work request component information failed for row id %y (result: %y)\", $id, $h));\n            \n            # set transaction hash keys to True in error hash\n            $errh.$id = True;\n        }\n    } else {\n        $rv.$id = $h.(\"USIM_ITEM_NUMBER\", \"MOBILE_ITEM_NUMBER\");\n    }\n\n    return $rv;\n}\n%endif\n\n#! takes a hash of transactionIDs -> item_numbers and returns a hash of transactionID -> is_prepay_kit values and processes the error hash\nhash sub sepl_scmhub_ret_is_prepay(object $ds, string $org_name, string $op_party, string $party_type, hash $data_hash, reference $errh) {\n    log(LL_DETAIL_1, \"sepl_scmhub_ret_is_prepay() about to look up %d item_numbers\", $data_hash.size());\n\n    my list $data = ();\n    {\n        my HashIterator $hi($data_hash);\n        while ($hi.next()) {\n            $data += (\n                \"LEGAL_ENTITY\": $org_name,\n                \"OPERATING_PARTY\": $op_party,\n                \"PARTY_TYPE\": $party_type,\n                \"ITEM_NUMBER\": $hi.getValue(),\n                \"QORUS_ROW_ID\": $hi.getKey(),\n                );\n        }\n    }\n    \n    my hash $ret;\n\n%ifdef QoreDebug\n    # fake response list\n    my list $fl = ();\n    # error count\n    my int $ec = 0;\n    my bool $do_errs = !parse_boolean(getInstanceData(\"no-scmhub-errors\"));\n    my HashIterator $hi($data_hash);\n    while ($hi.next()) {\n        my hash $h;\n\t# 10% chance of error on every record\n\tif ($do_errs && !(rand() % 10)) {\n\t    ++$ec;\n            $h = (\n                \"IS_PREPAY_KIT\": NULL,\n                \"STATUS\": \"E\",\n                );\n\t}\n\telse {\n            $h = (\n                \"IS_PREPAY_KIT\":rand() % 5 ? \"Y\" : \"N\",\n                \"STATUS\": \"C\",\n                );\n\t}\n        $h += (\n            \"QORUS_ROW_ID\": $hi.getKey(),\n            \"ERROR_MSG\": NULL,\n            );\n        $fl += $h;\n    }\n\n    $ret = (\n\t\"x_status\": list((\"STATUS_CODE\": 0, \"ERROR_CODE\": NULL, \"ERROR_DESCRIPTION\": NULL)),\n\t\"x_param_out\": $fl,\n\t);\n    log(LL_INFO, \"FAKE_SCMHUB: generated %d correct, %d errors, %d total in fake scm-ret_is_prepay response\", elements $fl - $ec, $ec, elements $fl);\n    log(LL_DEBUG_2, \"data: %N\", $data);\n    log(LL_DEBUG_2, \"ret: %N\", $ret);\n%else\n    $ret = sepl_exec_scmhub($ds, \"scm-ret_is_prepay\", $data);\n%endif\n\n    # add errors to error hash here (do not reassign as it may already have error information)\n    $errh += sepl_scmhub_check_ret_hash($data, $ret, True, \"scm-ret_is_prepay\");\n\n    # create return hash and check for lookup failures\n    my hash $rv = hash();\n    foreach my hash $h in ($ret.x_param_out) {\n        my softstring $tid = $h.QORUS_ROW_ID;\n        if ($h.STATUS != \"C\" || !$h.IS_PREPAY_KIT) {\n            swarning(SCMHUB_ERROR_INFO, sprintf(\"SCM-HUB is_prepay_kit failed for row id %y; affects 1 key (result: %y)\", $tid, $h));\n            log(LL_DETAIL_1, \"missing info in is_prepay_kit response for key ID: %y\", $tid);\n            # set transaction hash key to True in error hash\n            $errh.$tid = True;\n        } else {\n            $rv.$tid = $h.IS_PREPAY_KIT;\n        }\n    }\n    \n    return $rv;\n}\n\n%ifdef CURRENTLY_UNUSED\n#! takes a hash of transactionIDs -> msisdn, serial number and returns a hash of transactionID -> msisdn, serial number and processes the error hash\nhash sub sepl_scmhub_ret_iccid_msisdn_p(object $ds, string $org_name, hash $data_hash, reference $errh) {\n    log(LL_DETAIL_1, \"sepl_scmhub_ret_iccid_msisdn_p() about to look up %d pairings\", elements $data_hash);\n\n    my list $data = ();\n    foreach my softstring $id in (keys $data_hash) {\n\t$data += (\n\t    \"LEGAL_ENTITY\": $org_name,\n            \"MSISDN\": $data_hash.$id.msisdn,\n            \"SERIAL_NUMBER\": $data_hash.$id.serial_number,\n\t    \"QORUS_ROW_ID\": $id,\n\t    );\n    }\n    \n    my hash $ret;\n\n%ifdef QoreDebug\n    # fake response list\n    my list $fl = ();\n    # error count\n    my int $ec = 0;\n    my bool $do_errs = !parse_boolean(getInstanceData(\"no-scmhub-errors\"));\n    foreach my softstring $id in (keys $data_hash) {\n\t# 10% chance of error on every record\n\tif ($do_errs && !(rand() % 10)) {\n\t    ++$ec;\n\t  $fl += (\n\t      \"MSISDN\": NULL,\n\t      \"SERIAL_NUMBER\": NULL,\n\t      \"STA_CODE\": NULL,\n\t      \"QORUS_ROW_ID\": $id,\n\t      \"STATUS\": \"E\",\n\t      \"ERROR_MSG\": NULL,\n\t      );\n\t}\n\telse {\n\t  $fl += (\n\t      \"MSISDN\": $data_hash.$id.msisdn,\n\t      \"SERIAL_NUMBER\": $data_hash.$id.serial_number ? $data_hash.$id.serial_number : $data_hash.$id.msisdn,\n\t      \"STA_CODE\": $id,\n\t      \"QORUS_ROW_ID\": $id,\n\t      \"STATUS\": \"C\",\n\t      \"ERROR_MSG\": NULL,\n\t      );\n\t}\n    }\n\n    $ret = (\n\t\"x_status\": list((\"STATUS_CODE\": 0, \"ERROR_CODE\": NULL, \"ERROR_DESCRIPTION\": NULL)),\n\t\"x_param_out\": $fl,\n\t);\n    log(LL_INFO, \"FAKE_SCMHUB: generated %d correct, %d errors, %d total in fake scm-ret_iccid_msisdn_p response\", elements $fl - $ec, $ec, elements $fl);\n    log(LL_DEBUG_2, \"data: %N\", $data);\n    log(LL_DEBUG_2, \"ret: %N\", $ret);\n%else\n    $ret = sepl_exec_scmhub($ds, \"scm-ret_iccid_msisdn_p\", $data);\n%endif\n\n    # add errors to error hash here (do not reassign as it may already have error information)\n    $errh += sepl_scmhub_check_ret_hash($data, $ret, True, \"scm-ret_iccid_msisdn_p\");\n\n    # create return hash and check for lookup failures\n    my hash $rv = hash();\n    foreach my hash $h in ($ret.x_param_out) {\n        my softstring $tid = $h.QORUS_ROW_ID;\n        if ($h.STATUS != \"C\" || (!strlen($h.MSISDN) && !strlen($h.SERIAL_NUMBER))) {\n            swarning(SCMHUB_ERROR_INFO, sprintf(\"SCM-HUB retrieve iccid/msisdn pairings failed for row id %y; affects 1 key (result: %y)\", $tid, $h));\n            log(LL_DETAIL_1, \"missing lookup for iccid/msisdn pairing for key ID: %y\", $tid);\n            # set transaction hash key to True in error hash\n            $errh.$tid = True;\n        } else {\n            $rv.$tid = $h.(\"MSISDN\", \"SERIAL_NUMBER\");\n        }\n    }\n    \n    return $rv;\n}\n%endif\n\n%ifdef CURRENTLY_UNUSED\n#! takes a hash of transactionIDs -> msisdn and returns a hash of transactionID -> msisdn, paired serial number and processes the error hash\nhash sub sepl_scmhub_ret_imei_iccid_p(object $ds, string $org_name, hash $data_hash, reference $errh) {\n\n    log(LL_DETAIL_1, \"sepl_scmhub_ret_imei_iccid_p() about to look up %d pairings\", elements $data_hash);\n\n    my list $data = ();\n    foreach my softstring $id in (keys $data_hash) {\n\t$data += (\n\t    \"LEGAL_ENTITY_CODE\": $org_name,\n            \"MSISDN\": $data_hash.$id.msisdn,\n\t    \"QORUS_ROW_ID\": $id,\n\t    );\n    }\n\n    my hash $ret;\n\n%ifdef QoreDebug\n    # fake response list\n    my list $fl = ();\n    # error count\n    my int $ec = 0;\n    my bool $do_errs = !parse_boolean(getInstanceData(\"no-scmhub-errors\"));\n    foreach my softstring $id in (keys $data_hash) {\n\t# 10% chance of error on every record\n\tif ($do_errs && !(rand() % 10)) {\n\t    ++$ec;\n\t  $fl += (\n\t      \"MSISDN\": NULL,\n\t      \"PAIRED_SERIAL_NUMBER\": NULL,\n\t      \"STA_CODE\": NULL,\n\t      \"QORUS_ROW_ID\": $id,\n\t      \"STATUS\": \"E\",\n\t      \"ERROR_MSG\": NULL,\n\t      );\n\t}\n\telse {\n\t  $fl += (\n\t      \"MSISDN\": $data_hash.$id,\n\t      \"PAIRED_SERIAL_NUMBER\": $data_hash.$id,\n\t      \"STA_CODE\": $data_hash.$id,\n\t      \"QORUS_ROW_ID\": $id,\n\t      \"STATUS\": \"C\",\n\t      \"ERROR_MSG\": NULL,\n\t      );\n\t}\n    }\n\n    $ret = (\n\t\"x_status\": list((\"STATUS_CODE\": 0, \"ERROR_CODE\": NULL, \"ERROR_DESCRIPTION\": NULL)),\n\t\"x_param_out\": $fl,\n\t);\n    log(LL_INFO, \"FAKE_SCMHUB: generated %d correct, %d errors, %d total in fake scm-ret_imei_iccid_p response\", elements $fl - $ec, $ec, elements $fl);\n    log(LL_DEBUG_2, \"data: %N\", $data);\n    log(LL_DEBUG_2, \"ret: %N\", $ret);\n%else\n    $ret = sepl_exec_scmhub($ds, \"scm-ret_imei_iccid_p\", $data);\n%endif\n\n    $errh += sepl_scmhub_check_ret_hash($data, $ret, True, \"scm-ret_imei_iccid_p\");\n\n    # create return hash and check for lookup failures\n    my hash $rv = hash();\n    foreach my hash $h in ($ret.x_param_out) {\n        my softstring $id = $h.QORUS_ROW_ID;\n        if ($h.STATUS != \"C\" || (!$h.MSISDN && !$h.PAIRED_SERIAL_NUMBER)) {\n            swarning(SCMHUB_ERROR_INFO, sprintf(\"SCM-HUB retrieve imei/iccid pairings failed for row id %y (result: %y)\", $id, $h));\n\t    \n            # set transaction hash keys to True in error hash\n            $errh.$id = True;\n        } else\n            $rv.$id = $h.(\"MSISDN\", \"PAIRED_SERIAL_NUMBER\");\n    }\n\n    return $rv;\n}\n%endif\n\n#! takes a hash of order_id -> list(transaction_id) and returns a hash of order_id -> rma order type and processes the error hash appropriately\nhash sub sepl_scmhub_ret_rma_order_type(object $ds, string $org_name, hash $data_hash, reference $errh) {\n    log(LL_DETAIL_1, \"sepl_scmhub_ret_rma_order_type() about to look up %d order IDs\", elements $data_hash);\n\n    # scmhub call data list\n    my list $data = ();\n    # index lookup hash from qorus_row_id -> order_id\n    my hash $ilh;\n    {\n        my HashIterator $hi($data_hash);\n        my int $c = 0;\n        while ($hi.next()) {\n            # insert qorus_row_id -> order_id lookup entry\n            $ilh.$c = $hi.getKey();\n            $data += (\n                \"LEGAL_ENTITY\": $org_name,\n                \"DOCUMENT_IDENTIFIER\": $hi.getKey(),\n                \"QORUS_ROW_ID\": $c++,\n\t    );\n        }\n    }\n\n    my hash $ret;\n\n%ifdef QoreDebug\n    # fake response list\n    my list $fl = ();\n    # error count\n    my int $ec = 0;\n    my bool $do_errs = !parse_boolean(getInstanceData(\"no-scmhub-errors\"));\n    my HashIterator $hi($data_hash);\n    while ($hi.next()) {\n\t# 10% chance of error on every record\n\tif ($do_errs && !(rand() % 10)) {\n\t    ++$ec;\n\t  $fl += (\n\t      \"ORACLE_ORDER_TYPE\": NULL,\n\t      \"QORUS_ROW_ID\": $fl.size(),\n\t      \"STATUS\": \"E\",\n\t      \"ERROR_MSG\": NULL,\n\t      );\n\t}\n\telse {\n\t  $fl += (\n\t      \"ORACLE_ORDER_TYPE\": $org_name == \"UK_OPCO\" ? \"WOM Internal Return\" : \"DOM IE EXCHANGE Return\",\n\t      \"QORUS_ROW_ID\": $fl.size(),\n\t      \"STATUS\": \"C\",\n\t      \"ERROR_MSG\": NULL,\n\t      );\n\t}\n    }\n\n    $ret = (\n\t\"x_status\": list((\"STATUS_CODE\": 0, \"ERROR_CODE\": NULL, \"ERROR_DESCRIPTION\": NULL)),\n\t\"x_param_out\": $fl,\n\t);\n    log(LL_INFO, \"FAKE_SCMHUB: generated %d correct, %d errors, %d total in fake scm-ret_rma_order_type response\", elements $fl - $ec, $ec, elements $fl);\n    log(LL_DEBUG_2, \"data: %N\", $data);\n    log(LL_DEBUG_2, \"ret: %N\", $ret);\n%else\n    $ret = sepl_exec_scmhub($ds, \"scm-ret_rma_order_type\", $data);\n%endif\n\n    my *hash $eh = sepl_scmhub_check_ret_hash($data, $ret, True, \"scm-ret_rma_order_type\");\n\n    # process errors already logged\n    foreach my string $c in (keys $eh) {\n        # set transaction hash keys to True in error hash\n        map $errh.$1 = True, $data_hash.($ilh.$c);\n    }\n\n    # create return hash and check for lookup failures\n    my hash $rv = hash();\n    foreach my hash $h in ($ret.x_param_out) {\n        my softstring $oid = $ilh.($h.QORUS_ROW_ID);\n        #log(LL_DEBUG_2, \"oid: %y\", $oid);\n        if ($h.STATUS != \"C\" || !$h.ORACLE_ORDER_TYPE) {\n            swarning(SCMHUB_ERROR_INFO, sprintf(\"SCM-HUB retrieve rma order type failed for document identifier %s; (result: %y)\", $oid, $h));\n            \n            # set transaction hash keys to True in error hash\n            map $errh.$1 = True, $data_hash.$oid;\n        } else {\n            $rv.$oid = $h.\"ORACLE_ORDER_TYPE\";\n        }\n    }\n\n    return $rv;\n}\n\n\n#! takes a list of serial_numbers and returns a hash of serial_number -> gl_account_id and processes the error hash appropriately\nhash sub sepl_scmhub_ret_gl_account_id(object $ds, string $org_name, list $serial_numbers, string $default_gl_account_id, reference $errh) {\n    log(LL_DETAIL_1, \"sepl_scmhub_ret_gl_account_id() about to look up %d order IDs\", elements $serial_numbers);\n\n    # scmhub call data list\n    my list $data = ();\n\n    # index lookup hash from qorus_row_id -> serial_number\n    my hash $ilh;\n    {\n        my int $c = 0;\n        foreach my hash $sn in ($serial_numbers){\n            # insert qorus_row_id -> order_id lookup entry\n            $ilh.$c = $sn.serial_number;\n            $data += (\n                \"LEGAL_ENTITY\": $org_name,\n                \"SERIAL_NUMBER\": $sn.serial_number,\n                \"QORUS_ROW_ID\": $c++,\n\t    );\n        }\n    }\n\n    my hash $ret;\n\n%ifdef QoreDebug\n    # fake response list\n    my list $fl = ();\n    # error count\n    my int $ec = 0;\n    my bool $do_errs = !parse_boolean(getInstanceData(\"no-scmhub-errors\"));\n    foreach my hash $sn in ($serial_numbers){\n        delete $sn;\n\t# 10% chance of error on every record\n\tif ($do_errs && !(rand() % 10)) {\n\t    ++$ec;\n\t  $fl += (\n\t      \"EXP_ACCOUNT_ID\": NULL,\n\t      \"QORUS_ROW_ID\": $fl.size(),\n\t      \"STATUS\": \"E\",\n\t      \"ERROR_MSG\": NULL,\n\t      );\n\t}\n\telse {\n\t  $fl += (\n\t      \"EXP_ACCOUNT_ID\": \"123456789\",\n\t      \"QORUS_ROW_ID\": $fl.size(),\n\t      \"STATUS\": \"C\",\n\t      \"ERROR_MSG\": NULL,\n\t      );\n\t}\n    }\n\n    $ret = (\n\t\"x_status\": list((\"STATUS_CODE\": 0, \"ERROR_CODE\": NULL, \"ERROR_DESCRIPTION\": NULL)),\n\t\"x_param_out\": $fl,\n\t);\n    log(LL_INFO, \"FAKE_SCMHUB: generated %d correct, %d errors, %d total in fake scm-ret_rma_order_type response\", elements $fl - $ec, $ec, elements $fl);\n    log(LL_DEBUG_2, \"data: %N\", $data);\n    log(LL_DEBUG_2, \"ret: %N\", $ret);\n%else\n    $ret = sepl_exec_scmhub($ds, \"scm-ret_expen_accnt_id\", $data);\n%endif\n    \n    # create return hash and check for lookup failures\n    my hash $rv = hash();\n    foreach my hash $h in ($ret.x_param_out) {\n        my softstring $oid = $ilh.($h.QORUS_ROW_ID);\n        #log(LL_DEBUG_2, \"oid: %y\", $oid);\n        if ($h.STATUS != \"C\" || !$h.EXP_ACCOUNT_ID) {\n            swarning(SCMHUB_ERROR_INFO, sprintf(\"SCM-HUB retrieve gl_account_id failed for serial_number %s; using default: '%s'; (result: %y)\", $oid, $default_gl_account_id, $h));\n            $rv.$oid.\"gl_account_id\" = $default_gl_account_id;\n            $rv.$oid.\"reason_code\" = \"Internal Return\";\n            $rv.$oid.\"message_type\" = \"INV_STOCK_ADJ\";\n        } else {\n            $rv.$oid.\"gl_account_id\" = $h.\"EXP_ACCOUNT_ID\";\n            $rv.$oid.\"reason_code\" = \"Internal Return\";\n            $rv.$oid.\"message_type\" = \"INV_STOCK_ADJ\";\n        }\n    }\n\n    return $rv;\n\n}\n\n#! takes a hash of transactionIDs -> delivery_detail_id and returns a hash of transactionID -> account, cost_center and processes the error hash\nhash sub sepl_scmhub_ret_int_req_account(object $ds, string $org_name, hash $data_hash, reference $errh) {\n    log(LL_DETAIL_1, \"sepl_scmhub_ret_int_req_account() about to look up %d pairings\", elements $data_hash);\n\n    my list $data = ();\n    foreach my softstring $id in (keys $data_hash) {\n\t$data += (\n\t    \"LEGAL_ENTITY\": $org_name,\n            \"MSISDN\": $data_hash.$id,\n\t    \"QORUS_ROW_ID\": $id,\n\t    );\n    }\n\n    my hash $ret;\n\n%ifdef QoreDebug\n    # fake response list\n    my list $fl = ();\n    # error count\n    my int $ec = 0;\n    my bool $do_errs = !parse_boolean(getInstanceData(\"no-scmhub-errors\"));\n    foreach my softstring $id in (keys $data_hash) {\n\t# 10% chance of error on every record\n\tif ($do_errs && !(rand() % 10)) {\n\t    ++$ec;\n\t  $fl += (\n\t      \"ACCOUNT\": NULL,\n\t      \"COST_CENTER\": NULL,\n\t      \"STA_CODE\": NULL,\n\t      \"QORUS_ROW_ID\": $id,\n\t      \"STATUS\": \"E\",\n\t      \"ERROR_MSG\": NULL,\n\t      );\n\t}\n\telse {\n\t  $fl += (\n\t      \"ACCOUNT\": $data_hash.$id,\n\t      \"COST_CENTER\": $data_hash.$id,\n\t      \"STA_CODE\": $data_hash.$id,\n\t      \"QORUS_ROW_ID\": $id,\n\t      \"STATUS\": \"C\",\n\t      \"ERROR_MSG\": NULL,\n\t      );\n\t}\n    }\n\n    $ret = (\n\t\"x_status\": list((\"STATUS_CODE\": 0, \"ERROR_CODE\": NULL, \"ERROR_DESCRIPTION\": NULL)),\n\t\"x_param_out\": $fl,\n\t);\n    log(LL_INFO, \"FAKE_SCMHUB: generated %d correct, %d errors, %d total in fake scm-ret_int_req_account response\", elements $fl - $ec, $ec, elements $fl);\n    log(LL_DEBUG_2, \"data: %N\", $data);\n    log(LL_DEBUG_2, \"ret: %N\", $ret);\n%else\n    $ret = sepl_exec_scmhub($ds, \"scm-ret_int_req_account\", $data);\n%endif\n\n    $errh += sepl_scmhub_check_ret_hash($data, $ret, True, \"scm-ret_int_req_account\");\n\n    # create return hash and check for lookup failures\n    my hash $rv = hash();\n    foreach my hash $h in ($ret.x_param_out) {\n        my softstring $id = $h.QORUS_ROW_ID;\n        if ($h.STATUS != \"C\" || (!$h.ACCOUNT || !$h.COST_CENTER)) {\n            swarning(SCMHUB_ERROR_INFO, sprintf(\"SCM-HUB retrieve internal requisition accounting failed for row id %y (result: %y)\", $id, $h));\n\t    \n            # set transaction hash keys to True in error hash\n            $errh.$id = True;\n        } else {\n            $rv.$id = $h.(\"ACCOUNT\", \"COST_CENTER\");\n        }\n    }\n\n    return $rv;\n}\n\n#! takes a hash of order_id -> list(transaction_id) and returns a hash of order_id -> order_type and processes the error hash appropriately\nhash sub sepl_scmhub_ret_doc_header(object $ds, string $org_name, string $op_party, hash $data_hash, reference $errh, string $sending_sys = \"E-Biz\", string $party_type = \"SCM PARTNER\", string $trans_type = \"OM_SHIP_REQ\") {\n    log(LL_DETAIL_1, \"sepl_scmhub_ret_doc_header() about to look up %d order IDs\", elements $data_hash);\n\n    # scmhub call data list\n    my list $data = ();\n    # index lookup hash from qorus_row_id -> order_id\n    my hash $ilh;\n    {\n        my HashIterator $hi($data_hash);\n        my int $c = 0;\n        while ($hi.next()) {\n            # insert qorus_row_id -> order_id lookup entry\n            $ilh.$c = $hi.getKey();\n            $data += (\n                \"LEGAL_ENTITY\": $org_name,\n                \"SENDING_SYSTEM\": $sending_sys,\n                \"OPERATING_PARTY\": $op_party,\n                \"PARTY_TYPE\": $party_type,\n                \"TRANSACTION_TYPE\": $trans_type,\n                \"SYSTEM_REFERENCE\": $hi.getKey(),\n                \"QORUS_ROW_ID\": $c++,\n\t    );\n        }\n    }\n\n    my hash $ret;\n\n%ifdef QoreDebug\n    # fake response list\n    my list $fl = ();\n    # error count\n    my int $ec = 0;\n    my bool $do_errs = !parse_boolean(getInstanceData(\"no-scmhub-errors\"));\n    foreach my softstring $oid in (keys $data_hash) {\n        my hash $h = (\n            \"QORUS_ROW_ID\": $fl.size(),\n            \"SYSTEM_REFERENCE\": $oid,\n            );\n\t# 10% chance of error on every record\n\tif ($do_errs && !(rand() % 10)) {\n            $h += (\n                \"ORACLE_ORDER_TYPE\": NULL,\n                \"STATUS\": \"E\",\n                \"ERROR_MSG\": NULL,\n                );\n\t    ++$ec;\n        }\n\telse {\n            $h += (\n\t      \"ORACLE_ORDER_TYPE\": \"WOM H3G Retail Return\",\n\t      \"STATUS\": \"C\",\n\t      \"ERROR_MSG\": NULL,\n\t      );\n\t}\n        $fl += $h;\n    }\n\n    $ret = (\n\t\"x_status\": list((\"STATUS_CODE\": 0, \"ERROR_CODE\": NULL, \"ERROR_DESCRIPTION\": NULL)),\n\t\"x_param_out\": $fl,\n\t);\n    log(LL_INFO, \"FAKE_SCMHUB: generated %d correct, %d errors, %d total in fake scm-ret_doc_header response\", elements $fl - $ec, $ec, elements $fl);\n    log(LL_DEBUG_2, \"data: %N\", $data);\n    log(LL_DEBUG_2, \"ret: %N\", $ret);\n%else\n    $ret = sepl_exec_scmhub($ds, \"scm-ret_doc_header\", $data);\n%endif\n\n    my *hash $eh = sepl_scmhub_check_ret_hash($data, $ret, True, \"scm-ret_doc_header\");\n\n    # process errors already logged\n    foreach my string $c in (keys $eh) {\n        # set transaction hash keys to True in error hash\n        map $errh.$1 = True, $data_hash.($ilh.$c);\n    }\n\n    # create return hash and check for lookup failures\n    my hash $rv = hash();\n    foreach my hash $h in ($ret.x_param_out) {\n        my softstring $oid = $ilh.($h.QORUS_ROW_ID);\n        if ($h.STATUS != \"C\" || !$h.ORACLE_ORDER_TYPE) {\n            swarning(SCMHUB_ERROR_INFO, sprintf(\"SCM-HUB retrieve doc header failed for row id %y; affects %d transaction_id%s (result: %y)\", $oid, $data_hash.$oid.size(), $data_hash.$oid.size() == 1 ? \"\" : \"s\", $h));\n            log(LL_DETAIL_1, \"missing lookup for doc header for order_id %y affects the following transaction_ids: %y\", $oid, $data_hash.$oid);\n\t    \n            # set transaction hash keys to True in error hash\n            map $errh.$1 = True, $data_hash.$oid;\n        } else {\n            $rv.$oid = $h.\"ORACLE_ORDER_TYPE\";\n        }\n    }\n\n    return $rv;\n}\n\n#! takes a hash of order_id -> list(transaction_id) and returns a hash of order_id -> dealer_code and processes the error hash appropriately\nhash sub sepl_scmhub_ret_dealer_of_doc(object $ds, string $org_name, string $op_party, hash $data_hash, reference $errh, string $trans_type = \"OM_SHIP_CONFIRM\") {\n    log(LL_DETAIL_1, \"sepl_scmhub_ret_dealer_of_doc() about to look up %d order IDs\", $data_hash.size());\n\n    # scmhub call data list\n    my list $data = ();\n    # index lookup hash from qorus_row_id -> order_id\n    my hash $ilh;\n    {\n        my HashIterator $hi($data_hash);\n        my int $c = 0;\n        while ($hi.next()) {\n            # insert qorus_row_id -> order_id lookup entry\n            $ilh.$c = $hi.getKey();\n            $data += (\n                \"LEGAL_ENTITY\": $org_name,\n                \"OPERATING_PARTY\": $op_party,\n                \"TRANSACTION_CODE\": $trans_type,\n                \"DOC_HEADER_REFERENCE\": $hi.getKey(),\n                \"QORUS_ROW_ID\": $c++,\n\t    );\n        }\n    }\n\n    my hash $ret;\n\n%ifdef QoreDebug\n    # fake response list\n    my list $fl = ();\n    # error count\n    my int $ec = 0;\n    my bool $do_errs = !parse_boolean(getInstanceData(\"no-scmhub-errors\"));\n    foreach my softstring $oid in (keys $data_hash) {\n        my hash $h = (\n            \"QORUS_ROW_ID\": $fl.size(),\n            \"SYSTEM_REFERENCE\": $oid,\n            );\n\t# 10% chance of error on every record\n\tif ($do_errs && !(rand() % 10)) {\n            $h += (\n                \"DEALER_CODE\": NULL,\n                \"STATUS\": \"E\",\n                \"ERROR_MSG\": NULL,\n                );\n\t    ++$ec;\n        }\n\telse {\n            $h += (\n\t      \"DEALER_CODE\": $oid,\n\t      \"STATUS\": \"C\",\n\t      \"ERROR_MSG\": NULL,\n\t      );\n\t}\n        $fl += $h;\n    }\n\n    $ret = (\n\t\"x_status\": list((\"STATUS_CODE\": 0, \"ERROR_CODE\": NULL, \"ERROR_DESCRIPTION\": NULL)),\n\t\"x_param_out\": $fl,\n\t);\n    log(LL_INFO, \"FAKE_SCMHUB: generated %d correct, %d errors, %d total in fake scm-ret_dealer_of_doc response\", elements $fl - $ec, $ec, elements $fl);\n    log(LL_DEBUG_2, \"data: %N\", $data);\n    log(LL_DEBUG_2, \"ret: %N\", $ret);\n%else\n    $ret = sepl_exec_scmhub($ds, \"scm-ret_dealer_of_doc\", $data);\n%endif\n\n    my *hash $eh = sepl_scmhub_check_ret_hash($data, $ret, True, \"scm-ret_dealer_of_doc\");\n\n    # process errors already logged\n    foreach my string $c in (keys $eh) {\n        # set transaction hash keys to True in error hash\n        map $errh.$1 = True, $data_hash.($ilh.$c);\n    }\n\n    # create return hash and check for lookup failures\n    my hash $rv = hash();\n    foreach my hash $h in ($ret.x_param_out) {\n        my softstring $oid = $ilh.($h.QORUS_ROW_ID);\n\n        # special rule for NULL return value confirmed by Rudi Windisch 2013-01-17\n        if ($h.DEALER_CODE === NULL)\n            $h.DEALER_CODE = \"NULL\";\n\n        if ($h.STATUS != \"C\" || !$h.DEALER_CODE) {\n            swarning(SCMHUB_ERROR_INFO, sprintf(\"SCM-HUB retrieve dealer code failed for row id %y; affects %d transaction_id%s (result: %y)\", $oid, $data_hash.$oid.size(), $data_hash.$oid.size() == 1 ? \"\" : \"s\", $h));\n            log(LL_DETAIL_1, \"missing lookup for dealer code for order_id %y affects the following transaction_ids: %y\", $oid, $data_hash.$oid);\n\t    \n            # set transaction hash keys to True in error hash\n            map $errh.$1 = True, $data_hash.$oid;\n        } else {\n            $rv.$oid = $h.DEALER_CODE;\n        }\n    }\n\n    return $rv;\n}\n\n#! takes a hash of transaction_id -> (\"oid\": order_id, \"line\": line_number) and returns a hash: <order_id> \".\" <line_number> -> order_type and processes the error hash appropriately\nhash sub sepl_scmhub_ret_doc_line(object $ds, string $org_name, string $op_party, hash $data_hash, reference $errh, string $sending_sys = \"E-Biz\", string $party_type = \"SCM PARTNER\", string $trans_type = \"OM_SHIP_REQ\", string $supp_sys_type = \"DELIVERY DETAIL\" ) {\n\n    # argument $supp_sys_type, default value, was changed from OM_SHIP_REQ (20130121, petr vanek) on request by Guenther Wiesser\n\n    log(LL_DETAIL_1, \"sepl_scmhub_ret_doc_line() about to look up %d order IDs\", elements $data_hash);\n\n    # scmhub call data list\n    my list $data = ();\n    # index lookup hash from qorus_row_id -> order_id\n    my hash $ilh;\n    {\n        my HashIterator $hi($data_hash);\n        my int $c = 0;       \n        while ($hi.next()) {\n            my string $id = $hi.getKey();\n            my hash $h = $hi.getValue();\n            # insert qorus_row_id -> order_id lookup entry\n            $ilh.$c = (\n                \"oid\": $h.oid,\n                \"line\": $h.line,\n                \"id\": $id,\n                );\n            $data += (\n                \"LEGAL_ENTITY\": $org_name,\n                \"SENDING_SYSTEM\": $sending_sys,\n                \"OPERATING_PARTY\": $op_party,\n                \"PARTY_TYPE\": $party_type,\n                \"TRANSACTION_TYPE\": $trans_type,\n                \"HEADER_SYSTEM_REFERENCE\": $h.oid,\n                \"SYSTEM_REFERENCE\": sprintf(\"%06d\", $h.line),\n                \"SUPPL_SYSTEM_TYPE\": $supp_sys_type,\n                \"QORUS_ROW_ID\": $c++,\n\t    );\n        }\n    }\n\n    my string $f = \"scm-ret_doc_line\";\n    my hash $ret;\n\n%ifdef QoreDebug\n    # fake response list\n    my list $fl = ();\n    # error count\n    my int $ec = 0;\n    my bool $do_errs = !parse_boolean(getInstanceData(\"no-scmhub-errors\"));\n    foreach my softstring $line in (keys $data_hash) {\n        my hash $h = (\n            \"QORUS_ROW_ID\": $fl.size(),\n            \"SYSTEM_REFERENCE\": $line,\n            );\n\t# 10% chance of error on every record\n\tif ($do_errs && !(rand() % 10)) {\n            $h += (\n                \"SUPP_BUSINESS_PROCESS\": NULL,\n                \"STATUS\": \"E\",\n                \"ERROR_MSG\": NULL,\n                );\n\t    ++$ec;\n        }\n\telse {\n            $h += (\n\t      \"SUPP_BUSINESS_PROCESS\": (\"WOM\", \"DOM\", \"INTERNAL\")[rand() % 3],\n\t      \"STATUS\": \"C\",\n\t      \"ERROR_MSG\": NULL,\n\t      );\n\t}\n        $fl += $h;\n    }\n\n    $ret = (\n\t\"x_status\": list((\"STATUS_CODE\": 0, \"ERROR_CODE\": NULL, \"ERROR_DESCRIPTION\": NULL)),\n\t\"x_param_out\": $fl,\n\t);\n\n    log(LL_INFO, \"FAKE_SCMHUB: generated %d correct, %d errors, %d total in fake %s response\", elements $fl - $ec, $ec, elements $fl, $f);\n    log(LL_DEBUG_2, \"data: %N\", $data);\n    log(LL_DEBUG_2, \"ret: %N\", $ret);\n%else\n    $ret = sepl_exec_scmhub($ds, $f, $data);\n%endif\n\n    my *hash $eh = sepl_scmhub_check_ret_hash($data, $ret, True, $f);\n\n    # process errors already logged\n    foreach my string $c in (keys $eh) {\n        # set transaction_id key in error hash to True\n        $errh.($ilh.$c.id) = True;\n    }\n\n    # create return hash and check for lookup failures\n    my hash $rv = hash();\n    foreach my hash $h in ($ret.x_param_out) {\n        my hash $rh = $ilh.($h.QORUS_ROW_ID);\n\n        # special rule for NULL return value confirmed by Rudi Windisch 2013-01-17\n        if ($h.SUPP_BUSINESS_PROCESS === NULL)\n            $h.SUPP_BUSINESS_PROCESS = \"NULL\";\n\n        if ($h.STATUS != \"C\") {\n            swarning(SCMHUB_ERROR_INFO, sprintf(\"SCM-HUB retrieve doc line failed for order_id %y, line_number %y, transaction_id %y (result: %y)\", $rh.oid, $rh.line, $rh.id, $h));\n\n            # set transaction hash keys to True in error hash\n            $errh.($rh.id) = True;\n        } else\n            $rv.($rh.oid + \".\" + $rh.line) = $h.SUPP_BUSINESS_PROCESS;\n    }\n\n    return $rv;\n}\n\n#! takes a hash of transaction_ids -> (\"oid\": order_id, \"item\": item_number, \"qty\": quantity) and returns a hash: transaction_id -> (\"status\": STATUS_REASON, \"qty\": OVERQUANTITY, \"order_id\": order_id, \"item_number\": item_number) and processes the error hash appropriately\nhash sub sepl_scmhub_ret_doc_ln_qty_info(AbstractDatasource $ds, string $org_name, string $trans_type, string $disp_type, hash $data_hash, reference $errh) {\n    log(LL_DETAIL_1, \"sepl_scmhub_ret_doc_ln_qty_info() about to look up %d items\", $data_hash.size());\n\n    # scmhub call data list\n    my list $data = ();\n    {\n        my HashIterator $hi($data_hash);\n        while ($hi.next()) {\n            my softint $tid = $hi.getKey();\n            my hash $h = $hi.getValue();\n            $data += (\n                \"LEGAL_ENTITY\": $org_name,\n                \"TRANSACTION_TYPE\": $trans_type,\n                \"DOC_HEADER_REFERENCE\": $h.oid,\n                \"ITEM_NUMBER\": $h.item,\n                \"DISPATCHED_QTY\": $h.qty,\n                \"DISPATCHED_QTY_TYPE\": $disp_type,\n                \"QORUS_ROW_ID\": $tid,\n\t    );\n        }\n    }\n\n    my string $f = \"scm-ret_doc_ln_qty_info\";\n    my hash $ret;\n\n%ifdef QoreDebug\n    # fake response list\n    my list $fl = ();\n    # error count\n    my int $ec = 0;\n    my bool $do_errs = !parse_boolean(getInstanceData(\"no-scmhub-errors1\"));\n    foreach my softstring $tid in ($data_hash.keyIterator()) {\n        my hash $h = (\n            \"QORUS_ROW_ID\": $tid,\n            );\n\t# 5% chance of a generic error\n\tif ($do_errs && !(rand() % 200000000000)) {\n            $h += (\n                \"OVERQUANTITY\": 0,\n                \"STATUS_REASON\": NULL,\n                \"STATUS\": \"E\",\n                \"ERROR_MSG\": NULL,\n                );\n\t    ++$ec;\n        }\n        # 20% chance of a redirection\n\telse if ($do_errs && !(rand() % 1)) {\n            #my string $status = (\"NOHEADER\", \"NOLINE\", \"MULTIPLE\", \"OVERQUANTITY\")[rand() % 4];\n            my string $status = \"OVERQUANTITY\";\n            $h += (\n                \"STATUS_REASON\": $status,\n                \"STATUS\": \"C\",\n                \"ERROR_MSG\": NULL,\n                );\n            # set the quantity to some random number loosely based on the original quantity when status = OVERQUANTITY\n            if ($status == \"OVERQUANTITY\")\n                $h.OVERQUANTITY = (rand() % ($data_hash.$tid.qty));\n        }\n\telse {\n            $h += (\n                \"STATUS_REASON\": \"OK\",\n                \"STATUS\": \"C\",\n                \"ERROR_MSG\": NULL,\n\t      );\n\t}\n        $fl += $h;\n    }\n\n    $ret = (\n\t\"x_status\": list((\"STATUS_CODE\": 0, \"ERROR_CODE\": NULL, \"ERROR_DESCRIPTION\": NULL)),\n\t\"x_param_out\": $fl,\n\t);\n\n    log(LL_INFO, \"FAKE_SCMHUB: generated %d correct, %d errors, %d total in fake %s response\", elements $fl - $ec, $ec, elements $fl, $f);\n    log(LL_DEBUG_2, \"data: %N\", $data);\n    log(LL_DEBUG_2, \"ret: %N\", $ret);\n%else\n    $ret = sepl_exec_scmhub($ds, $f, $data);\n%endif\n\n    $errh += sepl_scmhub_check_ret_hash($data, $ret, True, $f);\n\n    # create return hash and check for lookup failures\n    my hash $rv = hash();\n    foreach my hash $h in ($ret.x_param_out) {\n        my softstring $tid = $h.QORUS_ROW_ID;\n        my hash $rh = $data_hash.$tid;\n        if ($h.STATUS != \"C\" || !$h.STATUS_REASON) {\n            swarning(SCMHUB_ERROR_INFO, sprintf(\"SCM-HUB retrieve doc line quantity info failed for order_id %y, item %y, transaction_id %y (result: %y)\", $rh.oid, $rh.item, $tid, $h));\n\n            # set transaction hash keys to True in error hash\n            $errh.$tid = True;\n        } else if ($h.STATUS_REASON == \"MULTIPLE\") {\n            swarning(SCMHUB_ERROR_INFO, sprintf(\"SCM-HUB retrieve doc line quantity info failed due to status %y for order_id %y, item %y, transaction_id %y (result: %y)\", $h.STATUS_REASON, $rh.oid, $rh.item, $tid, $h));\n\n            # set transaction hash keys to True in error hash\n            $errh.$tid = True;\n        } else if ($h.STATUS_REASON == \"NODOCUMENT\")\n            throw SCMHUB_ERROR, sprintf(\"SCM-HUB retrieve doc line quantity info failed due to status %y for order_id %y, item %y, transaction_id %y (result: %y)\", $h.STATUS_REASON, $rh.oid, $rh.item, $tid, $h);\n        else {\n            $rv.$tid = (\n                \"order_id\": $rh.oid,\n                \"item_number\": $rh.item,\n                \"status\": $h.STATUS_REASON,\n                \"qty\": $h.OVERQUANTITY,\n            );\n        }\n    }\n\n    return $rv;\n}\n\n#! takes a list of hashes of rma_receipt data and returns a hash of serial_number -> status_reason, overquantity and processes the error hash appropriately\nhash sub sepl_scmhub_ret_ser_qty_rma_src(object $ds, string $org_name, list $serial_numbers, string $dqt, reference $errh) {\n    log(LL_DETAIL_1, \"sepl_scmhub_ret_ser_qty_rma_src() about to look up %d order IDs\", elements $serial_numbers);\n\n    # scmhub call data list\n    my list $data = ();\n\n    # index lookup hash from qorus_row_id -> serial_number\n    my hash $ilh;\n    {\n        my int $c = 0;\n        foreach my hash $ln in ($serial_numbers){\n            # insert qorus_row_id -> order_id lookup entry\n            $ilh.$c = $ln.serial_number;\n            $data += (\n                \"LEGAL_ENTITY\": $org_name,\n                \"TRANSACTION_TYPE\": \"RMA_SOURCE\",\n                \"DOC_SRC_HEADER_REF\": $ln.order_id,\n                \"EXEC_LINE_NUM\": $ln.line_number,\n                \"ITEM_NUMBER\": $ln.item_number,\n                \"DISPATCHED_QTY\": $ln.dispatched_quantity,\n                \"DISPATCHED_QTY_TYPE\": $dqt,\n                \"SERIAL_NUMBER\": $ln.serial_number,\n                \"EFFECTIVE_DATE\": $ln.status_date,\n                \"SRC_SYS_REF\": $ln.order_id,\n                \"QORUS_ROW_ID\": $c++,\n\t    );\n        }\n    }\n\n    my hash $ret;\n\n%ifdef QoreDebug\n    # fake response list\n    my list $fl = ();\n    # error count\n    my int $ec = 0;\n    my bool $do_errs = !parse_boolean(getInstanceData(\"no-scmhub-errors\"));\n    foreach my hash $ln in ($data){\n        delete $ln;\n\t# 10% chance of error on every record\n\tif ($do_errs && !(rand() % 10)) {\n\t    ++$ec;\n\t  $fl += (\n\t      \"STATUS_REASON\": \"DUPLICATE\",\n          \"OVERQUANTITY\": NULL,\n\t      \"QORUS_ROW_ID\": $fl.size(),\n\t      \"STATUS\": \"E\",\n\t      \"ERROR_MSG\": NULL,\n\t      );\n\t}\n\telse {\n\t  $fl += (\n\t      \"STATUS_REASON\": \"OK\",\n          \"OVERQUANTITY\": NULL,\n\t      \"QORUS_ROW_ID\": $fl.size(),\n\t      \"STATUS\": \"C\",\n\t      \"ERROR_MSG\": NULL,\n\t      );\n\t}\n    }\n\n    $ret = (\n\t\"x_status\": list((\"STATUS_CODE\": 0, \"ERROR_CODE\": NULL, \"ERROR_DESCRIPTION\": NULL)),\n\t\"x_param_out\": $fl,\n\t);\n    log(LL_INFO, \"FAKE_SCMHUB: generated %d correct, %d errors, %d total in fake scm-ret_ser_qty_rma_lns response\", elements $fl - $ec, $ec, elements $fl);\n    log(LL_DEBUG_2, \"data: %N\", $data);\n    log(LL_DEBUG_2, \"ret: %N\", $ret);\n%else\n    $ret = sepl_exec_scmhub($ds, \"scm-ret_ser_qty_rma_lns\", $data);\n%endif \n    \n    $errh += sepl_scmhub_check_ret_hash($data, $ret, True, \"scm-ret_ser_qty_rma_lns\");\n\n    log(LL_DEBUG_2, \"errh_debug: %N\", $errh);\n\n    # create return hash and check for lookup failures\n    my hash $rv = hash();\n    foreach my hash $h in ($ret.x_param_out) {        \n\n        my softstring $tid = $h.QORUS_ROW_ID;\n        log(LL_DEBUG_2, \"tid: %N\", $tid);\n\n        my softstring $oid = $ilh.($h.QORUS_ROW_ID);\n        log(LL_DEBUG_2, \"oid: %N\", $oid);\n\n        if ($h.STATUS != \"C\" || $h.STATUS_REASON != \"OK\") {\n            swarning(SCMHUB_ERROR_INFO, sprintf(\"SCM-HUB serial number quantity check failed for for serial_number %s; (result: %y)\", $oid, $h));\n            $rv.$oid.\"status_reason\" = $h.\"STATUS_REASON\";\n\n            # set transaction hash keys to True in error hash \n            $errh.$tid = True;\n\n        } else {\n            $rv.$oid.\"status_reason\" = $h.\"STATUS_REASON\";\n        }\n    }\n\n    return $rv;\n\n}\n\n#! takes a list of hashes of rma_receipt data and returns a hash of serial_number -> status_reason, overquantity and processes the error hash appropriately\nhash sub sepl_scmhub_ret_ser_qty_rma(object $ds, string $org_name, list $serial_numbers, string $dqt, reference $errh) {\n    log(LL_DETAIL_1, \"sepl_scmhub_ret_ser_qty_rma() about to look up %d order IDs\", elements $serial_numbers);\n\n    # scmhub call data list\n    my list $data = ();\n\n    # index lookup hash from qorus_row_id -> serial_number\n    my hash $ilh;\n    {\n        my int $c = 0;\n        foreach my hash $ln in ($serial_numbers){\n            # insert qorus_row_id -> order_id lookup entry\n            $ilh.$c = $ln.serial_number;\n            $data += (\n                \"LEGAL_ENTITY\": $org_name,\n                \"TRANSACTION_TYPE\": \"RMA\",\n                \"DOC_HEADER_REFERENCE\": $ln.order_id,\n                \"DOC_LINE_REFERENCE\": $ln.line_number,\n                \"ITEM_NUMBER\": $ln.item_number,\n                \"DISPATCHED_QTY\": $ln.dispatched_quantity,\n                \"DISPATCHED_QTY_TYPE\": $dqt,\n                \"SERIAL_NUMBER\": $ln.serial_number,\n                \"EFFECTIVE_DATE\": $ln.status_date,\n                \"SRC_SYS_REF\": $ln.order_id,\n                \"QORUS_ROW_ID\": $c++,\n\t    );\n        }\n    }\n\n    my hash $ret;\n\n%ifdef QoreDebug\n    # fake response list\n    my list $fl = ();\n    # error count\n    my int $ec = 0;\n    my bool $do_errs = !parse_boolean(getInstanceData(\"no-scmhub-errors\"));\n    foreach my hash $ln in ($data){\n        delete $ln;\n\t# 10% chance of error on every record\n\tif ($do_errs && !(rand() % 10)) {\n\t    ++$ec;\n\t  $fl += (\n\t      \"STATUS_REASON\": \"DUPLICATE\",\n          \"OVERQUANTITY\": NULL,\n\t      \"QORUS_ROW_ID\": $fl.size(),\n\t      \"STATUS\": \"E\",\n\t      \"ERROR_MSG\": NULL,\n\t      );\n\t}\n\telse {\n\t  $fl += (\n\t      \"STATUS_REASON\": \"OK\",\n          \"OVERQUANTITY\": NULL,\n\t      \"QORUS_ROW_ID\": $fl.size(),\n\t      \"STATUS\": \"C\",\n\t      \"ERROR_MSG\": NULL,\n\t      );\n\t}\n    }\n\n    $ret = (\n\t\"x_status\": list((\"STATUS_CODE\": 0, \"ERROR_CODE\": NULL, \"ERROR_DESCRIPTION\": NULL)),\n\t\"x_param_out\": $fl,\n\t);\n    log(LL_INFO, \"FAKE_SCMHUB: generated %d correct, %d errors, %d total in fake scm-ret_ser_qty_rma_ln response\", elements $fl - $ec, $ec, elements $fl);\n    log(LL_DEBUG_2, \"data: %N\", $data);\n    log(LL_DEBUG_2, \"ret: %N\", $ret);\n%else\n    $ret = sepl_exec_scmhub($ds, \"scm-ret_ser_qty_rma_ln\", $data);\n%endif \n    \n    $errh += sepl_scmhub_check_ret_hash($data, $ret, True, \"scm-ret_ser_qty_rma_ln\");\n\n    log(LL_DEBUG_2, \"ilh: %N\", $ilh);\n\n    # create return hash and check for lookup failures\n    my hash $rv = hash();\n    foreach my hash $h in ($ret.x_param_out) {\n\n        my softstring $tid = $h.QORUS_ROW_ID;\n        log(LL_DEBUG_2, \"tid: %N\", $tid);\n\n        my softstring $oid = $ilh.($h.QORUS_ROW_ID);\n        log(LL_DEBUG_2, \"oid: %N\", $oid);\n\n        #log(LL_DEBUG_2, \"oid: %y\", $oid);\n        if ($h.STATUS != \"C\" || $h.STATUS_REASON != \"OK\") {\n            swarning(SCMHUB_ERROR_INFO, sprintf(\"SCM-HUB serial number quantity check failed for for serial_number %s; (result: %y)\", $oid, $h));\n            $rv.$oid.\"status_reason\" = $h.\"STATUS_REASON\";\n\n            # set transaction hash keys to True in error hash \n            $errh.$tid = True;\n\n        } else {\n            $rv.$oid.\"status_reason\" = $h.\"STATUS_REASON\";\n        }\n    }\n\n    return $rv;\n\n}\n\nconst SeplCommonColumns = (\"org_name\", \"message_type\");\n\n#! groups transactions when processing streaming data\nclass SeplStreamingDataHelper {\n    public {\n    }\n\n    private {\n        # table name\n        string $.table;\n\n        # columns for select\n        list $.scols;\n\n        # field list\n        list $.fl;\n\n        # key column name\n        string $.key;\n\n        # hash for grouping\n        hash $.h;\n\n        # hash of temp table data\n        hash $.data;\n\n        # number of rows processed\n        int $.size = 0;\n    }\n\n    constructor(string $table, softlist $cols, string $key) {\n        $.table = $table;\n\n        my hash $props = getInstanceData();\n        \n        $.scols = $props.select.$table;\n\n        # make a hash from select columns\n        my hash $ch;\n        map $ch.$1 = True, $.scols;\n        # add group columns to select columns if not already present\n        map $.scols += $1, $cols, !$ch.$1;\n\n        $.fl = $cols;\n        $.key = $key;\n\n        # make sure the keys exist in h\n        map $.h.$1 = hash(), $cols;\n\n        if (!$props.no_scmhub_write)\n            $.data.$table = ();\n    }\n\n    destructor() {\n        log(LL_DEBUG_1, \"table: %y rows: %d groups: %y\", $.table, $.size, $.h);\n        updateTempData((\"SGH\": (\"h\": $.h, \"size\": $.size)));\n\n        if ($.data && !getTempData(\"data\").$.table)\n            updateTempData((\"data\": $.data));\n    }\n\n    check(hash $row) {\n        # process groupings\n\tforeach my string $k in ($.fl) {\n            # skip empty values\n            if ($row.$k == \"\")\n                continue;\n\n\t    $.h.$k.($row.$k) += list($row.$.key);\n\t}\n        # add row to temp data if collecting temp data\n        if ($.data)\n            $.data.$.table += $row.($.scols);\n        # increment size\n        ++$.size;\n    }\n\n    group() {\n        my *hash $h = getTempData(\"SGH\");\n        if ($h) {\n            $.h = $h.h;\n            $.size = $h.size;\n            my *list $l = getTempData(\"data\").$.table;\n            if ($l)\n                $.data.$.table = $l;\n            log(LL_INFO, \"using stored group data for %s (size: %d)\", $.table, $.size);\n            return;\n        }\n\n        log(LL_INFO, \"streaming DB data from %s for grouping\", $.table);\n\n        # get our wfiid\n        my softint $wfiid = getWorkflowInstanceData(\"workflow_instanceid\");\n\n        my OracleSQLStatement $stmt(getInstanceData().local_staging);\n        my string $cstr = foldl $1 + \",\" + $2, $.scols;\n        my string $sql = sprintf(\"select %s from %s where i_sepl_created_id = %v\", $cstr, $.table);\n        log(LL_DETAIL_2, \"select: %s, args: %y\", $sql, $wfiid);\n        $stmt.prepare($sql);\n\n        on_exit $stmt.rollback();\n\n        # execute query\n        $stmt.exec($wfiid);\n\n        # process input data one row at a time\n        map $.check($1), $stmt;\n\n        log(LL_INFO, \"streamed %d row%s from %s for grouping\", $.size, $.size == 1 ? \"\" : \"s\", $.table);\n    }\n\n    addRow(string $t, hash $row) {\n        if (!$.data.$t)\n            $.data.$t = ();\n        $.data.$t += $row;\n    }\n\n    hash memberGate(string $m) {\n        if (!exists $.h.$m)\n            throw \"GROUP-ERROR\", sprintf(\"column %y is not grouped; known column groups: %y\", $m, $.fl);\n\n        return $.h.$m;\n    }\n\n    int size() {\n        return $.size;\n    }\n\n    bool empty() {\n        return !$.size;\n    }\n}\n\n#! groups transactions according to column values\nhash sub sepl_scmhub_group(list $data, softlist $cols, string $key) {\n    my hash $rv = hash();\n\n    foreach my hash $row in ($data) {\n\tforeach my string $k in ($cols) {\n            # skip empty values\n            if ($row.$k == \"\")\n                continue;\n\n\t    if (!exists $rv.$k.($row.$k))\n\t\t$rv.$k.($row.$k) = ();\n\t    $rv.$k.($row.$k) += $row.$key;\n\t}\n    }\n\n    #log(LL_DEBUG_2, \"sepl_scmhub_group() data=%y\", $data);\n    #log(LL_DEBUG_2, \"sepl_scmhub_group() cols=%y\", $cols);\n    #log(LL_DEBUG_2, \"sepl_scmhub_group() rv=%y\", $rv);\n    return $rv;\n}\n\n%ifdef QorusWorkflow\nstring sub mapls_oracle_table_validation(string $t) {\n    my OracleDatasourcePool $lsds(getInstanceData(\"local_staging\"));\n\n    my softint $wfiid = getWorkflowInstanceData(\"workflow_instanceid\");\n%ifdef QoreDebug\n    my string $rv = $lsds.selectRow(\"select case when exists (select 1 from %s where i_sepl_created_id = %v) then 'COMPLETE' else 'RETRY' end as result %s\", $t, $wfiid, $lsds.getDriverName() == \"oracle\" ? \"from dual\" : \"\").result;    \n%else\n    my string $rv = $lsds.selectRow(\"select case when exists (select 1 from %s where i_sepl_created_id = %v) then 'COMPLETE' else 'RETRY' end as result from dual\", $t, $wfiid).result;\n%endif\n    log(LL_INFO, \"checking table %s for isepl wfiid %d results in: %s\", $t, $wfiid, $rv);\n    return $rv;       \n}\n\nsub generic_scmhub_update_table(object $ds, string $table, int $wfiid, string $key, softlist $l, bool $isepl) {\n    my string $col = $isepl ? \"i_sepl_created_id\" : \"m_sepl_created_id\";\n    log(LL_INFO, \"updating %d key%s in %s with %s = %d using key column %s\", elements $l, elements $l == 1 ? \"\" : \"s\", $table, $col, -$wfiid, $key);\n\n    #log(LL_DEBUG_2, \"sl: %y\", $sl);\n    # break it up into chunks of 500 to avoid \"ORA-00932: inconsistent datatypes: expected - got CLOB\"\n    while (!$l.empty()) {\n        my list $tl = extract $l, 0, 500;\n        my softstring $sl = foldl $1 + \",\" + $2, $tl;\n        my int $rows = $ds.exec(\"update %s set %s = %v where %s in (SELECT regexp_substr (%v, '[^,]+', 1, lvl) as val FROM (select LEVEL lvl from dual CONNECT BY LEVEL <= ((length(%v) - length(REPLACE(%v, ',', '')))) + 1))\", $table, $col, -$wfiid, $key, $sl, $sl, $sl);\n        log(LL_DETAIL_1, \"updated %d row%s in %s\", $rows, $rows == 1 ? \"\" : \"s\", $table);\n    }\n}\n\nbool sub generic_scmhub_do_normal_split(hash $props, *hash $dd, int $wfiid, bool $isepl) {\n    if (exists $dd.errh)\n        $dd.errors = keys $dd.errh;\n    \n    if (!elements $dd.errors)\n\treturn True;\n\n    # get gs datasource\n    my OracleDatasourcePool $gsds($props.global_staging);\n   \n    # make sure the transaction is committed before creating the child wf order\n    on_success $gsds.commit();\n    on_error $gsds.rollback();\n\n    # update rows in global staging with the negative value of this wfiid\n    foreach my string $t in ($props.tablelist) {\n        # get the name of the key column to use\n        my string $key = sepl_get_key($t, $props);\n        \n        generic_scmhub_update_table($gsds, $t, $wfiid, $key, $dd.errors, $isepl);\n    }\n\n    return False;\n}\n\nbool sub generic_scmhub_do_error_tables_split(hash $props, *hash $dd, int $wfiid, bool $isepl) {\n    # get gs datasource\n    my OracleDatasourcePool $gsds($props.global_staging);\n\n    # make sure the transaction is committed before creating the child wf order\n    on_success $gsds.commit();\n    on_error $gsds.rollback();\n\n    my bool $skip = True;\n\n    foreach my string $t in (keys $dd.error_tables) {\n        foreach my string $col in (keys $dd.error_tables.$t) {\n            if (!elements $dd.error_tables.$t.$col)\n                continue;\n            $skip = False;\n\n            generic_scmhub_update_table($gsds, $t, $wfiid, $col, keys $dd.error_tables.$t.$col, $isepl);\n        }\n    }\n\n    return $skip;\n}\n\nsub generic_scmhub_split_lib(bool $isepl) {\n    my *hash $dd = getDynamicData();\n    my softint $wfiid = getWorkflowInstanceData(\"workflow_instanceid\");\n    my hash $props = getInstanceData();\n\n    if (exists $dd.error_tables ? generic_scmhub_do_error_tables_split($props, $dd, $wfiid, $isepl) : generic_scmhub_do_normal_split($props, $dd, $wfiid, $isepl)) {\n\tlog(LL_INFO, \"no errors to split; skipping (loosely-coupled) subworkflow bind step\");\n        return;\n    }\n\n    generic_scmhub_split_wf($wfiid, $props, $dd);\n}\n\nsub generic_scmhub_split_wf(int $wfiid, hash $props, *hash $dd, string $key = \"scmGoToError\") {\n    my hash $sd = getStaticData();\n\n    # set error key in new dynamic data\n    my hash $ndd.$key = True;\n\n    if (exists $props.omit_static_data)\n        $sd -= $props.omit_static_data;\n\n    if (exists $props.copy_dynamic_to_static)\n        $sd += $dd.($props.copy_dynamic_to_static);\n\n    if (exists $props.copy_dynamic)\n        $ndd += $dd.($props.copy_dynamic);\n\n    my string $name = getWorkflowInstanceData(\"name\");\n    $sd += (\"error_wfiid\": -$wfiid);\n\n    my softint $child_wfiid = createOrder($name, NOTHING, (\"staticdata\": $sd, \n\t\t\t\t\t\t\t   \"dynamicdata\": $ndd,\n\t\t\t\t\t\t\t   \"orderkeys\": getOrderKeys() + (\"parent\": $wfiid),\n\t\t\t\t\t  ));\n    log(LL_INFO, \"created child workflow order %d\", $child_wfiid);\n}\n\nhash sub sepl_process_update_skip_props(hash $props) {\n    my *hash $dd = getDynamicData();\n\n    if (exists $dd.skiph)\n        $dd.skip = keys $dd.skiph;\n\n    # if there are rows to skip, then set up properties for skipping those rows\n    if (exists $dd.skip) {\n\tforeach my string $t in ($props.tablelist) {\n            # get the name of the key column to use\n            my string $key = sepl_get_key($t, $props);\n            \n\t    $props.skip.$t = (\n\t\t\"column\": $key,\n\t\t\"values\": $dd.skip,\n\t\t);\n\t}\n    }\n\n    # process update hash and set up properties for updating in isepl_update_gsls_props()\n    if (exists $dd.update) {\n\t# if there are updates to make to all rows in all tables when copying, add them to \"crec\" in props here\n\tif (exists $dd.update.\"*\")\n\t    $props.crec.\"*\" += remove $dd.update.\"*\";\n\n\t# if there are updates to make to all rows in a table when copying, add them to \"crec\" in props here\n\tforeach my string $t in (keys $dd.update) {\n%ifdef QoreDebug\n            if (!inlist($t, $props.tablelist))\n\t        throw \"UPDATE-TABLE-ERROR\", sprintf(\"update data given for unknown table %y (valid: %y); data: %y\", $t, $props.tablelist, $dd.update.$t);\n%endif\n\n            if (exists $dd.update.$t.\"*\")\n\t        $props.crec.$t += remove $dd.update.$t.\"*\";\n\n            my int $size = $dd.update.$t.size();\n            # if there's no more data to process for this table, then continue\n            if (!$size)\n                continue;\n\n            # now there should be only 1 key; the table name\n            if ($size != 1)\n                throw \"UPDATE-TABLE-ERROR\", sprintf(\"table %y update definition should be a hash with a single key name giving the column to update; got keys: %y instead\", $t, keys $dd.update.$t);\n\n            my string $col = $dd.update.$t.firstKey();\n\t    $props.update.$t = (\n\t\t\"column\": $col,\n\t\t\"update\": $dd.update.$t.$col,\n\t\t);\n\t}\n    }\n\n%ifdef QoreDebug\n    log(LL_DEBUG_2, \"\\nskip: %N\\ncrec: %N\\nupdate: %N\", $props.skip, $props.crec, $props.update);\n%endif\n\n    return $props;\n}\n\n#! function for re-retrieving workflow data in later steps when recovering\nsub isepl_setup_data(string $sql, string $key, string $dsn) {\n    if (exists getTempData(\"source_data\"))\n        return;\n\n    my OracleDatasourcePool $gsds($dsn);       \n\n    # get current wfiid for query below\n    my softint $wfiid = getWorkflowInstanceData(\"workflow_instanceid\");\n\n    my *list $gs_result = $gsds.selectRows($sql, $wfiid);\n\n    log(LL_INFO, \"rows retrieved from global staging: %d\", elements $gs_result);\n\n    # filter data to be skipped or already in error\n    my *hash $dd = getDynamicData();\n    if ($dd) {\n        for (my int $i = 0; $i < elements $gs_result;) {\n            my softstring $tid = $gs_result[$i].$key;\n            \n            if ($dd.errh.$key.$tid) {\n                log(LL_DETAIL_1, \"ignoring %s %y as it is marked with an error\", $key, $tid);\n                # remove row from result list\n                splice $gs_result, $i, 1;\n                continue;\n            }\n            if ($dd.skiph.$tid) {\n                log(LL_DETAIL_1, \"ignoring %s %y as it is marked to be skipped\", $key, $tid);\n                # remove row from result list\n                splice $gs_result, $i, 1;\n                continue;\n            }\n            ++$i;\n        }\n    }\n\n    updateTempData((# save source data\n                    \"source_data\": $gs_result,\n                    # get isepl admin column data\n                    \"isepl_data\": sepl_get_data_isepl(),\n                   ));\n}\n\nstring sub sepl_scmhub_split_val(string $key = \"parent\") {\n    # see if the child workflow order already exists\n    my string $name = getWorkflowInstanceData(\"name\");\n    my string $ver = getWorkflowInstanceData(\"version\");\n    my softstring $wfiid = getWorkflowInstanceData(\"workflow_instanceid\");\n\n    my bool $b = sepl_check_order_key($name, $ver, $key, $wfiid);\n\n    if ($b) {\n        log(LL_INFO, \"check indicates that child order %s v%s with parent wfiid %d already exists, returning COMPLETE\", $name, $ver, $wfiid);\n        return OMQ::StatComplete;\n    }\n\n    log(LL_INFO, \"check indicates that no child order %s v%s with parent wfiid %d exists, returning RETRY\", $name, $ver, $wfiid);\n    return OMQ::StatRetry;\n}\n%endif\n","created": "2015-01-20 12:56:22.734680 +01:00","modified": "2015-01-20 12:56:22.734680 +01:00","createdby": "omq","modifiedby": "omq","tags": {},"source": "/Users/pchalupny/workspace/builds/qorus/user/libraries/sepl-inbound-lib-v2.0.qfd","offset": "7","host": "panda.local","user": "<shell-unknown>"},{"name": "mapls-lib","version": "1.0","id": 56,"function_type": "GENERIC","description": "library functions for \"MAPLS-\" workflows","author": "David Nichols (Qore Technologies, sro)","body": "%require-types\n\n#! autojoin constant value to join gsi_brep_trans with gsi_snr from data in memory\n/** This value should be set to the \\c \"autojoin\" property (in workflow instance data)\n    to automatically join the map data in memory - the main table is \"gsi_brep_trans\",\n    and we only need the msisdn and serial_number columns from the gsi_snr table\n    the table relationships are taken from the default keys or from the \"update_keys\" property\n*/\nconst AutoJoin_BrepTrans_Snr = (\n    \"master\": \"gsi_brep_trans\",\n    \"slave\": \"gsi_snr\",\n    \"columns\": (\"message_id\", \"msisdn\", \"serial_number\", \"serial_number_1\"),\n    );\n\n#! the magic number used to create a temporary workflow_instanceid to mark errored LS rows with scmhub write errors\nconst WRITE_ERROR = -90000000000000;\n\n#! the magic number used to create a temporary workflow_instanceid to mark errored LS rows with scmhub check errors\nconst CHECK_ERROR = -80000000000000;\n\n#! the magic number used to create a temporary workflow_instanceid to mark errored LS rows with serial count errors\nconst SERIAL_ERROR = -70000000000000;\n\nconst ScmhubErrorConf = (\n    \"write\": (\n        \"offset\": WRITE_ERROR,\n        \"key\": \"write\",\n        \"ekey\": \"scmWriteGoToError\",\n        \"pkey\": \"parent_write\",\n        ),\n    \"check\": (\n        \"offset\": CHECK_ERROR,\n        \"key\": \"check\",\n        \"ekey\": \"scmCheckGoToError\",\n        \"pkey\": \"parent_check\",\n        ),\n    \"serial_count\": (\n        \"offset\": SERIAL_ERROR,\n        \"key\": \"serial\",\n        \"ekey\": \"scmSerialGoToError\",\n        \"pkey\": \"parent_serial\",\n        ),\n    );\n\nstring sub mapls_get_error_key(*string $errtype) {\n    if ($errtype)\n        return ScmhubErrorConf.$errtype.ekey;\n    return \"scmGoToError\";\n}\n\nstring sub mapls_get_parent_key(*string $errtype) {\n    if ($errtype)\n        return ScmhubErrorConf.$errtype.pkey;\n    return \"parent\";\n}\n\nstring sub mapls_get_child_key(*string $errtype) {\n    if ($errtype)\n        return ScmhubErrorConf.$errtype.key;\n    return \"get\";\n}\n\n#! updates local staging tables after a batch split operation before reprocessing\nsub map_update_ls(hash $sd) {\n    my hash $props = getInstanceData();\n    my softint $wfiid = getWorkflowInstanceData(\"workflow_instanceid\");\n\n    log(LL_INFO, \"updating local staging tables after batch split with i_sepl_created_id = %d -> %d\", $sd.error_wfiid, $wfiid);\n\n    # get datasource\n    my OracleDatasourcePool $lsds($props.local_staging);\n\n    on_success $lsds.commit();\n    on_error $lsds.rollback();\n\n    # update rows in local staging with the msepl wfiid given\n    foreach my string $t in ($props.tablelist) {\n\tmy int $rows;\n\t$rows = $lsds.exec(\"update %s set m_sepl_created_id = %v, m_sepl_updated_id = %v, i_sepl_created_id = %v, i_sepl_updated_id = %v, m_sepl_status = 'I', i_sepl_status = 'I' where i_sepl_created_id = %v\", $t, $wfiid, $wfiid, $wfiid, $wfiid, $sd.error_wfiid);\n\tlog(LL_INFO, \"updated local staging: %s %d row%s with i_sepl_created_id = %d\", $t, $rows, $rows == 1 ? \"\" : \"s\", $wfiid);\n    } \n}\n\n# updates rows with errors in local staging\nsub mapls_update_errors(object $ds, string $table, int $wfiid, string $key, softlist $l, *string $errtype) {\n    my int $val = -$wfiid;\n    if ($errtype)\n        $val += ScmhubErrorConf.$errtype.offset;\n    log(LL_INFO, \"updating %d key%s in %s with i_sepl_created_id = %d using key column %s\", elements $l, elements $l == 1 ? \"\" : \"s\", $table, $val, $key);\n\n    # break it up into chunks of 500 to avoid \"ORA-00932: inconsistent datatypes: expected - got CLOB\"\n    while (!$l.empty()) {\n        my list $tl = extract $l, 0, 500;\n        my softstring $sl = foldl $1 + \",\" + $2, $tl;\n%ifdef QoreDebug\n        my string $sql = sprintf(\"update %s set m_sepl_created_id = %v, i_sepl_created_id = %v, m_sepl_status = 'E', i_sepl_status = 'E' where %s in (%s)\", $table, $key, $sl);\n        log(LL_DEBUG_2, \"SQL: %s, args: %y %s in l: %y\", $sql, $val, $key, $sl);\n        my int $rows = $ds.exec($sql, $val, $val);\n%else\n        my int $rows = $ds.exec(\"update %s set m_sepl_created_id = %v, i_sepl_created_id = %v, m_sepl_status = 'E', i_sepl_status = 'E' where %s in (SELECT regexp_substr (%v, '[^,]+', 1, lvl) as val FROM (select LEVEL lvl from dual CONNECT BY LEVEL <= ((length(%v) - length(REPLACE(%v, ',', '')))) + 1))\", $table, $val, $val, $key, $sl, $sl, $sl);\n%endif\n        log(LL_DETAIL_1, \"updated %d row%s in %s\", $rows, $rows == 1 ? \"\" : \"s\", $table);\n    }\n}\n\n#! creates a lookup hash from key values to row/list index numbers\nhash sub mapls_get_lookup(string $t, *softlist $l, string $key) {\n    #log(LL_DEBUG_2, \"mapls_get_lookup() t: %s key: %s l: %N\", $t, $key, $l);\n\n    # get any lookup hash data\n    my *hash $lh = getTempData(\"lh\");\n    if ($lh.$t.val())\n        return $lh.$t;\n\n    my hash $h = hash();\n    foreach my hash $rh in ($l) {\n        # index from primary key to list index\n        my softstring $kv = $rh.$key;\n        if (!exists $h.$kv)\n            $h.$kv = ();\n        $h.$kv += $#;\n    }\n\n    my hash $th.$t = $h;\n    updateTempData((\"lh\": $th));\n\n    #log(LL_DEBUG_2, \"mapls_get_lookup(table: %y, key: %y) lh: %y\", $t, $key, $h, $l);\n    #log(LL_DEBUG_2, \"mapls_get_lookup(table: %y, key: %y) data: %y\", $t, $key, $l);\n    return $h;\n}\n\n#! invalidates a lookup table after editing the target table\nsub mapls_invalidate_lookup(string $t) {\n    # get any lookup hash data\n    my *hash $lh = getTempData(\"lh\");\n    if (!$lh.$t)\n        return;\n    delete $lh.$t;\n    updateTempData((\"lh\": $lh));\n}\n\n#! retrieves data from a staging DB if necessary\nhash sub mapls_get_data(hash $props, string $dsn, *softlist $tablelist, *hash $w) {\n    #log(LL_DEBUG_2, \"mapls_get_data() w: %y\", $w);\n\n    if (!$tablelist)\n        $tablelist = $props.tablelist;\n\n    # if we already have the data, then return it\n    my *hash $data = getTempData(\"data\");\n    if ($data && $data.keys() == $tablelist) {\n        log(LL_DEBUG_2, \"mapls_get_data() cached: returning %y\", (map sprintf(\"%s: %d rows\", $1, $data.$1.size()), $data.keys()));\n\treturn $data;\n    }\n\n    # get our wfiid\n    my softint $wfiid = getWorkflowInstanceData(\"workflow_instanceid\");\n\n    # get datasource\n    my OracleDatasourcePool $ds($dsn);\n\n    # read in data\n    foreach my string $t in ($tablelist) {\n        # only read in data for missing tables\n        if ($data.$t)\n            continue;\n\n        my softlist $args = $wfiid;\n        my string $cols = $props.select.$t ? (foldl $1 + \",\" + $2, $props.select.$t) : \"*\";\n        my string $sql = sprintf(\"select %s from %s where i_sepl_created_id = %v\", $cols, $t);\n        my *hash $mh = $w.\"*\" + $w.$t;        \n        if ($mh.sql) {\n            $sql += \" and \" + $mh.sql;\n            $args += $mh.args;\n        }\n        log(LL_DEBUG_2, \"mapls_get_data() SQL: %s, args: %y\", $sql, $args);\n        $data.$t = $ds.vselectRows($sql, $args);\n    }\n\n    updateTempData((\"data\": $data));\n    log(LL_DEBUG_2, \"mapls_get_data() cached: returning %y\", (map sprintf(\"%s: %d rows\", $1, $data.$1.size()), $data.keys()));\n    return $data;\n}\n\n#! returns a list of source data suitable for scmhub processing\nlist sub mapls_get_scmhub_data(*softlist $tablelist) {\n    # see if this data is already stored in temp data\n    {\n        my *list $l = getTempData(\"scmhub_data\");\n        if ($l.val()) {\n            log(LL_DETAIL_1, \"returning %d row%s of stored data\", $l.size(), $l.size() == 1 ? \"\" : \"s\");\n            return $l;\n        }\n    }\n\n    # get properties and make sure the \"update_keys\" property is set\n    # (it's set automatically using the first key in the table description)\n    my hash $props = sepl_check_update_keys(getInstanceData());\n    my hash $th = mapls_get_data($props, $props.local_staging, $tablelist, $props.\"where\");\n\n    #log(LL_DEBUG_1, \"update keys: %y\", $props.update_keys);\n\n    # if any tables are empty, then remove them\n    map delete $th.$1, keys $th, $th.$1.empty();\n\n    # if there is only 1 table, then return it immediately\n    if ($th.size() == 1) {\n        my list $l = $th.firstValue();\n        log(LL_DETAIL_1, \"returning %d row%s in single table %y\", $l.size(), $l.size() == 1 ? \"\" : \"s\", $th.firstKey());\n        return $l;\n    }\n\n    # get autojoin data and execute it\n    my *hash $ajh = $props.autojoin;\n\n    # if there is no autojoin hash, return the first table\n    if (!$ajh) {\n        my list $l = $th.firstValue();\n        log(LL_DETAIL_1, \"returning %d row%s in master table %y (no auto-join performed)\", $l.size(), $l.size() == 1 ? \"\" : \"s\", $th.firstKey());\n        return $l;\n    }\n\n    # table names\n    my string $st = $ajh.slave;\n    my string $mt = $ajh.master;\n\n    #log(LL_DEBUG_2, \"th: %N\", $th);\n\n    # get any lookup hash data (hash of foreign keys in the dependent table to row numbers (list indices))\n    my hash $lh.$st = mapls_get_lookup($st, $th.$st, $props.update_keys.$st);\n\n    #log(LL_DEBUG_2, \"lh: %N\", $lh);\n\n    log(LL_DETAIL_1, \"indexed %d foreign key%s in %y for autojoin with %y\", $lh.$st.size(), $lh.$st.size() == 1 ? \"\" : \"s\", $st, $mt);\n\n    # loop through master table and make final list\n    my list $l = ();\n\n    {\n        my string $key = $props.update_keys.$mt;\n        foreach my hash $h in ($th.$mt) {\n            my softstring $kv = $h.$key;\n            # get list of indexes of dependent table for join for this primary key value\n            my *list $cl = $lh.$st.$kv;\n\n            #log(LL_DEBUG_2, \"key: %y row kv: %y cl: %y\", $key, $kv, $cl);\n\n            # if there is no match, then just output the master row\n            if (!$cl) {\n                $l += $h;\n                continue;\n            }\n\n            # otherwise output one master row for each slave row with the required data from the slave row\n            foreach my softstring $i in ($cl) {\n                # get the slave row hash\n                my hash $sh = $th.$st[$i];\n                # copy the columns from the slave row to a copy of the master row and add it to the result list\n                $l += $h + $sh.($ajh.columns);\n            }\n        }\n    }\n\n    # save lookup hash info in temp data in case it's needed later\n    updateTempData((\"scmhub_data\": $l));\n\n    log(LL_DETAIL_1, \"returning %d row%s in join (source from master table %y: %d)\", $l.size(), $l.size() == 1 ? \"\" : \"s\", $mt, $th.$mt.size());\n    return $l;\n}\n\n#! returns a hash of common isepl column data\nhash sub mapls_scmhub_constant_data() {\n    # get wf name\n    my string $wf = sepl_get_current_name();\n    # get wfiid\n    my softint $wfiid = getWorkflowInstanceData(\"workflow_instanceid\");\n\n    return (\n\t\"M_SEPL_CREATED_ID\" : $wfiid,\n\t\"M_SEPL_UPDATED_ID\" : $wfiid,\n\t\"M_SEPL_NAME\" : $wf,\n\t\"M_SEPL_STATUS\" : 'C',\n\t\"M_SEPL_BEGIN_DATE\" : now_us(),\n\t\"M_SEPL_INSTANCE\" : getSystemInfo().\"instance-key\",\n\t\"M_SEPL_ENVIRONMENT\" : getStaticData().\"msepl\",\n\t\"M_SEPL_CREATED_BY_USER\" : $wf,\n\t\"M_SEPL_UPDATED_DATE\" : now_us(),\n\t\"M_SEPL_UPDATE_BY_USER\" : $wf,\n\n\t\"I_SEPL_CREATED_ID\" : $wfiid,\n\t\"I_SEPL_UPDATED_ID\" : $wfiid,\n\t\"I_SEPL_NAME\" : $wf,\n\t\"I_SEPL_STATUS\" : 'C',\n\t\"I_SEPL_BEGIN_DATE\" : now_us(),\n\t\"I_SEPL_INSTANCE\" : getSystemInfo().\"instance-key\",\n\t\"I_SEPL_ENVIRONMENT\" : \"ISEPL-AT\",\n\t\"I_SEPL_CREATED_BY_USER\" : $wf,\n\t\"I_SEPL_UPDATED_DATE\" : now_us(),\n\t\"I_SEPL_UPDATE_BY_USER\" : $wf,\n\t);\n}\n\nbool sub mapls_scmhub_check_serial() {\n    return mapls_scmhub_check_intern(\"scmSerialGoToError\");\n}\n\n#! checks if the order should go to error the first time or if it should be skipped\nbool sub mapls_scmhub_check(bool $write = False, bool $check = False, bool $update = False) {\n    my string $key = $write ? \"scmWriteGoToError\" : ($check ? \"scmCheckGoToError\": \"scmGoToError\");\n\n    return mapls_scmhub_check_intern($key, $write, $check, $update);\n}\n\nbool sub mapls_scmhub_check_intern(string $key, bool $write = False, bool $check = False, bool $update = False) {\n    my *hash $dd = getDynamicData();\n\n    # if flagged to go to error\n    if ($dd.$key) {\n        # remove error flag so this happens only the first time\n        my hash $h.$key = False;\n        updateDynamicData($h);\n        # raise error\n        throw SCM_SPLIT_ERROR, \"This order was created by the parent workflow to document that batch order splitting was necessary; some data could be processed successfully; some not; see parent order for error details\";\n    }\n\n    if (!$write && $dd.scmWriteGoToError) {\n        log(LL_INFO, \"parent order failed in scmhub write step; skipping this step\");\n        return True;\n    }\n\n    if (!$check && $dd.scmCheckGoToError) {\n        log(LL_INFO, \"parent order failed in scmhub check step; skipping this step\");\n        return True;\n    }\n\n    # skip processing if no data was written in the file mapping step\n    if ($dd.\"skip-local-staging\" && !($update && $dd.skiph)) {\n        log(LL_INFO, \"no data; skipping this step\");\n        return True;\n    }\n\n    return False;\n}\n\n#! removed errored rows from scmhub data in temp data\nsub mapls_update_scmhub_data(list $source_data, string $key, *hash $kh) {\n    if ($kh.empty())\n        return;\n\n    my list $l = ();\n    foreach my hash $rh in ($source_data) {\n        if ($kh.($rh.$key))\n            continue;\n        $l += $rh;\n    }\n\n    updateTempData((\"scmhub_data\": $l));\n}\n\n\nbool sub mapls_scmhub_do_normal_split(hash $props, *hash $dd, int $wfiid, *string $errtype) {\n    my string $ek = \"errh\";\n    if ($errtype)\n        $ek += \"_\" + ScmhubErrorConf.$errtype.key;\n    my softlist $errors = keys $dd.$ek;\n\n    if (!$errors)\n\treturn True;\n\n    # get gs datasource\n    my OracleDatasourcePool $lsds($props.local_staging);\n   \n    # make sure the transaction is committed before creating the child wf order\n    on_success $lsds.commit();\n    on_error $lsds.rollback();\n\n    # update rows in local staging with the negative value of this wfiid\n    foreach my string $t in ($props.tablelist) {\n        # get the name of the key column to use\n        my string $key = sepl_get_key($t, $props);\n        \n        mapls_update_errors($lsds, $t, $wfiid, $key, $errors, $errtype);\n    }\n\n    return False;\n}\n\nbool sub mapls_scmhub_do_error_tables_split(hash $props, *hash $dd, int $wfiid, *string $errtype) {\n    # get gs datasource\n    my OracleDatasourcePool $lsds($props.local_staging);\n\n    # make sure the transaction is committed before creating the child wf order\n    on_success $lsds.commit();\n    on_error $lsds.rollback();\n\n    my bool $skip = True;\n\n    my string $key = \"error_tables\";\n    if ($errtype)\n        $key += \"_\" + ScmhubErrorConf.$errtype.key;\n    \n    foreach my string $t in ($dd.$key.keyIterator()) {\n        foreach my string $col in ($dd.$key.$t.keyIterator()) {\n            if (!$dd.$key.$t.$col.lsize())\n                continue;\n            $skip = False;\n\n            mapls_update_errors($lsds, $t, $wfiid, $col, keys $dd.$key.$t.$col, $errtype);\n        }\n    }\n\n    return $skip;\n}\n\nsub mapls_scmhub_split_lib(*string $errtype) {\n    my *hash $dd = getDynamicData();\n    my softint $wfiid = getWorkflowInstanceData(\"workflow_instanceid\");\n    my hash $props = getInstanceData();\n\n    my string $key = \"error_tables\";\n    if ($errtype)\n        $key += \"_\" + ScmhubErrorConf.$errtype.key;\n\n    if ($dd.$key ? mapls_scmhub_do_error_tables_split($props, $dd, $wfiid, $errtype) : mapls_scmhub_do_normal_split($props, $dd, $wfiid, $errtype)) {\n\tlog(LL_INFO, \"no errors to split; skipping (loosely-coupled) subworkflow bind step\");\n        return;\n    }\n\n    mapls_scmhub_split_wf($wfiid, $props, $dd, $errtype);\n}\n\nsub mapls_scmhub_split_wf(int $wfiid, hash $props, *hash $dd, *string $errtype) {\n    my string $key = mapls_get_error_key($errtype);\n    my hash $sd = getStaticData();\n    # set error key in new dynamic data\n    my hash $ndd.$key = True;\n\n    if ($props.omit_static_data)\n        $sd -= $props.omit_static_data;\n\n    if ($props.copy_dynamic_to_static) {\n        if ($props.copy_dynamic_to_static.typeCode() != NT_LIST)\n            $props.copy_dynamic_to_static = list($props.copy_dynamic_to_static);\n        $sd += $dd.($props.copy_dynamic_to_static);\n    }\n\n    if ($props.copy_dynamic) {\n        if ($props.copy_dynamic.typeCode() != NT_LIST)\n            $props.copy_dynamic = list($props.copy_dynamic);\n        $ndd += $dd.($props.copy_dynamic);\n    }\n\n    # calculate value for error_wfiid\n    my int $val = -$wfiid;\n    if ($errtype)\n        $val += ScmhubErrorConf.$errtype.offset;\n    $sd += (\"error_wfiid\": $val);\n\n    # set appropriate order key with the workflow value\n    my string $ok = mapls_get_parent_key($errtype);\n    my *hash $okh = getOrderKeys();\n    $okh.$ok = $wfiid;\n\n    # create new order data hash\n    my hash $oh = (\n        \"staticdata\": $sd, \n        \"dynamicdata\": $ndd,\n        \"orderkeys\": $okh,\n        );\n\n    my string $name = getWorkflowInstanceData(\"name\");\n    my softint $child_wfiid = createOrder($name, NOTHING, $oh);\n    # set child wf id in dynamic data\n    my string $ck = mapls_get_child_key($errtype);\n    my hash $dh.(\"split_error_wfiid_\" + $ck) = $child_wfiid;\n    updateDynamicData($dh);\n    log(LL_INFO, \"created child workflow order %d\", $child_wfiid);\n}\n","created": "2015-01-20 12:56:22.213060 +01:00","modified": "2015-01-20 12:56:22.213060 +01:00","createdby": "omq","modifiedby": "omq","tags": {},"source": "/Users/pchalupny/workspace/builds/qorus/user/libraries/mapls-lib-v1.0.qfd","offset": "7","host": "panda.local","user": "<shell-unknown>"},{"name": "mapls_rma_mip21_init","version": "1.0","id": 413,"function_type": "GENERIC","description": "MIP 31 -> 21 GSI_COMMISSIONING init function","author": "Marian Bonda, David Nichols","body": "%require-types\n\n#! MIP 21 wf template\nconst Mip21_Wf = \"$CC-21-COMMISSIONING_DATA_CDS-OUT\";\n\n#! maps to GSI_COMMISSIONING\nconst Commissioning_Mapper = (\n    \"order_number\": True,\n    \"shipment_type\": True,\n    \"dealer_code\": True,\n    \"account_number\": True, # xxx\n    \"item_code\": \"item_number\",\n    \"item_description\": True,\n    \"item_type\": True,\n    \"imei\": \"serial_number\",\n    \"msisdn\": True,\n    \"schedule_ship_date\": True,\n    \"return_date\": (\"code\": date sub (any $x, hash $rec) { return $rec.recording_date ? $rec.recording_date : $rec.system_time; }),\n    \"return_reason_code\": True,\n    \"return_reason_type\": \"return_reason_code\",\n    \"item_inspection_result\": (\"code\": string sub (any $x, hash $rec) { return $rec.inspection_result ? $rec.inspection_result : \"PASS\"; }),\n    \"tracking_number\": \"i_sepl_created_id\",\n    #\"delivery_detail_id\": \"line_number\",    \n    \"delivery_id\": string sub (any $x, hash $rec) { return now().format(\"YYYYMMDDHHmmSS\"); },\n    \"bi_isepl_id\": int sub (any $x, hash $rec) { return $rec.serial_number ? 0 : -1419; },\n    );\n\n#! constant fields for gsi_commissioning\nconst crec_commissioning = (\n    \"message_type\": \"COMMISSIONING\",\n    \"record_type\": \"R\",\n    \"item_category_type\": \"INVENTORY\",    \n    );        \n","created": "2015-01-20 12:56:25.411233 +01:00","modified": "2015-01-20 12:56:25.411233 +01:00","createdby": "omq","modifiedby": "omq","tags": {},"source": "/Users/pchalupny/workspace/builds/qorus/user/31-RMA_RECEIPT/mapls_rma_create_mip21_data-v1.0.qfd","offset": "7","host": "panda.local","user": "<shell-unknown>"}],"classes": [{"name": "Mapper","version": "1.0","id": 3,"description": "helper classes for flexible field mappings","author": "David Nichols (Qore Technologies, sro)","body": "\n#! this class is a base class for mapping input data to an Oracle table\n/* this class can be used to map from an input hash to an output hash\n*/\nclass MapperBase {\n    private {\n        #! the hash providing output field names and mappings\n\thash $.map;\n\n        #! the db encoding; necessary if any field mappings contain the \"maxlen\" key\n        *string $.enc;\n\n        #! the optional name for the object (for example - a table name) -will be prepended to field names in error messages\n        *string $.name;\n\n        # valid hash keys\n        const ValidKeys = (\n            \"name\": True,\n            \"code\": True,\n            \"maxlen\": True,\n            \"trunc\": True, \n            \"mand\": True,\n            \"number\": True,\n            \"type\": True,\n            \"sequence\": True,\n            );\n\n        # valid types\n        const ValidTypes = (\n            \"number\": True,\n            \"date\": True,\n            );\n    }\n\n    # no public members\n    public {}\n\n    #! builds the object based on a hash providing field mappings, data constraints, and optionally logic\n    /** @param $map a hash providing field mappings; each hash key is the name of the target record (Oracle column); each value is either \\c True (meaning no translations are done; the data is copied 1:1) or a hash with the following fields providing information about how the input records should be translated (all fields are optional):\n\t- \\c name: the value of this key gives the name of the input field; only use this if the input record name is different than the column name\n        - \\c code: a closure or call reference to process the field\n        - \\c maxlen: an integer giving the maximum field length in bytes; note that if any fields contain this key, the $enc argument must be supplied as well\n        - \\c trunc: assign to boolean True if the field should be truncated if over the maximum field length; this key can only be set to \\c True if the \\c \"maxlen\" key is also given\n        - \\c mand: assign to boolean True if the field is mandatory and an exception should be thrown if no input data is supplied\n        - \\c type: this gives the field type, can be \\c \"number\": field accepts only numeric values (any non-numeric values on input will cause an exception to be thrown when mapping) or \\c \"date\": date field\n        @param $enc the db encoding; necessary if any field mappings contain the \"maxlen\" key\n        @param $name the name of the mapper for use in logging strings\n\n        @throw MAP-ERROR the map hash has a logical error (ex: 'trunc' key given without 'maxlen', invalid map key)\n    */\n    constructor(hash $map, *string $enc, *string $name) {\n\t$.map = $map;\n        $.enc = $enc;\n        $.name = $name;\n\n        if (!$map)\n            throw \"MAP-ERROR\", \"empty map passed to MapperBase::constructor()\";\n\n        my hash $vk = $.validKeys();\n\n        # check map for logical errors\n        foreach my string $k in ($map.keyIterator()) {\n            if ($map.$k.maxlen && !exists $enc)\n                throw \"MAP-ERROR\", sprintf(\"field '%s' has a 'maxlen' field (%d), but the second argument giving the database encoding was not supplied to MapperBase::constructor()\", $.getFieldName($k), $map.$k.maxlen);\n\n            if ($map.$k.trunc && !$map.$k.maxlen)\n                throw \"MAP-ERROR\", sprintf(\"field '%s' has the 'trunc' key set to True, has no 'maxlen' key\", $.getFieldName($k));\n\n            foreach my string $hk in (keys $map.$k)\n                if (!$vk.$hk)\n                    throw \"MAP-ERROR\", sprintf(\"field '%s' in map hash contains unknown key '%s' (valid keys: %y)\", $.getFieldName($k), $hk, $vk.keys());\n\n            # convert old \"number\" tag to new \"type\" tag\n            if ($map.$k.number) {\n                if (exists $map.$k.type)\n                    throw \"MAP-ERROR\", sprintf(\"field '%s' has both 'type' and deprecated 'number' tags\", $.getFieldName($k));\n                $map.$k.type = \"number\";\n            }\n            else if (exists $map.$k.type && !ValidTypes.($map.$k.type))\n                throw \"MAP-ERROR\", sprintf(\"field '%s' in map hash contains an invalid type value '%s' (valid types: %y)\", $.getFieldName($k), $map.$k.type, ValidTypes.keys());\n\n            if (exists $map.$k.code && $map.$k.code.type() != Type::Closure && $map.$k.code.type() != Type::CallReference)\n                throw \"MAP-ERROR\", sprintf(\"field '%s' in map hash has a code argument assigned to type '%s'\", $.getFieldName($k), $map.$k.code.type());\n        }\n    }\n\n    string getFieldName(string $name) {\n        return $.name.val() ? sprintf(\"%s.%s\", $.name, $name) : $name;\n    }\n\n    #! returns a list of valid keys for this class (can be overridden in subclasses)\n    /** @return a list of valid keys for this class (can be overridden in subclasses)\n    */\n    hash validKeys() {\n        return ValidKeys;\n    }\n\n    #! processes the input record and returns a hash of the mapped values where the keys in the hash returned are the target field names; the order of the fields in the hash returned is the same order as the keys in the map hash.\n    /** @param $rec the record to translate\n\t@return a hash of field values in the target format based on the input data and processed according to the logic in the map hash\n        @throw MISSING-INPUT a field marked mandatory is missing\n        @throw STRING-TOO-LONG a field value exceeds the maximum value and the 'trunc' key is not set\n        @throw INVALID-NUMBER the field is marked as numeric but the input value contains non-numeric data\n    */\n    hash mapData(hash $rec) {\n        # we know the map has at least 1 element so no need to initialize $h as a hash to guarantee the return type\n\tmy hash $h;\n\n\t# iterate through target fields\n\tforeach my string $key in ($.map.keyIterator()) {\n            my any $m = $.map.$key;\n\n\t    # get source field name\n\t    my string $name = exists $m.name ? $m.name : $key;\n\n\t    # get source record value\n\t    my any $v;\n            if ($m.struct) {\n                # get the value\n                $v = $rec;\n                map $v = $v{$m.struct[$1]}, xrange(0, $m.struct.size() - 1);\n            }\n            else\n                $v = $rec.$name !== NULL ? $rec.$name : NOTHING;\n\n            # move any XML CDATA into the field value\n\t    if (exists $v.\"^cdata^\")\n\t\t$v = $v.\"^cdata^\";\n\n            # if the internal field was marked as needing processing by a subclass, then call the mapSubclass method\n            if ($m.subclass)\n                $v = $.mapSubclass($m, $v);\n\n            # execute any field filter if necessary\n\t    if (exists $m.code) {\n                try {\n                    $v = $m.code($v, $rec);\n                }\n                catch (hash $ex) {\n                    $ex.desc = sprintf(\"field %y closure: %s\", $key, $ex.desc);\n                    throw $ex.err, $ex.desc, $ex.arg;\n                }\n            }\n\n            # check maximum length\n            if ($m.maxlen && strlen($v) > $m.maxlen) {\n                # truncate the string if necessary\n                if ($m.trunc) {\n                    my string $msg = sprintf(\"field %y = %y input length %d truncating to %d bytes\", $.getFieldName($key), $v, strlen($v), $m.maxlen);\n%ifdef QorusWorkflow\n                    swarning(TRUNCATION_WARNING, $msg);\n%else\n                    log(LL_DETAIL_2, $msg);\n%endif\n                    $v = trunc_str($v, $m.maxlen, $.enc);\n                }\n                else\n                    throw \"STRING-TOO-LONG\", sprintf(\"field %y = %y, input length %d exceeds maximum byte length %d for input row: %y\", $.getFieldName($key), $v, strlen($v), $m.maxlen, $rec);\n            }\n\n            if ($v.typeCode() == NT_STRING && $v.empty())\n                delete $v;\n\n            if ($m.mand && !exists $v)\n                throw \"MISSING-INPUT\", sprintf(\"field %y is marked as mandatory but is missing in the input row: %y\", $.getFieldName($key), $rec);\n\t\n            # check for valid numeric values\n            if ($m.type == \"number\") {\n\t\tif (exists $v && $v !~ /^([-+])?[0-9\\.]+$/)\n\t\t    throw \"INVALID-NUMER\", sprintf(\"field %y = %y is marked as a numeric field, but the input data contains non-numeric text in input row: %y\", $.getFieldName($key), $v, $rec);\n\n%ifdef QoreDebug\n\t\t# only necessary for postgresql\n                if (exists $v && $v !== NULL)\n                    $v = number($v);\n%endif\n\t    }\n            else if ($m.type == \"date\" && $v.val() && $v.typeCode() != NT_DATE) {\n                $v = date($v);\n            }\n\n            # add value to row list\n\t    $h.$key = $v;\n\t}\n\n\t#log(LL_DEBUG_2, \"MapperBase::mapData() REC: %N\\nreturning: %N\", $rec, $h);\n\t#log(LL_DEBUG_2, \"MapperBase::mapData() returning: %y\", $h);\n        # return list of values for row\n\treturn $h;\n    }\n\n    #! to be overridden as necessary in subclasses\n    private any mapSubclass(hash $m, any $v) {\n        return $v;\n    }\n}\n\n#! this class provides an easy way to map row data to a single table\nclass SingleTableInboundMapper inherits public MapperBase {\n    private {\n        #! the AbstractDatasource used for inserts\n        AbstractDatasource $.dsp;\n\n        #! SQL string used for inserts\n        string $.sql_insert;\n\n        #! table name\n        string $.table_name;\n\n        #! constant values to add in each insert\n        *hash $.crec;\n    }\n\n    #! builds the object based on a hash providing field mappings, data constraints, and optionally logic; this variant takes a Datasource/DatasourcePool or other wrapper class as an argument directly\n    /** @param $dsp the Datasource/DatasourcePool or other wrapper class to do the inserts\n        @param $table_name the name of the table to insert into\n        @param $map a hash providing field mappings; each hash key is the name of the target record (Oracle column); each value is either \\c True (meaning no translations are done; the data is copied 1:1) or a hash with the following fields providing information about how the input records should be translated (all fields are optional):\n\t- \\c name: the value of this key gives the name of the input field; only use this if the input record name is different than the column name\n        - \\c code: a closure or call reference to process the field\n        - \\c maxlen: an integer giving the maximum field length in bytes; note that if any fields contain this key, the $enc argument must be supplied as well\n        - \\c trunc: assign to boolean True if the field should be truncated if over the maximum field length; this key can only be set to \\c True if the \\c \"maxlen\" key is also given\n        - \\c mand: assign to boolean True if the field is mandatory and an exception should be thrown if no input data is supplied\n        - \\c type: this gives the field type, can be \\c \"number\": field accepts only numeric values (any non-numeric values on input will cause an exception to be thrown when mapping) or \\c \"date\": date field\n        - \\c sequence: this field is populated from a sequence, the name of which is given as the value of this key\n        @param $extra_fields an optional list of additional field names for each insert; these values could differ for each row; if they are constant, put them in the $crec argument hash instead\n        @param $crec an optional constant hash of column names and values to add to each insert\n\n        @throw MAP-ERROR the map hash has a logical error (ex: 'trunc' key given without 'maxlen', invalid map key)\n    */\n    constructor(AbstractDatasource $dsp, string $table_name, hash $map, *softlist $extra_fields, *hash $crec) : MapperBase($map, $dsp.getOSEncoding(), $table_name) {\n        $.dsp = $dsp;\n        $.table_name = $table_name;\n\n        $.init($extra_fields, $crec);\n    }\n\n    #! returns a list of valid keys for this class (can be overridden in subclasses)\n    /** @return a list of valid keys for this class (can be overridden in subclasses)\n    */\n    hash validKeys() {\n        return ValidKeys + (\"sequence\": True);\n    }\n\n    #! shared initialization for constructors; not for external use\n    private init(*softlist $extra_fields, *hash $crec) {\n        # keys will be the list of column names to insert\n        my list $keys = ();\n\n        # copy constant record\n        $.crec = $crec;\n\n        # now add the column names from the map passed\n        $keys += keys ($.map + $crec);\n\n        # check for \"sequence\" key\n        foreach my string $k in ($keys) {\n            # set the \"subclass\" key for all fields with a \"sequence\" key\n            if (exists $.map.$k.sequence)\n                $.map.$k.subclass = True;\n        }\n\n        # prepare insert statement SQL\n        $.sql_insert = sprintf(\"insert into %s (\", $.table_name);\n\n        # add extra fields to the column name list\n\tif (elements $extra_fields)\n\t    $keys += $extra_fields;\n\n        # add field names to string\n        map $.sql_insert += sprintf(\"%s,\", $1), $keys;\n\n        # remove trailing comma and add more text\n        splice $.sql_insert, -1, 1, \") values (\";\n        map $.sql_insert += \"%v,\", $keys;\n\n        # replace trailing comma with close paren\n        splice $.sql_insert, -1, 1, \")\";\n    }\n\n    #! processes \"sequence\" keys\n    private any mapSubclass(hash $m, any $v) {\n        return $.getDS().getNextSequenceValue($m.sequence);\n    }\n\n    #! returns the Datasource/DatasourcePool or other wrapper class associated with this object\n    /** this method is normally used only internally\n        @return the Datasource/DatasourcePool or other wrapper class associated with this object\n    */\n    object getDS() {\n        return $.dsp;\n    }\n\n    #! inserts a row into the target table based on a mapped input record; does not commit the transaction\n    /** @param $rec the input record\n        @param $extra_values an optional list of extra values to add to the field list; if any extra fields were defined in the constructor, then the extra values must be given here\n        @param $ll an option log level argument, if this argument is present, then the SQL and arguments will be logged with the given log level\n\n        @return a hash of the row values inserted (row name: value), not including the extra values\n\n        @throw MISSING-INPUT a field marked mandatory is missing\n        @throw STRING-TOO-LONG a field value exceeds the maximum value and the 'trunc' key is not set\n        @throw INVALID-NUMBER the field is marked as numeric but the input value contains non-numeric data        \n    */\n    hash insertRowNoCommit(hash $rec, softlist $extra_values, *int $ll) {\n        my hash $h = $.mapData($rec + $.crec);\n        my list $args = hash_values($h) + $extra_values;\n\n        if ($ll) {\n            log($ll, \"insert %s: %y, extra: %y\", $.table_name, $h, $extra_values);\n            #log($ll, \"SQL=%s\", $.sql_insert);\n            #log($ll, \"args=%y\", $args);\n        }\n\n        $.getDS().vexec($.sql_insert, $args);\n\n        return $h;\n    }\n\n    #! inserts a row into the target table based on a mapped input record; commits the transaction\n    /** @param $rec the input record\n        @param $extra_values an optional list of extra values to add to the field list; if any extra fields were defined in the constructor, then the extra values must be given here\n        @param $ll an option log level argument, if this argument is present, then the SQL and arguments will be logged with the given log level\n\n        @return a hash of the row values inserted (column: value), not including the extra values\n\n        @throw MISSING-INPUT a field marked mandatory is missing\n        @throw STRING-TOO-LONG a field value exceeds the maximum value and the 'trunc' key is not set\n        @throw INVALID-NUMBER the field is marked as numeric but the input value contains non-numeric data        \n    */\n    hash insertRow(hash $rec, *softlist $extra_values, *int $ll) {\n        my object $dsp = $.getDS();\n        on_success $dsp.commit();\n        on_error $dsp.rollback();\n\n        return $.insertRowNoCommit($rec, $extra_values, $ll);\n    }\n\n    #! commits the transaction\n    nothing commit() {\n        $.getDS().commit();\n    }\n\n    #! rolls back the transaction\n    nothing rollback() {\n        $.getDS().rollback();\n    }\n\n    #! returns the table name\n    string getTableName() {\n        return $.table_name;\n    }\n}\n","created": "2015-01-20 12:56:26.851916 +01:00","modified": "2015-01-20 12:56:26.851916 +01:00","createdby": "omq","modifiedby": "omq","tags": {},"source": "/Users/pchalupny/workspace/builds/qorus/user/classes/Mapper-v1.0.qclass","offset": "5","host": "panda.local","user": "<shell-unknown>"}],"constants": [{"name": "Errors","version": "1.0","id": 3,"description": "defines error constants for SEPL workflow and job errors","author": "SEPL Qorus dev team","body": "#! this namespace contains all error constants\nnamespace ERROR {\n    #! when a transaction cannot be completed due to an Oracle cluster failover error\n    const DB_CLUSTER_FAILOVER = 'DB-CLUSTER-FAILOVER';\n\n    #! when a workflow or job cannot start because a required system property is not set\n    const PROPERTY_ERROR = 'PROPERTY-ERROR';\n\n    #! when SOAP authentication info is missing in system properties\n    const SOAP_AUTHENTICATION_ERROR = 'SOAP-AUTHENTICATION-ERROR';\n\n    #! when an order cannot be unblocked due to unforseen technical reasons (invalid status, etc)\n    const UNBLOCK_ERROR = 'UNBLOCK-ERROR';\n\n    #! when EBS returns an error code to a request\n    const EBS_ERROR = 'EBS-ERROR';\n\n    #! when a db action cannot be completed because a package has been redeployed\n    const DB_PACKAGE_STATE_ERROR = \"DB-PACKAGE-STATE-ERROR\";\n\n    #! the connection to the DB was lost or could not be established - workflows should retry when this error is thrown\n    const DATASOURCE_ERROR = \"DATASOURCE-ERROR\";\n\n    #! A business error for SCMHUB communication (manual throws)\n    const SCMHUB_ERROR = \"SCMHUB-ERROR\";\n\n    #! A common business error (manual throws)\n    const BUSINESS_ERROR = \"BUSINESS-ERROR\";\n\n    #! missing reason code (business error)\n    const MISSING_REASON_MAPPING = \"MISSING-REASON-MAPPING\";\n\n    #! smtp data error (gets a retry)\n    const SMTP_DATA_EXCEPTION = \"SMTP-DATA-EXCEPTION\";\n\n    #! file archive error (gets a retry)\n    const FILE_ARCHIVE_ERROR = \"FILE-ARCHIVE-ERROR\";\n\n    #! file open error (gets a retry)\n    const FILE_OPEN_ERROR = \"SEPL-FILE-OPEN-ERROR\";\n\n    #! scmhub info error message\n    const SCMHUB_ERROR_INFO = \"SCMHUB-ERROR-INFO\";\n\n    #! scmhub error summary message\n    const SCMHUB_ERROR_SUMMARY = \"SCMHUB-ERROR-SUMMARY\";\n\n    #! scmhub info result message\n    const SCMHUB_RESULT = \"SCMHUB-RESULT\";\n\n    #! batch splitting error\n    const SCM_SPLIT_ERROR = \"SCM-SPLIT-ERROR\";\n\n    #! input data truncation warning\n    const TRUNCATION_WARNING = \"TRUNCATION-WARNING\";\n\n    #! input data record skip warning\n    const SKIP_WARNING = \"SKIP-WARNING\";\n\n    #! input file is duplicated\n    const FILENAME_DUPLICITY_ERROR = \"FILENAME-DUPLICITY-ERROR\";\n\n    #! input file is duplicated\n    const FILENAME_DUPLICATION_ERROR = \"FILENAME-DUPLICATION-ERROR\";\n\n    #! async queue key doesn't exist yet: normally due to a race condition, should get a retry\n    const INVALID_KEY = \"INVALID-KEY\";\n\n    #! for transaction timeouts acquiring a datasource, should get a retry\n    const TRANSACTION_LOCK_TIMEOUT = \"TRANSACTION-LOCK-TIMEOUT\";\n\n    #! for temporary connection errors; should get a retry\n    const SOCKET_CONNECT_ERROR = \"SOCKET-CONNECT-ERROR\";\n\n    #! for scmhub timeout errors that should get a retry\n    const SCMHUB_TIMEOUT = \"SCMHUB-TIMEOUT\";\n\n    #! for Hybris SOAP error which should be retried\n    const HYBRIS_RETRY = \"HYBRIS-RETRY\";\n\n    #! for MIP03 error which should be retried\n    const MIP03_RETRY = \"MIP03-RETRY\";\n\n    #! wincash invalid request\n    const WINCASH_REQUEST_ERROR = \"WINCASH-REQUEST-ERROR\";\n}\n","created": "2015-01-20 12:56:26.755731 +01:00","modified": "2015-01-20 12:56:26.755731 +01:00","createdby": "omq","modifiedby": "omq","tags": {},"source": "/Users/pchalupny/workspace/erp-sepl/src/constants/Errors-v1.0.qconst","offset": "6","host": "panda-2.local","user": "pchalupny"}]},"mappers": null,"vmaps": null,"stepinfo": [{"name": "mapls_rma_receipt_inem_update_oracle","version": "1.0","author": "Marian Bonda","steptype": "NORMAL","stepfunction_instanceid": 400,"validationfunction_instanceid": 57,"arraytype": "NONE","created": "2015-01-20 12:56:46.936999 +01:00","sfname": "mapls_rma_receipt_inem_update_oracle","vfname": "mapls_update_oracle_validation","functions": [{"type": "primary","name": "mapls_rma_receipt_inem_update_oracle","version": "1.0","function_instanceid": 400,"function_type": "STEP","description": "update Oracle with RMA Receipt information","author": "Marian Bonda","body": "%require-types\n%require-our\n\n#! inserts a row in the staging database for each record and commits all of the new records in a single transaction\nsub mapls_rma_receipt_inem_update_oracle() {\n\n     my hash $sd = getStaticData();\n\n     # if running for the first time, process the file to gs\n     if (!exists $sd.error_wfiid)\n         process_data($sd);\n     else # otherwise update the local staging rows with this wfiid\n         map_update_ls($sd);\n\n}\n\n#! inserts a row in the staging database for each record and commits all of the new records in a single transaction\nsub process_data(hash $sd) {\n    my hash $props = getInstanceData();\n        \n    log(LL_DEBUG_1, \"data: %N\", $sd.data);\n\n    # insert row in primary table and rows in file details table and commit\n    on_success $props.brep_trans_mapper.commit();\n    on_error $props.brep_trans_mapper.rollback();\n\n    # capture data inserted for use in subsequent steps\n    my hash $nd = (\n        \"gsi_brep_trans\": (),\n        \"gsi_snr\": (),\n        );\n\n    # make a list of transaction_ids to be skipped after the scmhub call\n    my list $stidl = ();\n\n    foreach my hash $rec in ($sd.data) {\n        my hash $row = $props.brep_trans_mapper.insertRowNoCommit($rec, NOTHING, OMQ::LL_DEBUG_1);\n        $nd.gsi_brep_trans += $row;\n\n        switch ($rec.process_oracle) {\n            case \"N\": $stidl += $row.transaction_id;\n            case \"Y\": break;\n%ifdef INEM_SKIP\n            default: throw \"DATA-ERROR\", sprintf(\"missing or invalid 'process_oracle' field (with 'Y' or 'N' value) in input data: %N\", $rec);\n%endif\n        }\n\n        if ($rec.serial_number) {\n            $rec.\"_id\" = $row.transaction_id;\n            $row = $props.snr_mapper.insertRowNoCommit($rec, NOTHING, OMQ::LL_DEBUG_1);\n            $nd.gsi_snr += $row;\n        }\n    }\n\n    # save inserted data in TempData\n    updateTempData((\"data\": $nd));\n\n    my hash $dd;\n    # update complete_skip if we have any data with process_oracle = \"N\"\n    if ($stidl)\n        $dd.complete_skip = (\n            \"gsi_brep_trans\": (\n                \"column\": \"transaction_id\",\n                \"values\": $stidl,\n            ),\n            \"gsi_snr\": (\n                \"column\": \"transaction_id\",\n                \"values\": $stidl,\n            ),\n        );\n\n    # update dynamic data with row counts\n    {\n\tmy hash $ch;\n\tmap $ch.$1 = $nd.$1.lsize(), keys $nd;\n\t$dd += (\n            \"records_inserted\": $nd.gsi_brep_trans.size(),\n            \"records_total\": $sd.data.size(),\n            \"records_skipped\": 0,\n            \"ls-row-count\": $ch,\n\t    );\n        updateDynamicData($dd);\n    }\n\n    my int $c = $nd.gsi_brep_trans.size();\n    my int $sc = $nd.gsi_snr.size();\n    log(LL_INFO, \"inserted %d GSI_BREP_TRANS row%s\", $c, $c == 1 ? \"\" : \"s\");\n    log(LL_INFO, \"inserted %d GSI_SNR row%s\", $sc, $sc == 1 ? \"\" : \"s\");\n\n    if (!$c) {\n\tlog(LL_INFO, \"no records written to local staging; marking dynamic data for skipping remaining logic\");\n\tupdateDynamicData((\"skip-local-staging\": True));\n    }\n}\n","created": "2015-01-20 12:56:25.276357 +01:00","modified": "2015-01-20 12:56:25.276357 +01:00","createdby": "omq","modifiedby": "omq","tags": {},"source": "/Users/pchalupny/workspace/builds/qorus/user/31-RMA_RECEIPT/mapls_rma_receipt_inem_update_oracle-v1.0.qfd","offset": "6","host": "panda.local","user": "<shell-unknown>"},{"type": "validation","name": "mapls_update_oracle_validation","version": "1.0","function_instanceid": 57,"function_type": "VALIDATION","description": "validation for \"update_oracle\" steps in MAPLS- wfs in local staging","author": "David Nichols (Qore Technologies, sro)","body": "%require-types\n\nstring sub mapls_update_oracle_validation() {\n    my softlist $l = getInstanceData(\"tablelist\");\n    return mapls_oracle_table_validation($l[0]);\n}\n","created": "2015-01-20 12:56:22.217454 +01:00","modified": "2015-01-20 12:56:22.217454 +01:00","createdby": "omq","modifiedby": "omq","tags": {},"source": "/Users/pchalupny/workspace/builds/qorus/user/libraries/mapls-lib-v1.0.qfd","offset": "493","host": "panda.local","user": "<shell-unknown>"}]},{"name": "mapls_rma_receipt_scmhub_get","version": "1.0","author": "Marian Bonda","steptype": "NORMAL","stepfunction_instanceid": 402,"arraytype": "NONE","created": "2015-01-20 12:56:46.219710 +01:00","sfname": "mapls_rma_receipt_scmhub_get","functions": [{"type": "primary","name": "mapls_rma_receipt_scmhub_get","version": "1.0","function_instanceid": 402,"function_type": "STEP","description": "RMA Receipt SCM Hub get scmhub values for future updates","author": "Marian Bonda","body": "%require-types\n\n# MIP 31a Variant hash - for O(ln(n)) variant lookups based on the order type\n# needed here for the correct argument to scm_ret_ser_qty_rma_ln and scm_ret_ser_qty_rma_lns\nconst VariantMap = (\n    # MIP 31a1\n    \"DOM Extra\": 1,\n    \"DOM Exchange Extra\": 1,\n    \"DOM IE Exchange Extra\": 1,\n    \"DOM UK Return\": 1,\n    \"DOM UK Exchange Return\": 1,\n    \"DOM IE RETURN\": 1,\n    \"DOM IE EXCHANGE Return\": 1,\n    \"DOM UK Failed Delivery\": 1,\n    \"DOM IE failed delivery\": 1,\n\n    # MIP 31a2\n    \"WOM Extra\": 2,\n    \"WOM UK Debit Note Return\": 2,\n    \"WOM UK Return Order\": 2,\n    \"WOM UK Intercompany Return\": 2,\n    \"WOM UK I/C Export Return\": 2,\n    \"WOM UK MVNO Return\": 2,\n    \"WOM UK Insurance Return\": 2,\n    \"WOM IE INSURANCE RETURN\": 2,\n    \"WOM UK Corporate Return\": 2,\n    \"WOM IE CORPORATE RETURN\": 2,\n    \"WOM IE RETURN\": 2,\n    \"WOM IE Indirect Return\": 2,\n    \"WOM IE I/C Return\": 2,\n    \"WOM IE Failed Delivery\": 2,\n\n    # MIP 31a3\n    \"Internal Return\": 3,\n    \"Retail Extra\": 3,\n    \"WOM Retail Extra\": 3,\n    \"WOM IE INTERNAL RETURN\": 3,\n    \"WOM IE RETAIL EXTRA RETURN\": 3,\n    \"WOM Internal Return\": 3,\n\n    # MIP 31a4\n    \"WOM H3G Retail Return\": 4,\n    \"WOM IE RETAIL RETURN\": 4,\n    );\n\n#! retrieves data from the SCM Hub \nsub mapls_rma_receipt_scmhub_get() {\n    # check if the order should go to error the first time or if it should be skipped\n    if (mapls_scmhub_check())\n        return;\n\n    my hash $props = sepl_check_update_keys(getInstanceData());\n    log(LL_INFO, \"props.update_keys: %y tablelist: %y\", $props.update_keys, $props.tablelist);\n\n    # get data from gsi_brep_trans only\n    my list $data = mapls_get_data($props, $props.local_staging, \"gsi_brep_trans\").gsi_brep_trans;\n\n    # master hash of key values -> True (the last value is a hash so keys are only inserted once)\n    my hash $errh;\n\n    # master hash of updates to apply to transaction IDs (table -> keyname -> value -> column name -> value)\n    # however when table = \"*\" then it's \"*\" -> column name -> value (applied to all affected rows in all tables)\n    # however when keyname = \"*\" then it's table -> \"*\" -> column name -> value (applied to all affected rows in the given table)\n    #my hash $updateh;\n\n    log(LL_INFO, \"gsi_brep_trans rows: %d\", $data.size());\n    if (!$data) {\n        log(LL_INFO, \"no rows to process; skipping step\");\n\treturn;\n    }\n\n    # get scmhub datasource\n    my OracleDatasourcePool $ds(\"scmhub\");\n\n    my string $org_name = $props.org_name;\n\n    log(LL_DEBUG_1, \"data: %N\", $data);\n\n    # make map of order_id -> transaction_id list for the ret_rma_order_type call\n    my hash $oid;\n    map $oid.($1.order_id) += list($1.transaction_id), $data;\n    log(LL_DEBUG_2, \"oid: %y\", $oid);\n\n    # retrieve RMA order_type\n    my hash $ot = sepl_scmhub_ret_rma_order_type($ds, $org_name, $oid, \\$errh);\n    log(LL_DEBUG_1, \"retr_ot: %y\", $ot);\n\n    my hash $gl_orders;\n    my list $retail_extra_list;\n    my hash $check_serial_doc_hash;\n    my hash $check_serial_source_doc_hash;\n    \n    # map of order_ids to MIP 31a variant numbers\n    my hash $vmap;\n\n    foreach my string $k in ($oid.keyIterator()) {\n        # get the variant number for this order\n        $vmap.$k = VariantMap.($ot.$k);\n        if (!$vmap.$k)\n            throw \"UNKNOWN-ORDER-TYPE\", sprintf(\"cannot process unknown order type %y for order_id %y\", $ot.$k, $k);\n\n        log(LL_DEBUG_2, \"$ot.$k: %s\", $ot.$k);\n\n        if (inlist($ot.$k, (\"WOM H3G Retail Return\", \"WOM IE RETAIL RETURN\"))){\n            $check_serial_doc_hash.$k = True;\n        } else {\n            $check_serial_source_doc_hash.$k = True;\n        }\n\n        if (inlist($ot.$k, (\"WOM Internal Return\", \"Internal Return\"))){\n            $gl_orders.$k = True;\n        }        \n     \n        if (inlist($ot.$k, (\"WOM IE RETAIL EXTRA RETURN\", \"WOM Retail Extra\"))){\n            $retail_extra_list += $k;\n        }\n    }\n    log(LL_DEBUG_2, \"gl_orders: %y\", $gl_orders);\n    log(LL_DEBUG_2, \"check_serial_source_doc_hash: %y\", $check_serial_source_doc_hash);\n    log(LL_DEBUG_2, \"check_serial_doc_hash: %y\", $check_serial_doc_hash);\n    log(LL_DEBUG_2, \"retail_extra_list: %y\", $retail_extra_list);\n\n    # check serial numbers agains scmhub for variants MIP31A[1-2]\n    my list $check_serial_src = select mapls_get_scmhub_data(), $check_serial_source_doc_hash.($1.order_id) && $1.serial_number && $vmap.($1.order_id) < 3;\n    log(LL_DEBUG_2, \"check_serial_src: %y\", $check_serial_src);\n    my *hash $cser_src;\n    if ($check_serial_src){\n        $cser_src = sepl_scmhub_ret_ser_qty_rma_src($ds, $org_name, $check_serial_src, \"RMA_RECEIPT\", \\$errh);\n        log(LL_DEBUG_1, \"retr_cser_src: %y\", $cser_src);\n    }\n\n    # check serial numbers agains scmhub for variants MIP31A3\n    my list $check_serial_src3 = select mapls_get_scmhub_data(), $check_serial_source_doc_hash.($1.order_id) && $1.serial_number && $vmap.($1.order_id) == 3;\n    log(LL_DEBUG_2, \"check_serial_src: %y\", $check_serial_src3);\n    if ($check_serial_src3) {\n        $cser_src += sepl_scmhub_ret_ser_qty_rma_src($ds, $org_name, $check_serial_src3, \"RMA_RECEIPT_UNEXP_RET_EXTRA\", \\$errh);\n    }\n\n    log(LL_DEBUG_1, \"retr_cser_src: %y\", $cser_src);\n\n    # check serial numbers agains scmhub for variants MIP31A4\n    my list $check_serial = select mapls_get_scmhub_data(), $check_serial_doc_hash.($1.order_id) && $1.serial_number;\n    log(LL_DEBUG_2, \"check_serial: %y\", $check_serial);\n    my *hash $cser;\n    if ($check_serial){\n        $cser = sepl_scmhub_ret_ser_qty_rma($ds, $org_name, $check_serial, \"RMA_RECEIPT_INTERSTORE\", \\$errh);\n        log(LL_DEBUG_1, \"retr_cser: %y\", $cser);\n    }\n\n    # get gl_account_ids\n    my list $sn_data = select mapls_get_scmhub_data(), $gl_orders.($1.order_id);\n    log(LL_DEBUG_2, \"sn_data: %y\", $sn_data);\n    # make call for gl_account_id\n    my *hash $gai;\n    if (elements $sn_data){\n        my softstring $default_gl_account_id = $props.default_gl_account_id;\n        $gai = sepl_scmhub_ret_gl_account_id($ds, $org_name, $sn_data, $default_gl_account_id, \\$errh);\n        log(LL_DEBUG_1, \"retr_gai: %y\", $gai);\n    }\n\n    # \"not ok\" record count\n    my int $nok = $errh.size();\n    \n    updateDynamicData(\n        (\n         \"info\": (\n             \"total-recs\": $data.size(),\n             \"errored-recs\": $nok,\n             \"good-recs\": $data.size() - $nok,\n         ),\n         \"errh\": $errh,\n         \"order_types\": $ot,\n         \"gl_account_id\": $gai,\n         \"retail_extra_id\": $retail_extra_list,         \n         \"check_serial\": $cser,\n         \"check_serial_src\": $cser_src,\n         \"variant\": $vmap,\n        ));\n\n    if ($nok) {\n\t    log(LL_INFO, \"transactions with scmhub errors: %d (%y)\", $nok, $errh.size());\n        # disable batch order splitting for MIP31A\n        throw \"SCMHUB-ERROR\", \"at least one transaction has a SCMHUB error\"; \n    } else {\n    \tlog(LL_INFO, \"there are no transactions with scmhub errors\");\n    }\n\n}\n","created": "2015-01-20 12:56:25.307614 +01:00","modified": "2015-01-20 12:56:25.307614 +01:00","createdby": "omq","modifiedby": "omq","tags": {},"source": "/Users/pchalupny/workspace/builds/qorus/user/31-RMA_RECEIPT/mapls_rma_receipt_scmhub_get-v1.0.qfd","offset": "6","host": "panda.local","user": "<shell-unknown>"}]},{"name": "mapls_scmhub_update","version": "1.0","author": "David Nichols (Qore Technologies, sro)","steptype": "NORMAL","stepfunction_instanceid": 58,"arraytype": "NONE","created": "2015-01-20 12:56:34.783118 +01:00","sfname": "mapls_scmhub_update","functions": [{"type": "primary","name": "mapls_scmhub_update","version": "1.0","function_instanceid": 58,"function_type": "STEP","description": "performs the updates in local staging with scmhub information","author": "David Nichols (Qore Technologies, sro)","body": "%require-types\n\nsub mapls_scmhub_update_fast(hash $props) {\n    log(LL_DETAIL_2, \"performing fast staging update\");\n\n    my *hash $dd = getDynamicData();\n\n    my softint $wfiid = getWorkflowInstanceData(\"workflow_instanceid\");\n\n    # get datasource\n    my OracleDatasourcePool $lsds($props.local_staging);\n\n    on_success $lsds.commit();\n    on_error $lsds.rollback();\n\n    foreach my string $t in ($props.tablelist) {\n        # fixed values\n        my list $fv = ();\n\n        # process fixed updates\n        my string $sql = sprintf(\"update %s set \", $t);\n        foreach my string $col in ($props.crec.$t.keyIterator()) {\n            if (!$fv.empty())\n                $sql += \", \";\n            $sql += sprintf(\"%s = %v\", $col);\n            $fv += $props.crec.$t.$col;\n        }\n\n        # process dynamic updates\n        if ($props.update.$t) {\n            my hash $uh = $props.update.$t;\n\n            foreach my string $kv in ($uh.update.keyIterator()) {\n                # skip update if row has any errors\n                if ($dd.errh.$kv) {\n                    log(LL_DEBUG_1, \"skipping update for %s = %s in %y due to errors\", $uh.column, $kv, $t);\n                    continue;\n                }\n\n                my hash $dh = $uh.update.$kv;\n                # dynamic values\n                my list $dv = $fv;\n                # dynamic sql\n                my string $dsql = $sql;\n\n                foreach my string $col in ($dh.keyIterator()) {\n                    if (!$dv.empty())\n                        $dsql += \", \";\n                    \n                    $dsql += sprintf(\"%s = %v\", $col);\n%ifdef QoreDebug\n                    # convert value to an int\n                    $dv += TableDescriptions.$t.$col.type == \"number\" ? int($dh.$col) : $dh.$col;\n%else\n                    $dv += $dh.$col;\n%endif\n                }\n\n                $dsql += sprintf(\" where %s = %v\", $uh.column);\n%ifdef QoreDebug\n                # convert value to an int\n                $dv += TableDescriptions.$t.($uh.column).type == \"number\" ? int($kv) : $kv;\n%else\n                $dv += $kv;\n%endif\n    \n                my int $rows = $lsds.vexec($dsql, $dv);\n                log(LL_DEBUG_2, \"SQL: %s args: %y rows: %d\", $dsql, $dv, $rows);\n            }\n        }\n\n        # now update all rows that can be skipped\n        my *hash $sh = $props.skip.$t;\n\n        if ($sh.values) {\n            my softlist $vl = $sh.values;\n            while ($vl) {\n                my list $tvl = extract $vl, 0, 500;\n                my softstring $sl = foldl $1 + \",\" + $2, $tvl;\n%ifdef QoreDebug\n                $lsds.exec(\"update %s set m_sepl_created_id = null, i_sepl_created_id = null, m_sepl_updated_id = %v, i_sepl_updated_id = %v, status = 'O', previous_status = 'I', m_sepl_status = 'C', i_sepl_status = 'C' where %s in (%s)\", $t, $wfiid, $wfiid, $sh.column, $sl);\n%else\n                $lsds.exec(\"update %s set m_sepl_created_id = null, i_sepl_created_id = null, m_sepl_updated_id = %v, i_sepl_updated_id = %v, status = 'O', previous_status = 'I', m_sepl_status = 'C', i_sepl_status = 'C' where %s in (SELECT regexp_substr (%v, '[^,]+', 1, lvl) as val FROM (select LEVEL lvl from dual CONNECT BY LEVEL <= ((length(%v) - length(REPLACE(%v, ',', '')))) + 1))\", $t, $wfiid, $wfiid, $sh.column, $sl, $sl, $sl);\n%endif\n                log(LL_DETAIL_1, \"updated %d row%s in %s for skipping\", $tvl.size(), $tvl.size() == 1 ? \"\" : \"s\", $t);\n            }\n            log(LL_DEBUG_1, \"skipping %s rows %s = %y\", $t, $sh.column, $sh.values);\n        }\n    }\n    \n    #log(LL_DEBUG_2, \"mapls_scmhub_update: saving data: %N\", $tdd.gsi_snr);\n}\n\nsub mapls_scmhub_update() {\n    # check if this step should be skipped\n    if (mapls_scmhub_check(NOTHING, NOTHING, True))\n        return;\n\n    my hash $props = sepl_process_update_skip_props(sepl_check_update_keys(getInstanceData()));\n\n    if ($props.no_scmhub_write)\n        return mapls_scmhub_update_fast($props);\n\n    my *hash $dd = getDynamicData();\n\n    # get temp data table data for updating temp data along with local staging\n    my hash $tdd = mapls_get_data($props, $props.local_staging);\n    #log(LL_DEBUG_2, \"mapls_scmhub_update() BEFORE data: %N\", $tdd.gsi_snr);\n\n    # hash for lookup data, keyed by table\n    my hash $lh;\n\n    my softint $wfiid = getWorkflowInstanceData(\"workflow_instanceid\");\n\n    # get datasource\n    my OracleDatasourcePool $lsds($props.local_staging);\n\n    on_success $lsds.commit();\n    on_error $lsds.rollback();\n\n    foreach my string $t in ($props.tablelist) {\n        # fixed values\n        my list $fv = ();\n\n        # process fixed updates\n        my string $sql = sprintf(\"update %s set \", $t);\n        foreach my string $col in ($props.crec.$t.keyIterator()) {\n            if (!$fv.empty())\n                $sql += \", \";\n            $sql += sprintf(\"%s = %v\", $col);\n            $fv += $props.crec.$t.$col;\n        }\n\n        # process dynamic updates\n        if ($props.update.$t) {\n            # skip all processing on the table if there is no data\n            if ($tdd.$t.empty()) {\n                log(LL_DETAIL_2, \"skipping processing table %y as there is no data\", $t);\n                continue;\n            }\n\n            my hash $uh = $props.update.$t;\n\n            # make a hash of rows already updated so that fixed updates are only applied once\n            my hash $auh;\n\n            # make sure we have a lookup hash for secondary tables (if there are more updates than rows)\n            my bool $check = ($uh.update.size() > $tdd.$t.lsize());\n            if ($check)\n                $lh.$t = mapls_get_lookup($t, $tdd.$t, $props.update_keys.$t);\n\n            foreach my string $kv in ($uh.update.keyIterator()) {\n                # skip update if row has any errors\n                if ($dd.errh.$kv) {\n                    log(LL_DEBUG_1, \"skipping update for %s = %s in %y due to errors\", $uh.column, $kv, $t);\n                    continue;\n                }\n\n                # do not make an update if there is no row\n                if ($check && !$lh.$t.$kv) {\n                    log(LL_DEBUG_1, \"skipping update for %s = %s in %y; no such row was inserted\", $uh.column, $kv, $t);\n                    continue;\n                }\n\n                my hash $dh = $uh.update.$kv;\n                # dynamic values\n                my list $dv = $fv;\n                # dynamic sql\n                my string $dsql = $sql;\n\n                foreach my string $col in ($dh.keyIterator()) {\n                    if (!$dv.empty())\n                        $dsql += \", \";\n                    \n                    $dsql += sprintf(\"%s = %v\", $col);\n%ifdef QoreDebug\n                    # convert value to an int\n                    $dv += TableDescriptions.$t.$col.type == \"number\" ? int($dh.$col) : $dh.$col;\n%else\n                    $dv += $dh.$col;\n%endif\n                }\n\n                $dsql += sprintf(\" where %s = %v\", $uh.column);\n%ifdef QoreDebug\n                # convert value to an int\n                $dv += TableDescriptions.$t.($uh.column).type == \"number\" ? int($kv) : $kv;\n%else\n                $dv += $kv;\n%endif\n                \n                log(LL_DEBUG_2, \"SQL: %s args: %y\", $dsql, $dv);\n\n                $lsds.vexec($dsql, $dv);\n\n                # update temp data table data\n                # make sure we have a lookup hash for this table\n                $lh.$t = mapls_get_lookup($t, $tdd.$t, $props.update_keys.$t);\n\n                # don't try to update if the given key does not exist in this table data\n                if (!$lh.$t.$kv.val())\n                    continue;\n\n                # update fixed values for the first update to these rows\n                if (!$auh.$kv.val()) {\n                    # mark fixed values updated\n                    $auh.$kv = True;\n\n                    # update fixed values in all rows corresponding to this key\n                    foreach my softint $i in ($lh.$t.$kv)\n                        map $tdd.$t[$i].$1 = $props.crec.$t.$1, keys $props.crec.$t;\n                }\n\n                # perform updates in all rows corresponding to this key\n                foreach my softint $i in ($lh.$t.$kv)\n                    map $tdd.$t[$i].$1 = $dh.$1, keys $dh;\n            }\n        }\n\n        # now update all rows that can be skipped\n        my *hash $sh = $props.skip.$t;\n\n        if ($sh.values) {\n            my softlist $vl = $sh.values;\n            while ($vl) {\n                my list $tvl = extract $vl, 0, 500;\n                my softstring $sl = foldl $1 + \",\" + $2, $tvl;\n%ifdef QoreDebug\n                $lsds.exec(\"update %s set m_sepl_created_id = null, i_sepl_created_id = null, m_sepl_updated_id = %v, i_sepl_updated_id = %v, status = 'O', previous_status = 'I', m_sepl_status = 'C', i_sepl_status = 'C' where %s in (%s)\", $t, $wfiid, $wfiid, $sh.column, $sl);\n%else\n                $lsds.exec(\"update %s set m_sepl_created_id = null, i_sepl_created_id = null, m_sepl_updated_id = %v, i_sepl_updated_id = %v, status = 'O', previous_status = 'I', m_sepl_status = 'C', i_sepl_status = 'C' where %s in (SELECT regexp_substr (%v, '[^,]+', 1, lvl) as val FROM (select LEVEL lvl from dual CONNECT BY LEVEL <= ((length(%v) - length(REPLACE(%v, ',', '')))) + 1))\", $t, $wfiid, $wfiid, $sh.column, $sl, $sl, $sl);\n%endif\n                log(LL_DETAIL_1, \"updated %d row%s in %s for skipping\", $tvl.size(), $tvl.size() == 1 ? \"\" : \"s\", $t);\n            }\n            log(LL_DEBUG_1, \"skipping %s rows %s = %y\", $t, $sh.column, $sh.values);\n\n            # copy all rows without the affected keys to the new table list\n            my list $l = ();\n            # see if the key column value exists in \"skiph\" (so we have an O(ln(n)) search), add it if not\n            map $l += $1, $tdd.$t, (!exists $dd.skiph.($1.($sh.column)));\n            # update the data structure\n            $tdd.$t = $l;\n            # invalidate the lookup hash for this table\n            mapls_invalidate_lookup($t);\n        }\n\n        # now finally remove errored rows from the temp data list\n        if ($dd.errh) {\n            # get the key column name\n            my string $key = $props.update_keys.$t;\n            # copy all rows without the affected keys to the new table list\n            my list $l = ();\n            # see if the key column value exists in \"errh\" (so we have an O(ln(n)) search), add it if not\n            map $l += $1, $tdd.$t, (!exists $dd.errh.($1.$key));\n            # update the data structure\n            $tdd.$t = $l;\n            # invalidate the lookup hash for this table\n            mapls_invalidate_lookup($t);\n        }\n    }\n    \n    #log(LL_DEBUG_2, \"mapls_scmhub_update: saving data: %N\", $tdd.gsi_snr);\n\n    # update temp data in case it was updated (cheap call; can make it even if it was not updated)\n    updateTempData((\"data\": $tdd));\n}\n","created": "2015-01-20 12:56:22.239228 +01:00","modified": "2015-01-20 12:56:22.239228 +01:00","createdby": "omq","modifiedby": "omq","tags": {},"source": "/Users/pchalupny/workspace/builds/qorus/user/libraries/mapls-lib-v1.0.qfd","offset": "506","host": "panda.local","user": "<shell-unknown>"}]},{"name": "mapls_scmhub_map_split","version": "1.0","author": "David Nichols (Qore Technologies, sro)","steptype": "NORMAL","stepfunction_instanceid": 62,"validationfunction_instanceid": 48,"arraytype": "NONE","created": "2015-01-20 12:56:34.783118 +01:00","sfname": "mapls_scmhub_map_split","vfname": "generic_scmhub_split_val","functions": [{"type": "primary","name": "mapls_scmhub_map_split","version": "1.0","function_instanceid": 62,"function_type": "STEP","description": "creates a child workflow if there are any errored records","author": "David Nichols (Qore Technologies, sro)","body": "%require-types\nsub mapls_scmhub_map_split() {\n    # check if this step should be skipped\n    if (mapls_scmhub_check())\n        return;\n\n    # call library function with write = False\n    mapls_scmhub_split_lib();\n}\n","created": "2015-01-20 12:56:22.256919 +01:00","modified": "2015-01-20 12:56:22.256919 +01:00","createdby": "omq","modifiedby": "omq","tags": {},"source": "/Users/pchalupny/workspace/builds/qorus/user/libraries/mapls-lib-v1.0.qfd","offset": "827","host": "panda.local","user": "<shell-unknown>"},{"type": "validation","name": "generic_scmhub_split_val","version": "1.0","function_instanceid": 48,"function_type": "VALIDATION","description": "validation for the generic global to local staging copy function","author": "David Nichols (Qore Technologies, sro)","body": "%require-types\n\nstring sub generic_scmhub_split_val() {\n    return sepl_scmhub_split_val();\n}\n","created": "2015-01-20 12:56:22.141594 +01:00","modified": "2015-01-20 12:56:22.141594 +01:00","createdby": "omq","modifiedby": "omq","tags": {},"source": "/Users/pchalupny/workspace/builds/qorus/user/libraries/generic_scmhub_split-v1.0.qfd","offset": "6","host": "panda.local","user": "<shell-unknown>"}]},{"name": "mapls_rma_receipt_scmhub","version": "1.0","author": "Marian Bonda","steptype": "NORMAL","stepfunction_instanceid": 405,"validationfunction_instanceid": 46,"arraytype": "NONE","created": "2015-01-20 12:56:46.219710 +01:00","sfname": "mapls_rma_receipt_scmhub","vfname": "generic_scmhub_batch_validation","functions": [{"type": "primary","name": "mapls_rma_receipt_scmhub","version": "1.0","function_instanceid": 405,"function_type": "STEP","description": "RMA Receipt SCM Hub update","author": "Marian Bonda","body": "%require-types\n\n#! makes the SCM Hub update\nsub mapls_rma_receipt_scmhub() {\n    \n    #! check if the order should go to error the first time or be skipped\n    if (mapls_scmhub_check(True))\n\treturn;\n\n    # setup data from global staging in temp data\n    my list $source_data = mapls_get_scmhub_data();\n\n    log(LL_DEBUG_2, \"source_data: %N\", $source_data);\n\n    # sanity check - should not happen in practice (only if there is an error in a previous step)\n    if (!$source_data)\n    \tthrow \"NO-DATA-ERROR\", \"No data to submit to SCM Hub\";\n\n    # get scmhub datasource\n    my OracleDatasourcePool $ds(\"scmhub\");\n\n    # get constant data for environment (m_sepl_.../i_sepl_...)\n    my hash $constant_data = mapls_scmhub_constant_data();\n\n    # map constant values for the subsequent scmhub call\n    my string $ss = $source_data[0].source_system;\n    my string $wh;\n    if ($ss == \"UTL\") {\n        $wh = \"UTL_UK\";\n    } else if ($ss == \"ADS\") {\n        $wh = \"ADS_IE\";\n    }\n\n    # get dynamic data\n    my hash $dd = getDynamicData();\n\n    # master hash of scmhub call args; key is transaction_id; value is a hash: func: scmhub function name, data: scmhub function data\n    my hash $args;\n\n    # scmhub result hash data structure and mip info\n    my hash $edd = (\n        \"mip\": \"31a\",\n        );\n\n    foreach my hash $row in ($source_data) {\n        # scmhub function name\n        my string $func;\n        # scmhub arg hash\n        my hash $h;\n\n        # get order type as retrieved from the SCMHUB\n        my string $ot = $dd.order_types.($row.order_id);\n \n        # to recover old order data before the change to find the variant in the scmhub_get step\n        if (!$dd.variant.$ot) {\n            # get the variant number for this order\n            $dd.variant.$ot = VariantMap.$ot;\n            if (!$dd.variant.$ot)\n                throw \"UNKNOWN-ORDER-TYPE\", sprintf(\"cannot process unknown order type %y for order_id %y\", $ot, $row.order_id);\n        }\n       \n        switch ($dd.variant.$ot) {\n            \n            # MIP31A variant 1\n            # Capture Execution Transaction against Execution Document Source with line reference\n            case 1:\n\n            # MIP31A variant 2\n            # Capture Execution Transaction against Execution Document Source with line reference\n            case 2: {\n                $func = \"scm-capt_trx_agn_ex_doc_src\";\n                $h = (\n                    \"LEGAL_ENTITY_CODE\"       : $row.org_name,             # mapped from GSI_BREP_TRANS\n                    \"OPER_PARTY_CODE\"         : $row.source_system,        # mapped from GSI_BREP_TRANS\n                    \"PARTY_TYPE\"              : \"SCM PARTNER\",             # Constant\n                    \"WAREHOUSE_USAGE_CODE\"    : $wh,                       # Constant\n                    \"STORAGE_AREA_CODE\"       : $row.subinventory,         # from GSI_BREP_TRANS\n                    \"TRX_TYPE_CODE\"           : $row.message_type,         # from GSI_BREP_TRANS\n                    \"DOC_HEADER_SYS_REF\"      : $row.order_id,             # from GSI_BREP_TRANS\n                    \"EXECUTED_LINE_NUMBER\"    : $row.line_number,          # from GSI_BREP_TRANS        \n                    \"FLOW\"                    : \"SUPPLY\",                  # Constant\n                    \"ITEM_NUMBER\"             : $row.item_number,          # from GSI_BREP_TRANS\n                    \"EFFECTIVE_DATE\"          : $row.status_date,          # from GSI_BREP_TRANS\n                    \"QUANTITY\"                : $row.dispatched_quantity,  # from GSI_BREP_TRANS\n                    \"UOM\"                     : \"EA\",                      # Constant\n                    \"SOURCE_SYSTEM_REFERENCE\" : $row.order_id,             # from GSI_BREP_TRANS\n                    \"ITEM_REVISION\"           : $row.revision,             # from GSI_BREP_TRANS\n                    \"SERIAL_NUMBER\"           : $row.serial_number,\t   # from GSI_SNR\n                    \"QORUS_LINE_ID\"           : sprintf(\"%s%s\", $row.transaction_id, $row.line_number),\n                    \"QORUS_ROW_ID\"            : $#,                    \n                    ) + $constant_data;\n                break;\n            }\n\n            # MIP31A variant 3 (Unexpected retail return UK & IE, Internal Return)\n            # Capture Execution Transaction against Execution Document Source with line reference and Status C\n            case 3: {\n                $func = \"scm-capt_trx_agn_ex_doc_src_withc\";\n                $h = (\n                    \"LEGAL_ENTITY_CODE\"       : $row.org_name,             # mapped from GSI_BREP_TRANS\n                    \"OPER_PARTY_CODE\"         : $row.source_system,        # mapped from GSI_BREP_TRANS\n                    \"PARTY_TYPE\"              : \"SCM PARTNER\",             # Constant\n                    \"WAREHOUSE_USAGE_CODE\"    : $wh,                       # Constant\n                    \"STORAGE_AREA_CODE\"       : $row.subinventory,         # from GSI_BREP_TRANS\n                    \"TRX_TYPE_CODE\"           : \"RMA_RECEIPT_UNEXP_RET_EXTRA\",  # from GSI_BREP_TRANS\n                    \"DOC_HEADER_SYS_REF\"      : $row.order_id,             # from GSI_BREP_TRANS\n                    \"EXECUTED_LINE_NUMBER\"    : $row.line_number,          # from GSI_BREP_TRANS        \n                    \"FLOW\"                    : \"SUPPLY\",                  # Constant\n                    \"ITEM_NUMBER\"             : $row.item_number,          # from GSI_BREP_TRANS\n                    \"EFFECTIVE_DATE\"          : $row.status_date,          # from GSI_BREP_TRANS\n                    \"QUANTITY\"                : $row.dispatched_quantity,  # from GSI_BREP_TRANS\n                    \"UOM\"                     : \"EA\",                      # Constant\n                    \"SOURCE_SYSTEM_REFERENCE\" : $row.order_id,             # from GSI_BREP_TRANS\n                    \"ITEM_REVISION\"           : $row.revision,             # from GSI_BREP_TRANS\n                    \"SERIAL_NUMBER\"           : $row.serial_number,\t       # from GSI_SNR\n                    \"MSISDN\"                  : $row.msisdn,               # from GSI_SNR\n                    \"QORUS_LINE_ID\"           : sprintf(\"%s%s\", $row.transaction_id, $row.line_number),\n                    \"QORUS_ROW_ID\"            : $#,                    \n                    ) + $constant_data;\n                break;\n            }\n\n            # MIP31A variant 4 (InterOrgtransfer UK and IE)\n            # Capture Execution Transaction against Document with line reference\n            case 4: {\n                $func = \"scm-capt_ins_tr_agn_doc\";\n                $h = (\n                    \"LEGAL_ENTITY\"             : $row.org_name,\n                    \"OPER_PARTY\"               : $row.source_system,\n                    \"PARTY_TYPE\"               : \"SCM PARTNER\",\n                    # storage area info\n                    \"WAREHOUSE_USAGE_CODE\"     : $wh,\n                    \"STORAGE_AREA\"             : $row.subinventory,\n                    \"TRX_TYPE\"                 : \"RMA_RECEIPT_INTERSTORE\", #$row.message_type,\n                    \"DOC_HEADER_SYS_REF\"       : $row.order_id,\n                    \"DOC_LINE_SYS_REF\"         : $row.line_number,\n                    \"FLOW\"                     : \"SUPPLY\",\n                    \"ITEM_NUMBER\"              : $row.item_number,\n                    \"EFFECTIVE_DATE\"           : $row.status_date,\n                    \"QUANTITY\"                 : $row.dispatched_quantity,\n                    \"UOM\"                      : \"EA\",\n                    \"SOURCE_SYSTEM_REFERENCE\"  : $row.order_id,\n                    #\"ITEM_REVISION\"            : NOTHING,\n                    \"SERIAL_NUMBER\"            : $row.serial_number,\n                    \"MSISDN\"                   : $row.msisdn,\n                    #\"PAIR_SERIAL_NUMBER\"       : NOTHING,\n                    \"QORUS_ROW_ID\"            : $#,\n                    ) + $constant_data;\n                break;\n            }\n\n            default:\n            # this should never happen since order types and variants are processed in the scmhub_get step\n                throw \"UNKNOWN-ORDER-TYPE\", sprintf(\"cannot process order type %y for order_id %y MIP 31a variant %y\", $ot, $row.order_id, $dd.variant.$ot);\n        }\n\n        my softstring $tid = $row.transaction_id;\n        # add data to master arg hash\n        if (!$args.$tid)\n            $args.$tid = (\n                \"func\": $func,\n                \"data\": (),\n            );\n        $args.$tid.data += $h;\n    }\n\n    # document counter\n    my int $doc = 0;\n\n    # commit and rollback\n    on_success $ds.commit();\n    on_error $ds.rollback();\n\n    # make SCM Hub calls\n    my HashIterator $hi($args);\n    while ($hi.next()) {\n        my (string $f, list $data) = $hi.getValue().(\"func\", \"data\").values();\n        \n        # get transaction ID\n        my softstring $tid = $hi.getKey();\n\n        # get savepoint name for this transaction\n        #my string $sp = sprintf(\"sp_%d\", $tid);\n\n        log(LL_INFO, \"executing subtransaction sp_%d for transaction_id %y function: %y records: %d\", $tid, $tid, $f, $data.size());\n\n        #try {\n            # create savepoint for this transaction\n            #$ds.exec(\"savepoint %s\", $sp);\n            \n            # STEP 2: call Capture Transaction against Document\n%ifdef QoreDebug\n            $edd.scmhub.$tid.$f = sepl_fake_scmhub_call($f, $data);\n%else\n            $edd.scmhub.$tid.$f = sepl_exec_scmhub_nocommit($ds, $f, $data);\n%endif\n            # any errors cause the subtransaction to fail and get rolled back\n            sepl_scmhub_verify_ret_hash($data, $edd.scmhub.$tid.$f, $f);    \n\n            ++$doc;\n            log(LL_INFO, \"transaction_id %y successfully posted to the SCMHUB\", $tid);\n        #}\n        #catch (hash $ex) {\n            # make sure and log the error\n            #swarning(SCMHUB_ERROR_INFO, sprintf(\"%s: %s: data: %N\", $ex.err, $ex.desc, $data));\n                     \n            # if we have lost the connection (ex: failover error), then rethrow the exception (step should get a retry)\n            #if (!$ds.inTransaction())\n            #    rethrow;\n\n            # rollback subtransaction\n            #$ds.exec(\"rollback to %s\", $sp);\n\n            # mark transaction_id as failed\n            #$edd.errh_write.$tid = True;\n\n            # add associated close and confirm transaction_ids\n            #$edd.errh_write.$tid = True;\n\n            #log(LL_INFO, \"rolled back transaction to savepoint for transaction_id %y in the scmhub due to errors\", $tid);        \n            \n            \n        #}\n    }\n\n    # if none of the documents has gone through, then we have to ensure the whole step goes to ERROR\n    if (!$doc) {\n        log(LL_IMPORTANT, \"no documents were successfully posted to the SCM-HUB; the entire step will go to ERROR\");\n        throw \"SCMHUB-ERROR\", sprintf(\"all documents failed in the SCMHUB; transaction_ids affected: %y\", $args.keys());\n    }\n\n    updateDynamicData($edd);\n\n    log(LL_INFO, \"committed %d/%d documents to the scmhub\", $doc, $args.size());\n}\n","created": "2015-01-20 12:56:25.345152 +01:00","modified": "2015-01-20 12:56:25.345152 +01:00","createdby": "omq","modifiedby": "omq","tags": {},"source": "/Users/pchalupny/workspace/builds/qorus/user/31-RMA_RECEIPT/mapls_rma_receipt_scmhub-v1.0.qfd","offset": "7","host": "panda.local","user": "<shell-unknown>"},{"type": "validation","name": "generic_scmhub_batch_validation","version": "1.0","function_instanceid": 46,"function_type": "VALIDATION","description": "validates scmhub calls so they are not repeated twice","author": "David Nichols (Qore Technologies, sro)","body": "%require-types\n\nstring sub generic_scmhub_batch_validation() {\n    # FIXME: implement\n    return OMQ::StatRetry;\n}\n","created": "2015-01-20 12:56:22.131498 +01:00","modified": "2015-01-20 12:56:22.131498 +01:00","createdby": "omq","modifiedby": "omq","tags": {},"source": "/Users/pchalupny/workspace/builds/qorus/user/libraries/generic_scmhub_batch_validation-v1.0.qfd","offset": "6","host": "panda.local","user": "<shell-unknown>"}]},{"name": "mapls_scmhub_write_split","version": "1.0","author": "David Nichols (Qore Technologies, sro)","steptype": "NORMAL","stepfunction_instanceid": 59,"validationfunction_instanceid": 64,"arraytype": "NONE","created": "2015-01-20 12:56:34.783118 +01:00","sfname": "mapls_scmhub_write_split","vfname": "mapls_scmhub_write_split_val","functions": [{"type": "primary","name": "mapls_scmhub_write_split","version": "1.0","function_instanceid": 59,"function_type": "STEP","description": "performs the updates in local staging and the creation of a child workflow for errored records","author": "David Nichols (Qore Technologies, sro)","body": "%require-types\nsub mapls_scmhub_write_split() {\n    # check if this step should be skipped\n    if (mapls_scmhub_check())\n        return;\n\n    # call library function with write = True\n    mapls_scmhub_split_lib(\"write\");\n}\n","created": "2015-01-20 12:56:22.245486 +01:00","modified": "2015-01-20 12:56:22.245486 +01:00","createdby": "omq","modifiedby": "omq","tags": {},"source": "/Users/pchalupny/workspace/builds/qorus/user/libraries/mapls-lib-v1.0.qfd","offset": "779","host": "panda.local","user": "<shell-unknown>"},{"type": "validation","name": "mapls_scmhub_write_split_val","version": "1.0","function_instanceid": 64,"function_type": "VALIDATION","description": "validation for error splitting in scmhub write steps","author": "David Nichols (Qore Technologies, sro)","body": "%require-types\n\nstring sub mapls_scmhub_write_split_val() {\n    return sepl_scmhub_split_val(\"parent_write\");\n}\n","created": "2015-01-20 12:56:22.267576 +01:00","modified": "2015-01-20 12:56:22.267576 +01:00","createdby": "omq","modifiedby": "omq","tags": {},"source": "/Users/pchalupny/workspace/builds/qorus/user/libraries/mapls-lib-v1.0.qfd","offset": "891","host": "panda.local","user": "<shell-unknown>"}]},{"name": "mapls_update_order_id","version": "1.0","author": "Marian Bonda","steptype": "NORMAL","stepfunction_instanceid": 403,"arraytype": "NONE","created": "2015-01-20 12:56:46.219710 +01:00","sfname": "mapls_update_order_id","functions": [{"type": "primary","name": "mapls_update_order_id","version": "1.0","function_instanceid": 403,"function_type": "STEP","description": "MIP31 step to update order_id","author": "Marian Bonda","body": "%require-types\n\n#! makes the SCM Hub update\nsub mapls_update_order_id() {\n\n    return;\n\n    # disabling this step, due to changes in the specification    \n/*\n    # do this only for INEM workflows GB130461\n    if (!(getWorkflowMetadata().name =~ /INEM-IN/)){\n        log(LL_INFO, \"this is no INEM workflow, skipping order_id update\");\n        return;\n    }\n\n    # check if this step should be skipped\n    if (mapls_scmhub_check())\n        return;\n  \n    # get instance properties\n    my hash $props = getInstanceData();\n\n    # get our wfiid\n    my softint $wfiid = getWorkflowInstanceData(\"workflow_instanceid\");\n\n    # get datasource\n    my OracleDatasourcePool $lsds($props.local_staging);\n\n    on_success $lsds.commit();\n    on_error $lsds.rollback();\n\n   # make SCM Hub calls\n    my HashIterator $hi(getDynamicData(\"scmhub\"));\n    while ($hi.next()) {\n\n        my softstring $tid = $hi.getKey();\n        my softstring $oid = $hi.getValue().firstValue().x_param_out[0].ID;\n\tmy int $rows = $lsds.exec(\"UPDATE gsi_brep_trans SET order_id = %v WHERE transaction_id = %v AND i_sepl_created_id = %v\", int($oid), int($tid), $wfiid);\n\tlog(LL_INFO, \"updated local staging (%s row(s)): UPDATE gsi_brep_trans SET order_id = %s WHERE transaction_id = %s and i_sepl_created_id = %d\", $rows, int($oid), int($tid), $wfiid);\n\n    }\n*/\n}\n","created": "2015-01-20 12:56:25.315564 +01:00","modified": "2015-01-20 12:56:25.315564 +01:00","createdby": "omq","modifiedby": "omq","tags": {},"source": "/Users/pchalupny/workspace/builds/qorus/user/31-RMA_RECEIPT/mapls_update_order_id-v1.0.qfd","offset": "5","host": "panda.local","user": "<shell-unknown>"}]},{"name": "mapls_update_complete","version": "1.0","author": "David Nichols (Qore Technologies, sro)","steptype": "NORMAL","stepfunction_instanceid": 63,"arraytype": "NONE","created": "2015-01-20 12:56:34.783118 +01:00","sfname": "mapls_update_complete","functions": [{"type": "primary","name": "mapls_update_complete","version": "1.0","function_instanceid": 63,"function_type": "STEP","description": "generic update to local staging: update status = 'N' based on the i_sepl_created_id column","author": "David Nichols (Qore Technologies, sro)","body": "%require-types\n\nsub mapls_update_complete() {\n    # check if this step should be skipped\n    if (mapls_scmhub_check())\n        return;\n\n    # get instance properties\n    my hash $props = getInstanceData();\n\n    my string $status = $props.final_ls_status ? $props.final_ls_status : \"N\";\n\n    # get our wfiid\n    my softint $wfiid = getWorkflowInstanceData(\"workflow_instanceid\");\n\n    # get datasource\n    my OracleDatasourcePool $lsds($props.local_staging);\n\n    on_success $lsds.commit();\n    on_error $lsds.rollback();\n\n    my *hash $dd = getDynamicData();\n\n    # update rows in local staging with the wfiid given\n    foreach my string $t in ($props.tablelist) {\n        # update rows for skipping if necessary\n        my *hash $sh = $dd.complete_skip.$t;\n\n        if ($sh.values) {\n            my softstring $sl = foldl $1 + \",\" + $2, $sh.values;\n%ifdef QoreDebug\n            my int $rows = $lsds.exec(\"update %s set m_sepl_created_id = null, i_sepl_created_id = null, m_sepl_updated_id = %v, i_sepl_updated_id = %v, status = 'O', previous_status = 'I', m_sepl_status = 'C', i_sepl_status = 'C' where %s in (%s)\", $t, $wfiid, $wfiid, $sh.column, $sl);\n%else\n            my int $rows = $lsds.exec(\"update %s set m_sepl_created_id = null, i_sepl_created_id = null, m_sepl_updated_id = %v, i_sepl_updated_id = %v, status = 'O', previous_status = 'I', m_sepl_status = 'C', i_sepl_status = 'C' where %s in (SELECT regexp_substr (%v, '[^,]+', 1, lvl) as val FROM (select LEVEL lvl from dual CONNECT BY LEVEL <= ((length(%v) - length(REPLACE(%v, ',', '')))) + 1))\", $t, $wfiid, $wfiid, $sh.column, $sl, $sl, $sl);\n%endif\n            log(LL_INFO, \"skipping: updated local staging: %s %d row%s with status = 'O' where i_sepl_created_id = %d\", $t, $rows, $rows == 1 ? \"\" : \"s\", $wfiid);\n        }\n\n\tmy int $rows = $lsds.exec(\"update %s set status = %v, previous_status = 'I', m_sepl_status = 'C', i_sepl_status = 'C' where status = 'I' and i_sepl_created_id = %v\", $t, $status, $wfiid);\n\tlog(LL_INFO, \"complete: updated local staging: %s %d row%s with status = '%s' where i_sepl_created_id = %d\", $t, $rows, $rows == 1 ? \"\" : \"s\", $status, $wfiid);\n    }    \n}\n","created": "2015-01-20 12:56:22.263433 +01:00","modified": "2015-01-20 12:56:22.263433 +01:00","createdby": "omq","modifiedby": "omq","tags": {},"source": "/Users/pchalupny/workspace/builds/qorus/user/libraries/mapls-lib-v1.0.qfd","offset": "843","host": "panda.local","user": "<shell-unknown>"}]},{"name": "mapls_rma_trigger_mip32","version": "1.0","author": "Marian Bonda","steptype": "SUBWORKFLOW","stepfunction_instanceid": 408,"arraytype": "NONE","created": "2015-01-20 12:56:46.219710 +01:00","sfname": "mapls_rma_trigger_mip32","functions": [{"type": "primary","name": "mapls_rma_trigger_mip32","version": "1.0","function_instanceid": 408,"function_type": "STEP","description": "trigger MIP32","author": "Marian Bonda","body": "%require-types\n%require-our\n\nsub mapls_rma_trigger_mip32() {    \n    my hash $props = getInstanceData();\n\n    # MIP32 should be triggered only if order type is Internal Return or Retail Return\n    my HashIterator $ot(getDynamicData(\"order_types\"));\n    my bool $createMIP32 = False;\n    while ($ot.next()) {   \n        # there will be no MIP32 triggered from MIP31 for order_type 'Internal Return', \n        # since MIP31 inserts the message_type 'INV_STOCK_ADJ' passed from the gl_account_id lookup already\n        if ($ot.getValue() == \"WOM Retail Extra\" || $ot.getValue() == \"WOM IE RETAIL EXTRA RETURN\"){\n            # mip32 triggering was exchanged for updating the gl_account_id in the LS by this workflow\n            #$createMIP32 = True;\n        }\n    }\n    if (!$createMIP32){\n        #log(LL_INFO, \"no 'WOM IE RETAIL EXTRA RETURN' or 'WOM Retail Extra' found; skipping %s creation\", $props.mip32_wf);\n        log(LL_INFO, \"skipping %s creation\", $props.mip32_wf);\n        skipSubWorkflow();\n        return;\n    }\n\n    # skip creating an order if this wf did not create any global staging rows\n    if (getDynamicData(\"skip-local-staging\")) {\n\tlog(LL_INFO, \"no global staging rows were created; skipping %s creation\", $props.mip32_wf);\n\treturn;\n    }\n\n    my hash $data = getStaticData();\n    $data.mip31_misc_transaction = True;\n\n    # create order hash\n    my hash $ord = (\n\t\"staticdata\": $data,\n\t);\n\n    log(LL_INFO, \"binding subworkflow %s\", $props.mip32_wf);\n    # bind subworkflow\n    bindSubWorkflow((\"name\": $props.mip32_wf), $ord);\n  \n}\n","created": "2015-01-20 12:56:25.365300 +01:00","modified": "2015-01-20 12:56:25.365300 +01:00","createdby": "omq","modifiedby": "omq","tags": {},"source": "/Users/pchalupny/workspace/builds/qorus/user/31-RMA_RECEIPT/mapls_rma_receipt_tigger_flows-v1.0.qfd","offset": "103","host": "panda.local","user": "<shell-unknown>"}]},{"name": "mapls_rma_trigger_mip37","version": "1.0","author": "Marian Bonda","steptype": "NORMAL","stepfunction_instanceid": 409,"validationfunction_instanceid": 410,"arraytype": "NONE","created": "2015-01-20 12:56:46.219710 +01:00","sfname": "mapls_rma_trigger_mip37","vfname": "mapls_rma_trigger_mip37_val","functions": [{"type": "primary","name": "mapls_rma_trigger_mip37","version": "1.0","function_instanceid": 409,"function_type": "STEP","description": "trigger MIP37","author": "Marian Bonda","body": "%require-types\n%require-our\n\nsub mapls_rma_trigger_mip37() {    \n    my hash $props = getInstanceData();\n\n    # MIP32 should be triggered only if order type is Internal Return or Retail Return\n    my HashIterator $ot(getDynamicData(\"order_types\"));\n    my bool $createMIP37 = False;\n    while ($ot.next()) { \n        if ($ot.getValue() == \"WOM H3G Retail Return\" || $ot.getValue() == \"WOM IE RETAIL RETURN\") {\n            $createMIP37 = True;\n            break;\n        }\n    }\n    if (!$createMIP37){\n        log(LL_INFO, \"no 'WOM H3G Retail Return' or 'WOM IE RETAIL RETURN' found; skipping %s triggering\", $props.mip37_wf);        \n        return;\n    }\n\n    # skip creating an order if this wf did not create any global staging rows\n    if (getDynamicData(\"skip-local-staging\")) {\n\t    log(LL_INFO, \"no global staging rows were created; skipping %s creation\", $props.mip37_wf);\n\t    return;\n    }\n\n    # get this wfiid\n    my softint $wfiid = getWorkflowInstanceData(\"workflow_instanceid\");\n\n    my hash $sd = getStaticData();\n    my hash $data.uuid = $sd.uuid;\n\n    my hash $nsd = $data + \n\t(\"filename\": $sd.filename, \n\t \"msepl\": $sd.msepl, \n\t \"msepl_instance\": $sd.msepl_instance,\n\t \"created_by\": getWorkflowInstanceData(\"name\"),\n\t \"source_wfiid\": $wfiid,\n     \"source_message_type\": \"RMA_INTERNAL_DOM_WOM\",\n     \"source_mip\": 31,\n\t);\n\n    # if there is additional static data to add, then add it\n    my *hash $dd = getDynamicData();\n    if (exists $dd.gsls)\n\t$nsd += $dd.gsls;\n\n    my hash $h = (\n\t\"staticdata\": $nsd,\n\t#\"orderkeys\": (\"source_wfiid\": $wfiid),\n\t\"parent_workflow_instanceid\": $wfiid,\n\t);\n\n    $wfiid = createOrder($props.mip37_wf, NOTHING, $h);\n    log(LL_INFO, \"created %s wfiid %d\", $props.mip37_wf, $wfiid);\n   \n}\n","created": "2015-01-20 12:56:25.372914 +01:00","modified": "2015-01-20 12:56:25.372914 +01:00","createdby": "omq","modifiedby": "omq","tags": {},"host": "panda.local","source": "/Users/pchalupny/workspace/builds/qorus/user/31-RMA_RECEIPT/mapls_rma_receipt_tigger_flows-v1.0.qfd","offset": "154","user": "<shell-unknown>"},{"type": "validation","name": "mapls_rma_trigger_mip37_val","version": "1.0","function_instanceid": 410,"function_type": "VALIDATION","description": "trigger MIP37 validation","author": "Marian Bonda","body": "%require-types\n%require-our\n\nstring sub mapls_rma_trigger_mip37_val() {    \n\n    my hash $props = getInstanceData();\n\n    # get this wfiid\n    my softint $wfiid = getWorkflowInstanceData(\"workflow_instanceid\");\n\n    log(LL_DEBUG_2, \"mip 37 wf: %s\", $props.mip37_wf);\n\n    # get version\n    my string $ver = $omqservice.system.omqmap.rlookupworkflow($props.mip37_wf).lastversion;\n\n    # see if this workflow order already exists\n    my list $l;\n    try {\n\t$l = $omqservice.system.info.getOrderInfoFromKey($props.mip37_wf, $ver, \"source_wfiid\", $wfiid);\n    }\n    catch ($ex) {\n\tif ($ex.err == \"UNKNOWN-KEY-VALUE\")\n\t    $l = ();\n\telse\n\t    rethrow;\n    }\n\n    if (!elements $l) {\n\tlog(LL_INFO, \"validation indicates that no %s v%s order has been created yet for this order\", $props.mip37_wf, $ver);\n\treturn OMQ::StatRetry;\n    }\n\n    if (elements $l != 1)\n\tthrow \"VALIDATION-ERROR\", sprintf(\"unexpected answer received from call to system.info.getOrderInfoFromKey(%y, %y, \\\"msepl_wfiid\\\", %y): %y\", $props.mip37_wf, $ver, $wfiid, $l);\n\n    log(LL_INFO, \"validation indicates that %s v%s wfiid %d already exists for this order, returning COMPLETE\", $props.mip37_wf, $ver, $l[0].workflow_instanceid);\n    return OMQ::StatComplete;\n   \n}\n","created": "2015-01-20 12:56:25.378854 +01:00","modified": "2015-01-20 12:56:25.378854 +01:00","createdby": "omq","modifiedby": "omq","tags": {},"source": "/Users/pchalupny/workspace/builds/qorus/user/31-RMA_RECEIPT/mapls_rma_receipt_tigger_flows-v1.0.qfd","offset": "218","host": "panda.local","user": "<shell-unknown>"}]},{"name": "mapls_rma_create_mip21_data","version": "1.0","author": "Marian Bonda, David Nichols","steptype": "NORMAL","stepfunction_instanceid": 415,"validationfunction_instanceid": 414,"arraytype": "NONE","created": "2015-01-20 12:56:46.219710 +01:00","sfname": "mapls_rma_create_mip21_data","vfname": "mapls_rma_create_mip21_data_val","functions": [{"type": "primary","name": "mapls_rma_create_mip21_data","version": "1.0","function_instanceid": 415,"function_type": "GENERIC","description": "MIP 31 -> 21 GSI_COMMISSIONING population function","author": "Marian Bonda, David Nichols","body": "%require-types\n\n#! takes a hash of transaction_ids -> (\"oid\": order_id, \"line\": line_number, \"item\": item_number) and returns a hash: <order_id> \".\" <line_number> -> (\"order_type\": xxx, \"dealer_code\": xxx, \"reason_code\": xxx) and processes the error hash appropriately\nhash sub sepl_scmhub_ret_com_inf_mip31a3(object $ds, string $org_name, string $op_party, hash $data_hash, reference $errh) {\n    log(LL_DETAIL_1, \"sepl_scmhub_ret_com_inf_mip31a3() about to look up %d items\", $data_hash.size());\n\n    # scmhub call data list\n    my list $data = ();\n    {\n        my HashIterator $hi($data_hash);\n        while ($hi.next()) {\n            my softint $tid = $hi.getKey();\n            my hash $h = $hi.getValue();\n            $data += (\n                \"LEGAL_ENTITY\": $org_name,\n                \"OPERATING_PARTY\": $op_party,\n                \"PARTY_TYPE\": \"SCM PARTNER\",\n                \"TRANSACTION_TYPE\": \"RMA_RECEIPT\",\n                \"DOC_SRC_HEADER_EXEC_SYS_REF\": $h.oid,\n                \"DOC_SRC_LINE_EXEC_LINE_NUM\": $h.line,\n                \"ITEM_NUMBER\": $h.item,\n                \"QORUS_ROW_ID\": $tid,\n\t    );\n        }\n    }\n\n    my string $f = \"scm-ret_com_inf_mip31a3\";\n    my hash $ret;\n\n%ifdef QoreDebug\n    # fake response list\n    my list $fl = ();\n    # error count\n    my int $ec = 0;\n    my bool $do_errs = !parse_boolean(getInstanceData(\"no-scmhub-errors\"));\n    foreach my softstring $tid in (keys $data_hash) {\n        my hash $h = (\n            \"QORUS_ROW_ID\": $tid,\n            );\n\t# 10% chance of error on every record\n\tif ($do_errs && !(rand() % 10)) {\n            $h += (\n                \"ORACLE_ORDER_TYPE\": NULL,\n                \"DEALER_CODE\": NULL,\n                \"REASON_CODE\": NULL,\n                \"STATUS\": \"E\",\n                \"ERROR_MSG\": NULL,\n                );\n\t    ++$ec;\n        }\n\telse {\n            $h += (\n                \"ORACLE_ORDER_TYPE\": $org_name == \"UK_OPCO\" ? \"WOM UK Return Order\" : \"DOM IE EXCHANGE Return\",\n                \"DEALER_CODE\": \"dealer123\",\n                \"REASON_CODE\": \"oops\",\n                \"STATUS\": \"C\",\n                \"ERROR_MSG\": NULL,\n\t      );\n\t}\n        $fl += $h;\n    }\n\n    $ret = (\n\t\"x_status\": list((\"STATUS_CODE\": 0, \"ERROR_CODE\": NULL, \"ERROR_DESCRIPTION\": NULL)),\n\t\"x_param_out\": $fl,\n\t);\n\n    log(LL_INFO, \"FAKE_SCMHUB: generated %d correct, %d errors, %d total in fake %s response\", elements $fl - $ec, $ec, elements $fl, $f);\n    log(LL_DEBUG_2, \"data: %N\", $data);\n    log(LL_DEBUG_2, \"ret: %N\", $ret);\n%else\n    $ret = sepl_exec_scmhub($ds, $f, $data);\n%endif\n\n    $errh += sepl_scmhub_check_ret_hash($data, $ret, True, $f);\n\n    # create return hash and check for lookup failures\n    my hash $rv = hash();\n    foreach my hash $h in ($ret.x_param_out) {\n        my softstring $tid = $h.QORUS_ROW_ID;\n        my hash $rh = $data_hash.$tid;\n        if ($h.STATUS != \"C\" || !$h.ORACLE_ORDER_TYPE) {\n            swarning(SCMHUB_ERROR_INFO, sprintf(\"SCM-HUB retrieve doc line failed for order_id %y, line_number %y, transaction_id %y (result: %y)\", $rh.oid, $rh.line, $tid, $h));\n\n            # set transaction hash keys to True in error hash\n            $errh.$tid = True;\n        } else\n            $rv.($rh.oid + \".\" + $rh.line) = (\n                \"order_type\": $h.ORACLE_ORDER_TYPE,\n                \"dealer_code\": $h.DEALER_CODE,\n                \"reason_code\": $h.REASON_CODE,\n                \"type\": \"mip31a3\",\n            );\n    }\n\n    return $rv;\n}\n\n#! takes a hash of transaction_ids -> (\"oid\": order_id, \"line\": line_number, \"item\": item_number) and returns a hash: <order_id> \".\" <line_number> -> (\"order_type\": xxx, \"dealer_code\": xxx, \"reason_code\": xxx) and processes the error hash appropriately\nhash sub sepl_scmhub_ret_com_inf_mip31a4(object $ds, string $org_name, string $op_party, hash $data_hash, reference $errh) {\n    log(LL_DETAIL_1, \"sepl_scmhub_ret_com_inf_mip31a4() about to look up %d items\", $data_hash.size());\n\n    # scmhub call data list\n    my list $data = ();\n    {\n        my HashIterator $hi($data_hash);\n        while ($hi.next()) {\n            my softint $tid = $hi.getKey();\n            my hash $h = $hi.getValue();\n            $data += (\n                \"LEGAL_ENTITY\": $org_name,\n                \"OPERATING_PARTY\": $op_party,\n                \"PARTY_TYPE\": \"SCM PARTNER\",\n                \"TRANSACTION_TYPE\": \"RMA_RECEIPT_INTERSTORE\",\n                \"DOC_HEADER_SYS_REF\": $h.oid,\n                \"DOC_LINE_SYS_REF\": $h.line,\n                \"ITEM_NUMBER\": $h.item,\n                \"QORUS_ROW_ID\": $tid,\n\t    );\n        }\n    }\n\n    my string $f = \"scm-ret_com_inf_mip31a4\";\n    my hash $ret;\n\n%ifdef QoreDebug\n    # fake response list\n    my list $fl = ();\n    # error count\n    my int $ec = 0;\n    my bool $do_errs = !parse_boolean(getInstanceData(\"no-scmhub-errors\"));\n    foreach my softstring $tid in (keys $data_hash) {\n        my hash $h = (\n            \"QORUS_ROW_ID\": $tid,\n            );\n\t# 10% chance of error on every record\n\tif ($do_errs && !(rand() % 10)) {\n            $h += (\n                \"ORACLE_ORDER_TYPE\": NULL,\n                \"DEALER_CODE\": NULL,\n                \"REASON_CODE\": NULL,\n                \"STATUS\": \"E\",\n                \"ERROR_MSG\": NULL,\n                );\n\t    ++$ec;\n        }\n\telse {\n            $h += (\n                \"ORACLE_ORDER_TYPE\": $org_name == \"UK_OPCO\" ? \"WOM UK Return Order\" : \"DOM IE EXCHANGE Return\",\n                \"DEALER_CODE\": \"dealer123\",\n                \"REASON_CODE\": \"oops\",\n                \"STATUS\": \"C\",\n                \"ERROR_MSG\": NULL,\n\t      );\n\n\t}\n        $fl += $h;\n    }\n\n    $ret = (\n\t\"x_status\": list((\"STATUS_CODE\": 0, \"ERROR_CODE\": NULL, \"ERROR_DESCRIPTION\": NULL)),\n\t\"x_param_out\": $fl,\n\t);\n\n    log(LL_INFO, \"FAKE_SCMHUB: generated %d correct, %d errors, %d total in fake %s response\", elements $fl - $ec, $ec, elements $fl, $f);\n    log(LL_DEBUG_2, \"data: %N\", $data);\n    log(LL_DEBUG_2, \"ret: %N\", $ret);\n%else\n    $ret = sepl_exec_scmhub($ds, $f, $data);\n%endif\n\n    $errh += sepl_scmhub_check_ret_hash($data, $ret, True, $f);\n\n    # create return hash and check for lookup failures\n    my hash $rv = hash();\n    foreach my hash $h in ($ret.x_param_out) {\n        my softstring $tid = $h.QORUS_ROW_ID;\n        my hash $rh = $data_hash.$tid;\n        if ($h.STATUS != \"C\" || !$h.ORACLE_ORDER_TYPE) {\n            swarning(SCMHUB_ERROR_INFO, sprintf(\"SCM-HUB retrieve doc line failed for order_id %y, line_number %y, transaction_id %y (result: %y)\", $rh.oid, $rh.line, $tid, $h));\n\n            # set transaction hash keys to True in error hash\n            $errh.$tid = True;\n        } else\n            $rv.($rh.oid + \".\" + $rh.line) = (\n                \"order_type\": $h.ORACLE_ORDER_TYPE,\n                \"dealer_code\": $h.DEALER_CODE,\n                \"reason_code\": $h.REASON_CODE,\n                \"type\": \"mip31a4\",\n            );\n    }\n\n    return $rv;\n}\n\n#! takes a hash of transaction_ids -> (\"oid\": order_id, \"line\": line_number, \"item\": item_number) and returns a hash: <order_id> \".\" <line_number> -> (\"order_type\": xxx, \"dealer_code\": xxx, \"reason_code\": xxx) and processes the error hash appropriately\nhash sub sepl_scmhub_ret_com_inf_mip31b(object $ds, string $org_name, string $op_party, hash $data_hash, reference $errh) {\n    log(LL_DETAIL_1, \"sepl_scmhub_ret_com_inf_mip31b() about to look up %d items\", $data_hash.size());\n\n    # scmhub call data list\n    my list $data = ();\n    {\n        my HashIterator $hi($data_hash);\n        while ($hi.next()) {\n            my softint $tid = $hi.getKey();\n            my hash $h = $hi.getValue();\n            $data += (\n                \"LEGAL_ENTITY\": $org_name,\n                \"OPERATING_PARTY\": $op_party,\n                \"PARTY_TYPE\": \"SCM PARTNER\",\n                \"TRANSACTION_TYPE\": \"RMA_GEN_RECEIPT\",\n                \"ORACLE_HEADER_ID\": $h.oid,\n                \"ORACLE_LINE_NUMBER\": $h.line,\n                \"ITEM_NUMBER\": $h.item,\n                \"QORUS_ROW_ID\": $tid,\n\t    );\n        }\n    }\n\n    my string $f = \"scm-ret_com_inf_mip31b\";\n    my hash $ret;\n\n%ifdef QoreDebug\n    # fake response list\n    my list $fl = ();\n    # error count\n    my int $ec = 0;\n    my bool $do_errs = !parse_boolean(getInstanceData(\"no-scmhub-errors\"));\n    foreach my softstring $tid in (keys $data_hash) {\n        my hash $h = (\n            \"QORUS_ROW_ID\": $tid,\n            );\n\t# 10% chance of error on every record\n\tif ($do_errs && !(rand() % 10)) {\n            $h += (\n                \"ORACLE_ORDER_TYPE\": NULL,\n                \"DEALER_CODE\": NULL,\n                \"REASON_CODE\": NULL,\n                \"STATUS\": \"E\",\n                \"ERROR_MSG\": NULL,\n                );\n\t    ++$ec;\n        }\n\telse {\n            $h += (\n                \"ORACLE_ORDER_TYPE\": $org_name == \"UK_OPCO\" ? \"WOM UK Return Order\" : \"DOM IE EXCHANGE Return\",\n                \"DEALER_CODE\": \"dealer123\",\n                \"REASON_CODE\": \"oops\",\n                \"STATUS\": \"C\",\n                \"ERROR_MSG\": NULL,\n\t      );\n\t}\n        $fl += $h;\n    }\n\n    $ret = (\n\t\"x_status\": list((\"STATUS_CODE\": 0, \"ERROR_CODE\": NULL, \"ERROR_DESCRIPTION\": NULL)),\n\t\"x_param_out\": $fl,\n\t);\n\n    log(LL_INFO, \"FAKE_SCMHUB: generated %d correct, %d errors, %d total in fake %s response\", elements $fl - $ec, $ec, elements $fl, $f);\n    log(LL_DEBUG_2, \"data: %N\", $data);\n    log(LL_DEBUG_2, \"ret: %N\", $ret);\n%else\n    $ret = sepl_exec_scmhub($ds, $f, $data);\n%endif\n\n    $errh += sepl_scmhub_check_ret_hash($data, $ret, True, $f);\n\n    # create return hash and check for lookup failures\n    my hash $rv = hash();\n    foreach my hash $h in ($ret.x_param_out) {\n        my softstring $tid = $h.QORUS_ROW_ID;\n        my hash $rh = $data_hash.$tid;\n        if ($h.STATUS != \"C\" || !$h.ORACLE_ORDER_TYPE) {\n            swarning(SCMHUB_ERROR_INFO, sprintf(\"SCM-HUB retrieve doc line failed for order_id %y, line_number %y, transaction_id %y (result: %y)\", $rh.oid, $rh.line, $tid, $h));\n\n            # set transaction hash keys to True in error hash\n            $errh.$tid = True;\n        } else\n            $rv.($rh.oid + \".\" + $rh.line) = (\n                \"order_type\": $h.ORACLE_ORDER_TYPE,\n                \"dealer_code\": $h.DEALER_CODE,\n                \"reason_code\": $h.REASON_CODE,\n                \"type\": \"mip31b\",\n            );\n    }\n\n    return $rv;\n}\n\n#! map of function names to functions\nconst FuncMap = (\n    \"mip31a3\": \\sepl_scmhub_ret_com_inf_mip31a3(),\n    \"mip31a4\": \\sepl_scmhub_ret_com_inf_mip31a4(),\n    \"mip31b\": \\sepl_scmhub_ret_com_inf_mip31b(),\n);\n\nsub mapls_rma_create_mip21_data() {\n    # check if this step should be skipped\n    if (mapls_scmhub_check())\n        return;\n    \n    # setup data from local staging in temp data\n    my list $source_data = mapls_get_scmhub_data();\n    \n    #my int $bs = $source_data.size();\n    # skip non-serialized data\n    #$source_data = select $source_data, $1.serial_number;\n    #log(LL_INFO, \"removed %d non-serialized rows from source data (before: %d after: %d)\", $bs - $source_data.size(), $bs, $source_data.size()); \n\n    if ($source_data.empty()) {\n        swarning(SKIP_WARNING, \"no data to submit to MIP 21; skipping GSI_COMMISSIONING population\");\n        return;\n    }\n\n    my hash $props = getInstanceData();\n\n    # get the source party code (\"UTL\" or \"ADS\")\n    #my string $source_party = get_party_from_org($props.org_name);\n\n    my string $op_party = $source_data[0].source_system;\n\n    # get dynamic data\n    my hash $dd = getDynamicData();\n\n    # call \"retrieve commissioning info\" for each order line and item number\n    # hash of function names -> args: arg hash to the scmhub function\n    my hash $data;\n\n    # get a hash of order_ids\n    my hash $lh;\n\n    foreach my hash $row in ($source_data) {\n        # get scmhub info\n        my string $fn;\n        switch ($dd.mip) {            \n            case \"31a\": {\n                my string $oid = $row.order_id;\n                if ($dd.variant.$oid == 3)\n                    $fn = \"mip31a3\";\n                else if ($dd.variant.$oid == 4)\n                    $fn = \"mip31a4\";\n                else {\n                    swarning(SKIP_WARNING, \"skipping MIP21 for order_id %y; it is MIP 31a %y\", $oid, $dd.variant.$oid);\n                }\n                break;\n            }\n            case \"31b\": {\n                $fn = \"mip31b\";\n                break;\n            }\n            default:\n                throw \"MIP-ERROR\", sprintf(\"don't know how to map mip info %y to an scmhub config for the retrieve commissioning info call\", $dd.mip);\n        }\n        if (!$fn)\n            continue;\n        my softstring $tid = $row.transaction_id;\n        $data.$fn.$tid = (\n            \"oid\": $row.order_id,\n            \"line\": $row.line_number,\n            \"item\": $row.item_number,\n            );\n        $lh.($row.order_id) = True;\n    }\n\n    if (!$data) {\n        swarning(SKIP_WARNING, \"no data to send to MIP 21; skipping step\");\n        return;\n    }\n\n    # get scmhub datasource\n    my OracleDatasourcePool $ds(\"scmhub\");\n\n    # error hash\n    my hash $errh;\n\n    my hash $oth;\n    # first make a lookup for order_type -> shipment_type if possible to skip any rows\n    if ($dd.order_types) {\n        # make a reverse map to get the order IDs\n        my hash $rh;\n        map $rh.($1.value).($1.key) = True, $dd.order_types.pairIterator();\n\n        foreach my string $order_type in ($rh.keyIterator()) {\n            $oth.$order_type = $omqservice.user.commissioning_cache.get($props.org_name, $order_type);\n            if ($oth.$order_type == \"SKIP\") {\n                my hash $sh = $rh.$order_type;\n                # filter out all lines with this order_id\n                my list $rl = select $source_data, !$sh.($1.order_id);\n                swarning(SCMHUB_RESULT, \"skipping GSI_COMMISSIONING population for order IDs: %y; order type: %y (lines removed: %d)\", $sh.keys(), $order_type, $source_data.size() - $rl.size());\n                $source_data = $rl;                \n            }\n        }\n\n        if (!$source_data) {\n            swarning(SKIP_WARNING, \"no data to send to MIP 21; skipping step\");\n            return;\n        }\n\n        log(LL_INFO, \"got order type map: %y\", $oth);\n    }\n\n    # order hash keyed by order_id and line_number \n    my hash $oh;\n\n    # scmhub result hash\n    my hash $srh;\n\n    my HashIterator $hi($data);\n    while ($hi.next()) {\n        log(LL_DEBUG_1, \"key: %y map: %y\", $hi.getKey(), FuncMap);\n        my hash $h = FuncMap.($hi.getKey())($ds, $props.org_name, $op_party, $hi.getValue(), \\$errh);\n        if ($errh)\n            throw \"SCMHUB-COMMISSIONING-INFO-ERROR\", sprintf(\"retrieve commissioning info for %y failed to retrieve order info for all data; see previous errors for more information\", $hi.getKey());\n        log(LL_DEBUG_1, \"got order info lookup hash: %y\", $h);        \n\n        $srh += $h;\n        $oh += $h;\n    }\n\n    # first check for rows to be skipped and filter out that data\n    my list $nsd = ();\n    foreach my hash $row in ($source_data) {\n        my softstring $oid = $row.order_id;\n        my softstring $line = $row.line_number;\n        $row.oidline = $oid + \".\" + $line;\n        my *hash $oih = $oh.($row.oidline);\n        if (!$oih) {\n            delete $oh.($row.oidline);\n            swarning(SCMHUB_RESULT, \"Skipping GSI_COMMISSIONING population for order: %y, line: %s as no order information was retrieved from the scmhub\", $oid, $line);\n            continue;\n        }\n\n        $row.st = $oth.($oih.order_type) ? $oth.($oih.order_type) : $omqservice.user.commissioning_cache.get($props.org_name, $oih.order_type);\n        if ($row.st == \"SKIP\") {\n            delete $oh.($row.oidline);\n            swarning(SCMHUB_RESULT, \"Skipping GSI_COMMISSIONING population for order: %y line: %s; order type: %y shipment_type: %y\", $oid, $line, $oih.order_type, $row.st);\n            continue;\n        }\n\n        $nsd += $row;\n    }\n    if (!$nsd) {\n        swarning(SKIP_WARNING, \"all rows are marked to be skipped; no data written to gsi_commissioning\");\n        return;\n    }\n    $source_data = $nsd;\n\n    # now retrieve order_id -> order_number information from gsi_order_line\n    my OracleDatasourcePool $lsds($props.local_staging);\n\n    # now retrieve dealer_code -> account_number information from gsi_parties\n    my *hash $oah = get_account_hash($props, $oh, $dd.mip == \"31b\");\n\n    # get item information\n    my hash $ih = get_item_hash($props, $source_data);\n\n    # insert data in tables and commit as single transaction\n    on_success $props.mip21_mapper.commit();\n    on_error $props.mip21_mapper.rollback();\n\n    # row count hash\n    my hash $rch;\n\n    foreach my hash $row in ($source_data) {\n        my hash $oih = $oh.($row.oidline);\n        my hash $tih = $ih.($row.item_number);\n\n        # check for skipping by item type\n        if ($omqservice.user.commissioning_cache.skip_item_type($props.org_name, $tih.item_type)) {\n            swarning(SCMHUB_RESULT, \"Skipping GSI_COMMISSIONING population for order: %y line: %s; item: %y item_type: %y: item type is flagged to be skipped\", $row.order_id, $row.line_number, $row.item_number, $tih.item_type);\n            continue;\n        }\n\n        # check for non-numeric characters in order_number\n        if ($row.order_id !~ /^[0-9\\.]*$/)\n            throw \"ORDER-NUMBER-ERROR\", sprintf(\"fatal error processing order_id %y: contains non-numeric characters which cannot be written to CDS\", $row.order_id);\n\n        $row += (\n            \"order_number\": $row.order_id,\n            \"shipment_type\": $row.st,\n            \"dealer_code\": $oih.dealer_code,\n            \"account_number\": $oah.($row.oidline),\n            \"return_reason_code\": $oih.reason_code,\n            \"item_description\": $tih.description,\n            \"item_type\": $tih.item_type,\n            );\n\n        # save header record and add transaction ID to order info hash\n        $props.mip21_mapper.insertRowNoCommit($row, NOTHING, OMQ::LL_DEBUG_1);\n        \n        ++$rch.gsi_commissioning;\n    }\n\n    my hash $ndd = (\n        \"commissioning-info\": $srh,\n        \"mip21\": $rch,\n        );\n    updateDynamicData($ndd);\n\n    if ($rch.gsi_commissioning)\n        log(LL_INFO, \"committing transaction in local staging; row counts: %y\", $rch);\n    else\n        swarning(SKIP_WARNING, \"no rows written to gsi_commissioning\");\n}\n\n*hash sub get_account_hash(hash $props, hash $oh, bool $mip31b) {\n    my hash $oah;\n    if (!$mip31b) {\n        # get a hash of unique dealer codes; ignore missing dealer codes\n        my hash $dh;\n        map $dh.($1.value.dealer_code) += list($1.key), $oh.pairIterator(), $1.value.dealer_code;\n\n        log(LL_DEBUG_1, \"get_account_hash() dh: %y\", $dh);\n\n        if ($dh) {\n%ifdef QoreDebug\n            map $oah.$1 = $1, $dh.keyIterator();\n%else\n            # make select args\n            my hash $sh = (\n                \"columns\": (cop_distinct(\"dealer_code\"), \"account_number\"),\n                \"where\": (\"enabled_flag\": \"Y\", \"status\": op_in(\"C\",\"N\"), \"dealer_code\": op_in($dh.keys())),\n            );\n\n            my *hash $q = $props.gsi_parties.select($sh);\n            # check if we got account_numbers for all dealer codes\n            if ($q.account_number.size() < $dh.size()) {\n                my int $ds = $dh.size();\n                map delete $dh.$1, $q.dealer_code;\n                throw \"ACCOUNT-NUMBER-ERROR\", sprintf(\"query in GSI_PARTIES returned %d account_numbers (%y) for %d dealer_codes; missing dealer_codes: %y\", $q.account_number.size(), $q.account_number, $ds, $dh.keys());\n            }\n            else if ($q.account_number.size() > $dh.size()) {\n                throw \"ACCOUNT-NUMBER-ERROR\", sprintf(\"query in GSI_PARTIES returned %d account_numbers (%y) for %d dealer_codes; result: %y\", $q.account_number.size(), $q.account_number, $dh.size(), $q);\n            }\n            \n            context ($q) \n                map $oah.$1 = %account_number, $dh.%dealer_code;\n%endif\n        }\n    }\n    else {\n%ifdef QoreDebug\n        map $oah.($1.dealer_code) = $1.dealer_code, $oh.iterator();\n%else\n        # process rows for mip31b\n        my hash $sd = getStaticData();\n        my hash $nh;\n        my hash $th;\n        foreach my hash $h in ($sd.gsi_fb) {\n            my string $oidline = $h.system_reference_id + \".\" + $h.system_reference_line;\n            my string $osdr = $h.orig_sys_document_ref;\n            if ($osdr =~ /_/)\n                $osdr =~ s/_.*$//;\n            $th.$oidline = True;\n            $nh.$osdr += list($oidline);\n        }\n        \n        log(LL_DEBUG_1, \"nh: %y\", $nh);\n        \n        my hash $sh = (\n            \"columns\": (\"orig_sys_document_ref\", \"orig_sys_customer_ref\"),\n            \"where\": (\"orig_sys_document_ref\": op_in($nh.keys())),\n            );\n        \n        my *hash $q = $props.gsi_oe_headers_iface.select($sh);\n        context ($q) \n            map $oah.$1 = %orig_sys_customer_ref, $nh.%orig_sys_document_ref;\n        if ($oah.size() != $th.size()) {\n            my string $dummy_value = getWorkflowMetadata().name =~ /UK-/ ? \"88888888\" : \"7777777\";\n            \n            my softlist $ml = map $1, $th.keyIterator(), !$oah.$1;\n            swarning(SCMHUB_ERROR_INFO, \"query in GSI_OE_HEADERS_IFACE returned account_numbers mapping to %d lines (%y) for %d orig_sys_document_ref values; missing orig_sys_document_ref values for the following lines: %y; hardcoding to %y\", $oah.size(), $oah, $nh.size(), $ml, $dummy_value);\n            map $oah.$1 = $dummy_value, $ml;\n        }\n%endif\n    }\n\n    log(LL_DEBUG_1, \"got account_number lookup hash: %y\", $oah);\n    return $oah;\n}\n\nhash sub get_item_hash(hash $props, list $source_data) {\n    my hash $ih;\n%ifdef QoreDebug\n    map $ih.($1.item_number) = (\"item_number\": $1.item_number, \"item_id\": $1.item_number, \"description\": \"test description\", \"item_type\": 123), $source_data;\n%else\n    # get a list of unique item_numbers for the queries below\n    my hash $inh;\n    map $inh.($1.item_number) = True, $source_data;\n\n    log(LL_DEBUG_1, \"get_item_hash() inh: %y\", $inh);\n    # make select args\n    my hash $sh = (\n        \"columns\": (\"item_number\", \"item_id\", \"description\", \"item_type\"),\n        \"where\": (\"item_number\": op_in($inh.keys())),\n        );\n\n    my *hash $q = $props.gsi_items.select($sh);\n    context ($q) $ih.%item_number = %%;\n    if ($ih.size() != $inh.size()) {\n        my softlist $ml = select $inh.keyIterator(), !$ih.$1;\n        throw \"ITEM-ERROR\", sprintf(\"query in GSI_ITEMS returned %d items (%y) for %d item_numbers; missing item_numbers: %y\", $ih.size(), $ih, $inh.size(), $ml);\n    }\n%endif\n    log(LL_DEBUG_1, \"got item lookup hash: %y\", $ih);\n    return $ih;\n}\n","created": "2015-01-20 12:56:25.465299 +01:00","modified": "2015-01-20 12:56:25.465299 +01:00","createdby": "omq","modifiedby": "omq","tags": {},"source": "/Users/pchalupny/workspace/builds/qorus/user/31-RMA_RECEIPT/mapls_rma_create_mip21_data-v1.0.qfd","offset": "69","host": "panda.local","user": "<shell-unknown>"},{"type": "validation","name": "mapls_rma_create_mip21_data_val","version": "1.0","function_instanceid": 414,"function_type": "VALIDATION","description": "MIP 31 -> 21 GSI_COMMISSIONING population validation function","author": "Marian Bonda","body": "string sub mapls_rma_create_mip21_data_val() {\n    my hash $props = getInstanceData();\n    my OracleDatasourcePool $ds($props.local_staging);\n\n    my softint $wfiid = getWorkflowInstanceData(\"workflow_instanceid\");\n\n%ifdef QoreDebug\n    my string $res = $ds.selectRow(\"select case when exists (select 1 from gsi_commissioning where i_sepl_created_id = %v) then 'COMPLETE' else 'RETRY' end as result %s\", $wfiid, $ds.getDriverName() == \"oracle\" ? \"from dual\" : \"\").result;\n%else\n    my string $res = $ds.selectRow(\"select case when exists (select 1 from gsi_commissioning where i_sepl_created_id = %v) then 'COMPLETE' else 'RETRY' end as result from dual\", $wfiid).result;\n%endif\n\n    log(LL_INFO, \"validating gsi_commissioning for i_sepl_created_id = %y results in: %y\", $wfiid, $res);\n    return $res;\n}\n","created": "2015-01-20 12:56:25.416316 +01:00","modified": "2015-01-20 12:56:25.416316 +01:00","createdby": "omq","modifiedby": "omq","tags": {},"source": "/Users/pchalupny/workspace/builds/qorus/user/31-RMA_RECEIPT/mapls_rma_create_mip21_data-v1.0.qfd","offset": "47","host": "panda.local","user": "<shell-unknown>"}]}],"wffuncs": [{"type": "onetimeinit","name": "mapls_rma_receipt_inem_init","version": "1.0","function_instanceid": 399,"function_type": "GENERIC","description": "RMA Receipt MIP31 INEM one time initialization function","author": "Marian Bonda","created": "2015-01-20 12:56:25.266121 +01:00","modified": "2015-01-20 12:56:25.266121 +01:00","source": "/Users/pchalupny/workspace/builds/qorus/user/31-RMA_RECEIPT/mapls_rma_receipt_inem_init-v1.0.qfd","line": "7","body": "%require-types\n\nconst Mip37_Wf = \"$CC-37-INV_RETAIL_CLOSE_INTER_ORG_TRANS-IN\";\n\n#! default values for system properties\nconst Defaults = FileDefaults+ (\n    \"mip21_wf\": Mip21_Wf,\n    \"mip37_wf\": Mip37_Wf,\n    );\n\n#! system properties needed for this workflow\nconst Props = keys Defaults + (\"local_staging\", \"base_path\");\n\n#! list of tables\nconst TableList = (\"gsi_brep_trans\", \"gsi_snr\");\n\n#! maps Oracle (target) GSI_BREP_TRANS fields from RMA Receipt (source) fields\nconst BrepTans_Mapper = (    \n    \"source_system\": True,\n    \"order_id\": True,\n    \"line_number\": True,\n    \"item_number\": True,\n    \"dispatched_quantity\": True,\n    \"subinventory\": True,\n    \"status_date\": True,\n    \"system_time\": \"status_date\",\n    \"lp_order_id\": \"source_system_reference\",\n    );\n    \n#! maps Oracle (target) GSI_SNR fields from RMA Receipt (source) fields\nconst Snr_Mapper = (    \n    \"transaction_id\": \"_id\",\n    \"source_system\": True,\n    \"lp_order_id\": \"source_system_reference\",\n    \"order_id\": True,\n    \"serial_number\": True,\n    );\n\n#! constant mapping hash\nconst crec_brep_trans = (\n    \"target_system\": \"H3G\", \n    \"message_type\": \"RMA_RECEIPT\",\n    \"line_status\": \"400\",\n    \"line_type\": \"01\",\n    );\n\nconst crec_snr = (\n    \"target_system\": \"H3G\", \n    \"message_type\": \"RMA_RECEIPT\",\n    );\n\n#! initializes the workflow; checks required properties and sets up the mapper object\n/** @throw PROPERTY-ERROR missing system property (see @ref Props for required properties)\n*/\nsub mapls_rma_receipt_inem_init() {\n    # get the workflow name\n    #my string $wf = getWorkflowMetadata().name;\n\n    # get required properties\n    my hash $props = process_paths(sepl_prop_get(Props, Defaults));\n\n    # get org name\n    my string $org = sepl_get_org_name();\n\n    # add other properties\n    $props += (\n\t\"tablelist\" : TableList, # list of tables\n        \"org_name\" : $org, # set org name\n        \"CC\" : sepl_get_cc(), # get the country code           \n        \"mip21_wf\": process_workflow($props.mip21_wf),\n        \"mip37_wf\": process_workflow($props.mip37_wf),\n        # copy the dynamic data to the split off workflow instance if applicable\n        \"copy_dynamic\": (\"order_types\", \"gl_account_id\", \"retail_extra_id\", \"complete_skip\"),\n\t);\n\n    if ($props.CC == \"UK\"){\n        $props.source_system = \"UTL\";\n    } else {\n        $props.source_system = \"ADS\";\n    }\n\n    # save properties in instance data\n    updateInstanceData($props);\n\n    # make sure the datasource is defined and exists\n    my OracleDatasourcePool $ds(getInstanceData(\"local_staging\"));\n\n    log(LL_INFO, \"starting with the following properties: %y\", getInstanceData());\n\n    my hash $brep_trans_crec = crec_brep_trans + (\"source_system\": $props.source_system);\n    my hash $snr_crec = crec_snr + (\"source_system\": $props.source_system);\n\n    # create brep_trans mapper objects\n    my EbsSingleTableInboundMapper $brep_trans_mapper($ds, \"gsi_brep_trans\", BrepTans_Mapper, NOTHING, $brep_trans_crec);\n    # create snr mapper objects\n    my EbsSingleTableInboundMapper $snr_mapper($ds, \"gsi_snr\", Snr_Mapper, NOTHING, $snr_crec);\n    # create gsi_commissioning (MIP 21 IF) mapper object\n    my EbsSingleTableInboundMapper $mip21_mapper($ds, \"gsi_commissioning\", Commissioning_Mapper, NOTHING, crec_commissioning);\n\n    # get tables for select statements\n    my Table $gsi_parties($ds, \"gsi_parties\");\n    my Table $gsi_items($ds, \"gsi_items\");\n\n    # create file mapper object and save in instance data\n    updateInstanceData((\"brep_trans_mapper\": $brep_trans_mapper,\n                        \"snr_mapper\": $snr_mapper,\n                        \"mip21_mapper\": $mip21_mapper,\n                        \"autojoin\": AutoJoin_BrepTrans_Snr,\n                        \"gsi_parties\": $gsi_parties,\n                        \"gsi_items\": $gsi_items));\n}\n","createdby": "omq","modifiedby": "omq","tags": {},"offset": "7","host": "panda.local","user": "<shell-unknown>"},{"type": "errorfunction","name": "sepl_errorfunction_base","version": "1.0","function_instanceid": 35,"function_type": "GENERIC","description": "the base errorfunction for all SEPL workflows; this will contain common error definitions for all SEPL workflows","created": "2015-01-20 12:56:22.035704 +01:00","modified": "2015-01-20 12:56:22.035704 +01:00","source": "/Users/pchalupny/workspace/erp-sepl/src/libraries/sepl_errorfunction_base-v1.0.qfd","line": "5","body": "#! returns common error definitions for all SEPL workflows\n/** Requires the ERROR constant for error string definitions.  Note the default values for each error:\n    - \\c status: OMQ::StatError\n    - \\c severity: OMQ::ES_Major\n    - \\c business: \\c False\n    @return common error definitions for all SEPL workflows\n*/\nhash sub sepl_errorfunction_base() {\n    return (\n\n\tERROR::DB_CLUSTER_FAILOVER: (\n\t    \"desc\"          : \"DB cluster failover error; the system should autorecover\",\n\t    \"status\"        : OMQ::StatRetry,\n\t    \"retry-delay\"   : 2s,\n\t),\n\n\tERROR::PROPERTY_ERROR: (\n\t    \"desc\"          : \"A required system property is not set\",\n\t),\n\n\tERROR::SOAP_AUTHENTICATION_ERROR: (\n\t    \"desc\"          : \"A required system property is not set giving SOAP authentication information\",\n\t),\n\n\tERROR::UNBLOCK_ERROR: (\n\t    \"desc\"          : \"The order cannot be unblocked for processing\",\n\t),\n\n\tERROR::EBS_ERROR: (\n\t    \"desc\"          : \"Oracle E-Business Suite returned an error code in the response to a request\",\n\t),\n\n\tERROR::DB_PACKAGE_STATE_ERROR: (\n\t    \"desc\"          : \"Oracle package has been redeployed; the datasource will be reset and the order should be recovered automatically\",\n\t    \"status\"        : OMQ::StatRetry,\n\t    \"retry-delay\"   : 1m,\n\t),\n\n\tERROR::DATASOURCE_ERROR: (\n\t    \"desc\"          : \"the connection to the DB was lost or could not be established; orders will be retried when this error is thrown\",\n\t    \"status\"        : OMQ::StatRetry,\n\t    \"retry-delay\"   : 10m,\n\t),\n\n\tERROR::SCMHUB_ERROR: (\n\t    \"desc\"          : \"SCMHUB business error. See error detail for more info\",\n\t    \"business\"      : True,\n\t),\n\n\tERROR::BUSINESS_ERROR: (\n\t    \"desc\"          : \"A common business error. See error detail for more info\",\n\t    \"business\"      : True,\n\t),\n\n\t\"SOCKET-SSL-ERROR\" : (\n\t    \"desc\"          : \"SSL unified socket error. Probably a proxy outage. Trying to retry...\",\n\t    \"status\"        : OMQ::StatRetry,\n\t    \"retry-delay\"   : 30m,\n\t),\n\n\t\"HTTP-CLIENT-RECEIVE-ERROR\" : (\n\t    \"desc\"          : \"HTTP connection error. Probably a proxy outage. Trying to retry...\",\n\t    \"status\"        : OMQ::StatRetry,\n\t    \"retry-delay\"   : 30m,\n\t),\n\n\t\"SOCKET-TIMEOUT\" : (\n\t    \"desc\"          : \"A connection timeout. Probably a proxy outage. Trying to retry...\",\n\t    \"status\"        : OMQ::StatRetry,\n\t    \"retry-delay\"   : 30m,\n\t),\n\n\tERROR::MISSING_REASON_MAPPING: (\n\t    \"desc\"          : \"missing reason code mapping\",\n\t    \"business\"      : True,\n\t),\n\n\tERROR::SMTP_DATA_EXCEPTION: (\n\t    \"desc\"          : \"error in SMTP communication\",\n\t    \"status\"        : OMQ::StatRetry,\n\t),\n\n\tERROR::FILE_ARCHIVE_ERROR: (\n\t    \"desc\"          : \"error saving/moving archive file\",\n\t    \"status\"        : OMQ::StatRetry,\n\t    \"retry-delay\"   : 1m,\n\t),\n\n\tERROR::FILE_OPEN_ERROR: (\n\t    \"desc\"          : \"error opening file, possibly due to some kind of unknown filesystem synchronization delay\",\n\t    \"status\"        : OMQ::StatRetry,\n\t    \"retry-delay\"   : 1m,\n\t),\n\n\t# NOTE: does not result in an error due to the low severity; just used for reporting purposes and visibility via the API/GUI\n\tERROR::SCMHUB_ERROR_INFO: (\n\t    \"desc\"          : \"scmhub call resulted in an error, see details for more information\",\n\t    \"severity\"      : OMQ::ES_Warning,\n\t),\n\n\t# NOTE: does not result in an error due to the low severity; just used for reporting purposes and visibility via the API/GUI\n\tERROR::SCMHUB_RESULT: (\n\t    \"desc\"          : \"scmhub call result information record, see details for more information\",\n\t    \"severity\"      : OMQ::ES_Info,\n\t),\n\n\t# NOTE: does not result in an error due to the low severity; just used for reporting purposes and visibility via the API/GUI\n\tERROR::SCMHUB_ERROR_SUMMARY: (\n\t    \"desc\"          : \"one or more scmhub calls resulted in an error, see details for more information\",\n\t    \"severity\"      : OMQ::ES_Warning,\n\t),\n\n\tERROR::SCM_SPLIT_ERROR: (\n\t    \"desc\"          : \"See warnings in the parent order\",\n\t    \"business\"      : True,\n\t),\n\n\tERROR::TRUNCATION_WARNING: (\n\t    \"desc\"          : \"input data was truncated for inserting into the DB; see details for more information\",\n\t    \"severity\"      : OMQ::ES_Warning,\n\t),\n\n\tERROR::SKIP_WARNING: (\n\t    \"desc\"          : \"a record was skipped because it did not meet the input criteria; see details for more information\",\n\t    \"severity\"      : OMQ::ES_Warning,\n\t),\n\n\tERROR::FILENAME_DUPLICITY_ERROR : (\n\t    \"desc\" : \"Input filename duplicity. Perform manual check of the data\",\n\t    \"business\" : True,\n\t),\n\n\tERROR::FILENAME_DUPLICATION_ERROR : (\n\t    \"desc\" : \"Input filename duplication. Perform manual check of the data\",\n\t    \"business\" : True,\n\t),\n\n\tERROR::INVALID_KEY: (\n\t    \"desc\"          : \"the given key did not exist in the specified queue; maybe a required workflow is not running; see details for more information\",\n\t    \"status\"        : OMQ::StatRetry,\n\t    \"retry-delay\"   : 10m,\n\t),\n\n\tERROR::TRANSACTION_LOCK_TIMEOUT: (\n\t    \"desc\"          : \"a shared database connection could not be acquired within the timeout period (normally 2 minutes)\",\n\t    \"status\"        : OMQ::StatRetry,\n\t    \"retry-delay\"   : 15m,\n\t),\n\n\tERROR::SOCKET_CONNECT_ERROR: (\n\t    \"desc\"          : \"the remote host could not be contacted; see details for more information\",\n\t    \"status\"        : OMQ::StatRetry,\n\t    \"retry-delay\"   : 15m,\n\t),\n\n\tERROR::SCMHUB_TIMEOUT: (\n\t    \"desc\"          : \"the scmhub reported a time-out; the operation will be retried; see details for more information\",\n\t    \"status\"        : OMQ::StatRetry,\n\t    \"retry-delay\"   : 30s, /*,, just fix the syntax highlighting for perl */\n\t),\n\n    ERROR::HYBRIS_RETRY: (\n\t    \"desc\"          : \"the Hybris/O2 SOAP server returned a technical retry error; the operation will be retried; see details for more information\",\n\t    \"status\"        : OMQ::StatRetry,\n\t    \"retry-delay\"   : 5m,\n\t),\n\n    ERROR::MIP03_RETRY: (\n\t    \"desc\"          : \"MIP03 cannot find barcode data in GSI_ITEMS. It's usually caused by pending MIP01 processing.\",\n\t    \"status\"        : OMQ::StatRetry,\n\t    \"retry-delay\"   : 1h,\n\t),\n\n    ERROR::WINCASH_REQUEST_ERROR: (\n         \"desc\" : \"Error in a WINCASH request. Perform check of the data sent by WINCASH\",\n         \"business\" : True,\n\t),\n\n\t); # return hash\n\n}\n","createdby": "omq","modifiedby": "omq","tags": {},"offset": "5","host": "panda-2.local","user": "pchalupny"},{"type": "attachfunction","name": "isepl_attach_base","version": "1.0","function_instanceid": 29,"function_type": "GENERIC","description": "library function for isepl attach functions (can be used as an attach function as well if no additional logic is necessary)","created": "2015-01-20 12:56:21.873505 +01:00","modified": "2015-01-20 12:56:21.873505 +01:00","source": "/Users/pchalupny/workspace/builds/qorus/user/libraries/isepl_attach_base-v1.0.qfd","line": "4","body": "#! returns \\c True if the order was blocked, \\c False if not\nbool sub isepl_attach_base() {\n    # get workflow and order info\n    my hash $h = getWorkflowInstanceData();\n    # set status to BLOCKED if currently READY or SCHEDULED and the system property \"block\" is set for this wf\n    if (inlist($h.initstatus, (OMQ::StatReady, OMQ::StatScheduled)) && parseBoolean($omqservice.system.prop.get($h.name, \"block\"))) {\n        # set BLOCKED status when attach function exits\n        setBlocked();\n        # insert a note on the order why it was blocked\n        setOrderInfo((\"op_comment\": sprintf(\"order blocked on %y in attach function due to property %s.block == True\", now_us(), $h.name)));\n        return True;\n    }\n    return False;\n}\n","createdby": "omq","modifiedby": "omq","tags": {},"offset": "4","host": "panda.local","user": "<shell-unknown>"}],"exec": [],"exec_count": 0,"connections": [],"groups": [{"name": "UK","enabled": true,"size": 144},{"name": "UK-OPCO","enabled": true,"size": 135},{"name": "UK-OPCO-IN","enabled": true,"size": 68},{"name": "UK-OPCO-IN-RMA_RECEIPT","enabled": true,"size": 3},{"name": "UK-31-RMA_RECEIPT","enabled": true,"size": 2},{"name": "UK-31-RMA_RECEIPT_INEM-IN","enabled": true,"size": 1},{"name": "UK-31-RMA_RECEIPT_INEM-IN v1.0","enabled": true,"size": 1}],"alerts": [],"options": []}
